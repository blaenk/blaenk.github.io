<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Algorithms - Blaenk Denum</title>
  <meta name="author" content="Jorge Israel Peña">
  <meta name="description" content="AKA Blaenk Denum">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="/favicon.png" rel="shortcut icon">
  <link href='http://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Merriweather:900italic,900,700italic,400italic,700,400,300italic,300' rel='stylesheet' type='text/css'>
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='/css/screen.css' rel='stylesheet' type='text/css' />
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured"></script>
  <script src="https://rawgit.com/ekalinin/typogr.js/master/typogr.min.js"></script>
  <script src='/js/blaenk.js' type='text/javascript'></script>
</head>
<body>
  <div class="page-wrapper">
    <header id="header">
  <div id="stamp">
    <h1 id="name">
      <a href="/">
        <span class="emboldened">Jorge</span>.Israel.<span class="emboldened">Peña</span>
      </a>
    </h1>
    <h4 id="pseudonym">
      AKA <span class="emboldened">Blaenk</span>.Denum
    </h4>
  </div>
  <nav id="main-nav">
    <ul class="main">
      <li><a href="/about/">About</a></li>
      <li><a href="/notes/">Notes</a></li>
      <li><a href="/work/">Work</a></li>
      <li><a href="/lately/">Lately</a></li>
      <li><a id="search_btn">Search</a></li>
    </ul>
  </nav>
  <nav id="mobile-nav">
    <div class="menu">
      <a class="button">Menu</a>
      <div class="container">
        <ul class="main">
          <li><a href="/about/">About</a></li>
          <li><a href="/notes/">Notes</a></li>
          <li><a href="/work/">Work</a></li>
          <li><a href="/lately/">Lately</a></li>
        </ul>
      </div>
    </div>
    <div class="search">
      <a class="button"></a>
      <div class="container">
        <form action="http://google.com/search" method="get">
          <input type="text" name="q" results="0">
          <input type="hidden" name="q" value="site:blaenkdenum.com">
        </form>
      </div>
    </div>
  </nav>
</header>
<form class="desk_search" action="http://google.com/search" method="get">
  <input id="search" type="text" name="q" results="0" placeholder="Search" autocomplete="off" spellcheck="false">
  <input type="hidden" name="q" value="site:blaenkdenum.com">
</form>

    
        <article class="post">
  <h2 class="title"><a href="/notes/algorithms"><span>Algorithms</span></a></h2>
  <div class="entry-content"><p>What follows are some notes on algorithms I&#39;ve been reviewing from <a href="http://amzn.com/032157351X">Algorithms</a> by Robert Sedgewick and Kevin Wayne, <a href="http://amzn.com/1849967202">The Algorithm Design Manual</a> by Steven S. Skiena, and other sources around the Internet <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> <sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup> <sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup>. I wanted to write some notes on the material so that I could easily look back on it, but mainly so that I could be sure that I understand the material.</p>

<nav id="toc">
<h3>Contents</h3><ol>
<li>
<a href="#approaches">Approaches</a>
<ol>
<li>
<a href="#strategies">Strategies</a>
</li>
<li>
<a href="#modeling">Modeling</a>
</li>
<li>
<a href="#techniques">Techniques</a>
</li>
<li>
<a href="#intractability">Intractability</a>
</li>
</ol>
</li>
<li>
<a href="#analysis">Analysis</a>
<ol>
<li>
<a href="#summations">Summations</a>
</li>
<li>
<a href="#logarithms">Logarithms</a>
</li>
<li>
<a href="#bounds">Bounds</a>
</li>
<li>
<a href="#dominance-relations">Dominance Relations</a>
<ol>
<li>
<a href="#sum-of-bounds">Sum of Bounds</a>
</li>
<li>
<a href="#product-of-bounds">Product of Bounds</a>
</li>
</ol>
</li>
<li>
<a href="#master-theorem">Master Theorem</a>
</li>
<li>
<a href="#approximations">Approximations</a>
</li>
</ol>
</li>
<li>
<a href="#bitwise-operations">Bitwise Operations</a>
<ol>
<li>
<a href="#parity">Parity</a>
</li>
<li>
<a href="#bitwise-set-operations">Bitwise Set Operations</a>
</li>
</ol>
</li>
<li>
<a href="#integers">Integers</a>
</li>
<li>
<a href="#arrays">Arrays</a>
</li>
<li>
<a href="#sorting">Sorting</a>
<ol>
<li>
<a href="#selection-sort">Selection Sort</a>
</li>
<li>
<a href="#insertion-sort">Insertion Sort</a>
</li>
<li>
<a href="#shell-sort">Shell Sort</a>
</li>
<li>
<a href="#merge-sort">Merge Sort</a>
<ol>
<li>
<a href="#top-down">Top-Down</a>
<ol>
<li>
<a href="#merge-sort-improvements">Merge Sort Improvements</a>
</li>
</ol>
</li>
<li>
<a href="#bottom-up">Bottom-Up</a>
</li>
</ol>
</li>
<li>
<a href="#quick-sort">Quick Sort</a>
<ol>
<li>
<a href="#quick-sort-improvements">Quick Sort Improvements</a>
</li>
<li>
<a href="#three-way-partitioning">Three-way Partitioning</a>
</li>
</ol>
</li>
</ol>
</li>
<li>
<a href="#heaps">Heaps</a>
<ol>
<li>
<a href="#heap-insertion">Heap Insertion</a>
</li>
<li>
<a href="#heap-removal">Heap Removal</a>
</li>
<li>
<a href="#heap-sort">Heap Sort</a>
</li>
<li>
<a href="#median-maintenance">Median Maintenance</a>
</li>
</ol>
</li>
<li>
<a href="#selection">Selection</a>
</li>
<li>
<a href="#binary-search-trees">Binary Search Trees</a>
<ol>
<li>
<a href="#bst-structure">BST Structure</a>
</li>
<li>
<a href="#bst-traversal">BST Traversal</a>
<ol>
<li>
<a href="#morris-traversal">Morris Traversal</a>
</li>
</ol>
</li>
<li>
<a href="#bst-deletion">BST Deletion</a>
</li>
<li>
<a href="#bst-select">BST Select</a>
</li>
</ol>
</li>
<li>
<a href="#search-trees">2-3 Search Trees</a>
<ol>
<li>
<a href="#tree-searching">2-3 Tree Searching</a>
</li>
<li>
<a href="#tree-insertion">2-3 Tree Insertion</a>
</li>
</ol>
</li>
<li>
<a href="#red-black-trees">Red-Black Trees</a>
<ol>
<li>
<a href="#red-black-tree-insertion">Red-Black Tree Insertion</a>
</li>
<li>
<a href="#red-black-tree-deletion">Red-Black Tree Deletion</a>
<ol>
<li>
<a href="#red-black-tree-balance">Red-Black Tree Balance</a>
</li>
</ol>
</li>
</ol>
</li>
<li>
<a href="#hash-tables">Hash Tables</a>
<ol>
<li>
<a href="#hash-functions">Hash Functions</a>
</li>
<li>
<a href="#pathological-data-sets">Pathological Data Sets</a>
</li>
<li>
<a href="#load-factor">Load Factor</a>
</li>
<li>
<a href="#separate-chaining">Separate Chaining</a>
</li>
<li>
<a href="#double-hashing">Double Hashing</a>
</li>
<li>
<a href="#linear-probing">Linear Probing</a>
<ol>
<li>
<a href="#linear-probing-deletion">Linear Probing Deletion</a>
</li>
</ol>
</li>
<li>
<a href="#sparse-vectors">Sparse Vectors</a>
</li>
</ol>
</li>
<li>
<a href="#bloom-filters">Bloom Filters</a>
</li>
<li>
<a href="#graphs">Graphs</a>
<ol>
<li>
<a href="#undirected-graphs">Undirected Graphs</a>
<ol>
<li>
<a href="#depth-first-search">Depth-First Search</a>
</li>
<li>
<a href="#breadth-first-search">Breadth-First Search</a>
</li>
<li>
<a href="#connected-components">Connected Components</a>
</li>
<li>
<a href="#cycle-detection">Cycle Detection</a>
</li>
<li>
<a href="#bipartite-detection">Bipartite Detection</a>
</li>
</ol>
</li>
<li>
<a href="#directed-graphs">Directed Graphs</a>
<ol>
<li>
<a href="#digraph-reachability">Digraph Reachability</a>
</li>
<li>
<a href="#directed-cycle-detection">Directed Cycle Detection</a>
</li>
<li>
<a href="#topological-order">Topological Order</a>
</li>
<li>
<a href="#strong-connectivity">Strong Connectivity</a>
</li>
<li>
<a href="#all-pairs-reachability">All-Pairs Reachability</a>
</li>
</ol>
</li>
<li>
<a href="#dynamic-connectivity">Dynamic Connectivity</a>
<ol>
<li>
<a href="#quick-find">Quick-Find</a>
</li>
<li>
<a href="#quick-union">Quick-Union</a>
</li>
<li>
<a href="#weighted-quick-union">Weighted Quick-Union</a>
<ol>
<li>
<a href="#path-compression">Path Compression</a>
</li>
</ol>
</li>
</ol>
</li>
<li>
<a href="#minimum-cut">Minimum Cut</a>
</li>
<li>
<a href="#minimum-spanning-trees">Minimum Spanning Trees</a>
<ol>
<li>
<a href="#prim39s-algorithm">Prim&#39;s Algorithm</a>
<ol>
<li>
<a href="#eager-prim39s-algorithm">Eager Prim&#39;s Algorithm</a>
</li>
</ol>
</li>
<li>
<a href="#kruskal39s-algorithm">Kruskal&#39;s Algorithm</a>
</li>
</ol>
</li>
<li>
<a href="#shortest-paths">Shortest Paths</a>
<ol>
<li>
<a href="#dijkstra39s-algorithm">Dijkstra&#39;s Algorithm</a>
</li>
<li>
<a href="#topological-sort">Topological Sort</a>
</li>
<li>
<a href="#parallel-job-scheduling">Parallel Job Scheduling</a>
</li>
<li>
<a href="#bellman-ford-algorithm">Bellman-Ford Algorithm</a>
</li>
</ol>
</li>
<li>
<a href="#constraint-satisfaction-problems">Constraint Satisfaction Problems</a>
<ol>
<li>
<a href="#backtracking-search">Backtracking Search</a>
</li>
<li>
<a href="#k-consistency">K-Consistency</a>
</li>
<li>
<a href="#tree-structured-csps">Tree-Structured CSPs</a>
</li>
<li>
<a href="#cutset-conditioning">Cutset Conditioning</a>
</li>
<li>
<a href="#iterative-algorithms">Iterative Algorithms</a>
</li>
</ol>
</li>
</ol>
</li>
<li>
<a href="#strings">Strings</a>
<ol>
<li>
<a href="#string-rotation">String Rotation</a>
</li>
<li>
<a href="#string-sorting">String Sorting</a>
<ol>
<li>
<a href="#counting-sort">Counting Sort</a>
</li>
<li>
<a href="#least-significant-digit-sort">Least Significant Digit Sort</a>
</li>
<li>
<a href="#most-significant-digit-sort">Most Significant Digit Sort</a>
</li>
<li>
<a href="#three-way-string-quicksort">Three-way String QuickSort</a>
</li>
</ol>
</li>
<li>
<a href="#tries">Tries</a>
<ol>
<li>
<a href="#trie-deletion">Trie Deletion</a>
</li>
<li>
<a href="#ternary-search-trees">Ternary Search Trees</a>
</li>
</ol>
</li>
<li>
<a href="#substring-search">Substring Search</a>
<ol>
<li>
<a href="#brute-force-substring-search">Brute-Force Substring Search</a>
</li>
<li>
<a href="#knuth-morris-pratt">Knuth-Morris-Pratt</a>
<ol>
<li>
<a href="#kmp-dfa-composition">KMP DFA Composition</a>
</li>
<li>
<a href="#preventing-backtracking-in-kmp">Preventing Backtracking in KMP</a>
</li>
<li>
<a href="#kmp-dfa-construction">KMP DFA Construction</a>
</li>
<li>
<a href="#kmp-search">KMP Search</a>
</li>
</ol>
</li>
<li>
<a href="#boyer-moore">Boyer-Moore</a>
<ol>
<li>
<a href="#bm-skip-table">BM Skip Table</a>
</li>
<li>
<a href="#bm-search">BM Search</a>
</li>
</ol>
</li>
<li>
<a href="#rabin-karp">Rabin-Karp</a>
</li>
</ol>
</li>
<li>
<a href="#regular-expressions">Regular Expressions</a>
<ol>
<li>
<a href="#regex-match-checking">Regex Match Checking</a>
</li>
<li>
<a href="#regex-nfa-construction">Regex NFA Construction</a>
</li>
</ol>
</li>
<li>
<a href="#data-compression">Data Compression</a>
<ol>
<li>
<a href="#run-length-encoding">Run-Length Encoding</a>
</li>
<li>
<a href="#huffman-compression">Huffman Compression</a>
</li>
<li>
<a href="#lzw-compression">LZW Compression</a>
</li>
</ol>
</li>
</ol>
</li>
<li>
<a href="#greedy-algorithms">Greedy Algorithms</a>
</li>
<li>
<a href="#b-trees">B-Trees</a>
<ol>
<li>
<a href="#b-tree-insertion">B-Tree Insertion</a>
</li>
</ol>
</li>
<li>
<a href="#suffix-arrays">Suffix Arrays</a>
</li>
<li>
<a href="#network-flow">Network-Flow</a>
<ol>
<li>
<a href="#ford-fulkerson">Ford-Fulkerson</a>
</li>
</ol>
</li>
<li>
<a href="#geometric-algorithms">Geometric Algorithms</a>
<ol>
<li>
<a href="#augmented-bst-as-interval-tree">Augmented BST as Interval Tree</a>
</li>
<li>
<a href="#interval-trees">Interval Trees</a>
</li>
<li>
<a href="#intersection-queries">Intersection Queries</a>
</li>
<li>
<a href="#one-dimensional-range-count">One-Dimensional Range Count</a>
</li>
<li>
<a href="#line-segment-intersection">Line Segment Intersection</a>
</li>
<li>
<a href="#rectangle-intersection">Rectangle Intersection</a>
</li>
</ol>
</li>
<li>
<a href="#dynamic-programming">Dynamic Programming</a>
<ol>
<li>
<a href="#maximum-weight-independent-set">Maximum-Weight Independent Set</a>
</li>
<li>
<a href="#knapsack-problem">Knapsack Problem</a>
</li>
</ol>
</li>
<li>
<a href="#np-complete-problems">NP-Complete Problems</a>
</li>
</ol>
</nav>
<h1 id="approaches">
<span class="hash">#</span>
<a href="#approaches" class="header-link">Approaches</a>
</h1><h2 id="strategies">
<span class="hash">#</span>
<a href="#strategies" class="header-link">Strategies</a>
</h2>
<p>Some general strategies to approaching a given problem:</p>

<ul>
<li><strong>concrete examples</strong>: manually solve concrete instances and build a general solution</li>
<li><strong>case analysis</strong>: split the input/execution into a number of cases and solve each in isolation</li>
<li><strong>iterative refinement</strong>: brute-force and improve upon it</li>
<li><strong>reduction</strong>: use well-known solution to another problem as subroutine</li>
<li><strong>graph modeling</strong>: model the problem as a graph</li>
</ul>
<h2 id="modeling">
<span class="hash">#</span>
<a href="#modeling" class="header-link">Modeling</a>
</h2>
<ul>
<li><strong>permutations</strong>: arrangements, tours, orderings, or sequences</li>
<li><strong>subsets</strong>: clusters, collections, committees, groups, packagings, or selections</li>
<li><strong>trees</strong>: hierarchies, dominance relationships, ancestor/descendant relationships, or taxonomies</li>
<li><strong>graphs</strong>: networks, circuits, webs, relationships</li>
<li><strong>points</strong>: sites, positions, data records, locations</li>
<li><strong>polygons</strong>: shapes, regions, configurations, boundaries</li>
<li><strong>strings</strong>: text, characters, patterns, labels</li>
</ul>
<h2 id="techniques">
<span class="hash">#</span>
<a href="#techniques" class="header-link">Techniques</a>
</h2>
<ul>
<li><strong>divide-and-conquer</strong>: decompose the problem into two or more sub-problems until they are simple enough to solve directly, <strong>then combine the results</strong></li>
<li><strong>greedy algorithms</strong>: make locally optimum, seemed-like-a-good-idea-at-the-time decisions in stages and never change them (don&#39;t backtrack). This won&#39;t always yield the optimum solution.</li>
</ul>

<p>In divide-and-conquer, the problem is often solved in the combination phase. For example, merge sort divides the problem and actually solves (i.e. sorts) it during the merge phase.</p>
<h2 id="intractability">
<span class="hash">#</span>
<a href="#intractability" class="header-link">Intractability</a>
</h2>
<p>An intractable problem is one that has no efficient solution. It can be proved that a problem is intractable if a known intractable problem can be reduced to the given problem.</p>

<ul>
<li>change the problem formulation such that it still achieves the higher goal</li>
<li>brute-force or dynamic programming: acceptable if instances or exponential parameter is small</li>
<li>search: prune search-space via backtracking, branch-and-bound, hill-climbing</li>
<li>heuristics: insight, common case analysis</li>
<li>parallelization: solve subparts in parallel</li>
<li>approximation: solution that is provably close to optimum</li>
</ul>
<h1 id="analysis">
<span class="hash">#</span>
<a href="#analysis" class="header-link">Analysis</a>
</h1>
<p>The goal of asymptotic analysis is to suppress the constant factors and lower-order terms. This is because the constant factors are very system-dependent, such as how many cycles a certain operation may take between different pieces of hardware. The lower-order terms are also not as important because they are rendered irrelevant for very large inputs, where the higher-order terms dominate.</p>
<h2 id="summations">
<span class="hash">#</span>
<a href="#summations" class="header-link">Summations</a>
</h2>
<p>The summation of a constant is simply the product of the constant and the range:</p>

<p><script type="math/tex; mode=display"> \sum_{i = 1}^n 1 = n </script></p>

<p>The sum of the first <script type="math/tex">n</script> integers can be visualized as folding the range of values at the middle so that the first integer is paired with the last, or more generally: the <script type="math/tex">i^\text{th}</script> paired with the <script type="math/tex">(n - i + 1)\text{th}</script>. Below, the bound of <script type="math/tex">n/2</script> refers to the &quot;folding at the middle,&quot; then each pair is added. <strong>Note</strong> that the sum is quadratic!</p>

<p><script type="math/tex; mode=display"> \sum_{i = 1}^n i = \sum_{i = 1}^{n/2} (i + (n - i + 1)) = \frac {n (n + 1)} 2 </script></p>

<p>The sum of a <em>harmonic series</em> is approximately equal to the logarithm of the bound.</p>

<p><script type="math/tex; mode=display"> H(n) = \sum_{i = 1}^n \frac 1 i \approx \log n </script></p>
<h2 id="logarithms">
<span class="hash">#</span>
<a href="#logarithms" class="header-link">Logarithms</a>
</h2>
<p>The exponent of a logarithm operand can be extracted:</p>

<p><script type="math/tex; mode=display"> \log_a n^b = b \cdot \log_a n </script></p>
<h2 id="bounds">
<span class="hash">#</span>
<a href="#bounds" class="header-link">Bounds</a>
</h2>
<p><img src="http://i.imgur.com/fMlyzap.png" class="center" /></p>

<p>The upper-bound <script type="math/tex">f(n) = O(g(n))</script> means that there exists some constant <script type="math/tex">c</script> such that <script type="math/tex">f(n)</script> is <em>always</em> <script type="math/tex">\le c \cdot g(n)</script> for a large enough <script type="math/tex">n</script>, that is, for some offset <script type="math/tex">n_0</script> such that <script type="math/tex">n \ge n_0</script>.</p>

<p><img src="https://i.imgur.com/L5oa2vN.png" class="center" /></p>

<p>The lower-bound <script type="math/tex">f(n) = \Omega(g(n))</script> is similar except that it is a lower-bound, so that there exists some constant <script type="math/tex">c</script> such that <script type="math/tex">f(n)</script> is <em>always</em> <script type="math/tex">\ge c \cdot g(n)</script> for <script type="math/tex">n \ge n_0</script>.</p>

<p><img src="https://i.imgur.com/GzSDZW7.png" class="center" /></p>

<p>There is also <script type="math/tex">f(n) = \Theta(g(n))</script> which means that <script type="math/tex">c_1 \cdot g(n)</script> is an upper-bound and <script type="math/tex">c_2 \cdot g(n)</script> is a lower-bound on <script type="math/tex">f(n)</script> for <script type="math/tex">n \ge n_0</script>. This is a tighter bound on <script type="math/tex">f(n)</script> than simply a lower or upper-bound alone would provide.</p>

<p><img src="https://i.imgur.com/mdfglLj.png" class="center" /></p>

<p>Constant factors are ignored since they can easily be beaten out by a different chosen value of <script type="math/tex">c</script>.</p>
<h2 id="dominance-relations">
<span class="hash">#</span>
<a href="#dominance-relations" class="header-link">Dominance Relations</a>
</h2>
<p>A faster-growing function <script type="math/tex">f(n)</script> <em>dominates</em> a slower-growing one <script type="math/tex">g(n)</script>, i.e. <script type="math/tex"> f \gg g</script>. In order of increasing dominance:</p>

<table>
<thead>
<tr>
<th style="text-align: left">Name</th>
<th style="text-align: left">Complexity</th>
<th style="text-align: left">Examples</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Constant</td>
<td style="text-align: left"><script type="math/tex">1</script></td>
<td style="text-align: left">adding two numbers</td>
</tr>
<tr>
<td style="text-align: left">Logarithmic</td>
<td style="text-align: left"><script type="math/tex">\log n</script></td>
<td style="text-align: left">binary search</td>
</tr>
<tr>
<td style="text-align: left">Linear</td>
<td style="text-align: left"><script type="math/tex">n</script></td>
<td style="text-align: left">incrementing each element in an array</td>
</tr>
<tr>
<td style="text-align: left">Linearithmic</td>
<td style="text-align: left"><script type="math/tex">n \log n</script></td>
<td style="text-align: left">QuickSort and MergeSort</td>
</tr>
<tr>
<td style="text-align: left">Quadratic</td>
<td style="text-align: left"><script type="math/tex">n^2</script></td>
<td style="text-align: left">looking at all/most pairs of an array</td>
</tr>
<tr>
<td style="text-align: left">Cubic</td>
<td style="text-align: left"><script type="math/tex">c^n</script></td>
<td style="text-align: left">looking at all/most triples of an array</td>
</tr>
<tr>
<td style="text-align: left">Exponential</td>
<td style="text-align: left"><script type="math/tex">c^n</script></td>
<td style="text-align: left">looking at all subsets of an array</td>
</tr>
<tr>
<td style="text-align: left">Factorial</td>
<td style="text-align: left"><script type="math/tex">n!</script></td>
<td style="text-align: left">looking at all permutations or orderings of n items</td>
</tr>
</tbody>
</table>

<p>When analyzing an algorithm it is common to produce an expression of bounds which can easily be simplified by keeping in mind the principle of dominance relations.</p>
<h3 id="sum-of-bounds">
<span class="hash">#</span>
<a href="#sum-of-bounds" class="header-link">Sum of Bounds</a>
</h3>
<p>For example, is an algorithm first sorts its input and then prints each element, then that&#39;s a sorting operation of <script type="math/tex">O(n \log n)</script> followed by a linear printing operation of <script type="math/tex">O(n)</script>, essentially becoming <script type="math/tex">O(n \log n + n)</script>. However, the linearithmic term clearly dominates the linear term, so simplifying it to <script type="math/tex">O(n \log n)</script> still leaves an accurate bound.</p>

<p><script type="math/tex; mode=display"> O(f(n)) + O(g(n)) → O(\max (f(n), g(n))) </script></p>
<h3 id="product-of-bounds">
<span class="hash">#</span>
<a href="#product-of-bounds" class="header-link">Product of Bounds</a>
</h3>
<p>Constant factors are ignored since a different value of the constant <script type="math/tex">c</script> can be chosen to compensate for any arbitrary constant factor.</p>

<p><script type="math/tex; mode=display"> O(c \cdot f(n)) → O(f(n)) </script></p>

<p>However, the product of functions is important. For example, a linear scan of an array in <script type="math/tex">O(n)</script> where for each element another linear scan of the array is made in <script type="math/tex">O(n)</script> produces a product of <script type="math/tex">O(n \cdot n) = O(n^2)</script>.</p>

<p><script type="math/tex; mode=display"> O(f(n)) \cdot O(g(n)) → O(f(n) \cdot g(n)) </script></p>
<h2 id="master-theorem">
<span class="hash">#</span>
<a href="#master-theorem" class="header-link">Master Theorem</a>
</h2>
<p>The master theorem provides a straightforward, &quot;black-box&quot; way of determining the running time of a recursive, divide-and-conquer algorithm. It&#39;s stated as:</p>

<p><script type="math/tex; mode=display"> T(n) = a T \left(\frac n b\right) + f\left(n^d\right) </script></p>

<p>where:</p>

<ul>
<li><script type="math/tex">n</script> is the size of the problem</li>
<li><script type="math/tex">a</script> is the number of recursive calls per level</li>
<li><script type="math/tex">\frac n b</script> is the size of each subproblem</li>
<li><script type="math/tex">f\left(n^d\right)</script> is the work done outside of the recursive calls, e.g. the merge in mergesort</li>
</ul>

<p>Then the run-time complexity of an algorithm can be determined based on the values of <script type="math/tex">a</script>, <script type="math/tex">b</script>, and <script type="math/tex">d</script>.</p>

<ul>
<li><p>when <script type="math/tex">a = b^d</script>, the complexity is <script type="math/tex">O\left(n^d \log n\right)</script></p>

<p>The same amount of work <script type="math/tex">n^d</script> is being done at each level, of which there are <script type="math/tex">\log n</script>.</p>

<p><img src="https://i.imgur.com/MPsr8vI.png" /></p></li>
<li><p>when <script type="math/tex">a < b^d</script>, the complexity is <script type="math/tex">O\left(n^d\right)</script></p>

<p>Most of the work is done at the root, as if only at a single level.</p>

<p><img src="https://i.imgur.com/01nnPMf.png" /></p></li>
<li><p>when <script type="math/tex">a > b^d</script>, the complexity is <script type="math/tex">O\left(n^{\log_b a}\right)</script></p>

<p>It&#39;s equivalent to the number of leaves in the recursion tree, since most of the work is done at the bottom of the tree.</p>

<p><img src="https://i.imgur.com/R2poF7S.png" /></p></li>
</ul>

<p>Essentially, the master theorem is a tug-of-war between:</p>

<ul>
<li><script type="math/tex">a</script>: the rate of subproblem proliferation</li>
<li><script type="math/tex">b^d</script>: the rate of work shrinkage per subproblem</li>
</ul>
<h2 id="approximations">
<span class="hash">#</span>
<a href="#approximations" class="header-link">Approximations</a>
</h2>
<p>Oftentimes it&#39;s useful to use approximations instead of exact values.</p>

<p>Stirling&#39;s approximation:</p>

<p><script type="math/tex; mode=display"> \ln N! \approx N \ln N - N + \ln \sqrt {2 \pi N} </script></p>
<h1 id="bitwise-operations">
<span class="hash">#</span>
<a href="#bitwise-operations" class="header-link">Bitwise Operations</a>
</h1>
<p>Bits can be unconditionally turned on by ORing with 1:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// set third bit</span>
<span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></figure>
<p>Bits can be unconditionally turned off by ANDing with 0:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// unset third bit</span>
<span class="n">bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></figure>
<p>Bits can be toggled by XORing with 1:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// toggle third bit</span>
<span class="n">bits</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></figure>
<p>XOR can be replicated without actually using XOR by simply writing out what XOR means, i.e. exclusive OR: (a AND NOT b) OR (NOT a AND b)</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// emulate XOR</span>
<span class="n">x</span> <span class="o">^</span> <span class="n">y</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span>
</code></pre></figure>
<p>The least significant set bit can be obtained with:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">x</span> <span class="o">=</span> <span class="mo">0101</span> <span class="mo">0100</span>
<span class="n">least_significant_set_bit</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></figure>
<p>The way this works is:</p>

<ol>
<li><p>all bits up-to-and-including the least significant set bit are flipped</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="o">=</span> <span class="mo">0101</span> <span class="mo">0011</span>
                 <span class="err">→</span>
</code></pre></figure></li>
<li><p>flip <em>all</em> bits so that only the previously-least significant set bit will pass when ANDed with the original value</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="o">~</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1010</span> <span class="mi">1100</span>
</code></pre></figure></li>
<li><p>AND with the original value so that only the least significant set bit passes</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mo">0000</span> <span class="mo">0100</span>
</code></pre></figure></li>
</ol>

<p>Likewise, the least significant set bit can be unset with:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">x</span> <span class="o">=</span> <span class="mo">0101</span> <span class="mo">0100</span>
<span class="n">least_significant_set_bit_unset</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></figure>
<p>This works because all bits up-to-and-including the least significant set bit are flipped, such that the least significant set bit is now unset (0) and all prior bits are set (1). All other more significant bits remain unchanged. This way, ANDing both causes the previously least significant set bit to fail.</p>
<h2 id="parity">
<span class="hash">#</span>
<a href="#parity" class="header-link">Parity</a>
</h2>
<p>The parity can be computed by continuously right-shifting and ANDing the shifted bit with 1 and adding the result to the running parity. However, only the 1 bits will have an effect on the parity, so a quicker way is to continuously be accessing and turning off the next lowest set bit. Finally, lookup tables of e.g. 16-bit chunks can be precomputed so that on a given input, the parity for each 16-bit chunk of the input is looked up and added together.</p>
<h2 id="bitwise-set-operations">
<span class="hash">#</span>
<a href="#bitwise-set-operations" class="header-link">Bitwise Set Operations</a>
</h2>
<p>A very important property of XOR is that it a number XORed with itself is 0.</p>

<p><script type="math/tex; mode=display"> N \oplus N = 0 </script></p>

<p>For example, given a list of numbers where each number appears exactly twice <em>except</em> for one number, the number that appears only once can be obtained by XORing each element with the next one, since duplicate elements would cancel themselves out.</p>

<p>More generally, bytes can be treated as a set, where bitwise operations correspond to set operations.</p>

<p>A set can be tested for the presence of a value by using the AND operator. More generally, this can be seen as a set intersection operation, in which the operands may, after all, be singleton sets.</p>

<p><script type="math/tex; mode=display"> S_a \mathrel{\&} S_b </script></p>

<p>A value can be <em>unconditionally</em> added to set <script type="math/tex">S</script> using the OR operator:</p>

<p><script type="math/tex; mode=display"> S \mathrel{|} N </script></p>

<p>A value can be <em>unconditionally</em> removed from set <script type="math/tex">S</script> using the AND operator with the complement of the value to be removed:</p>

<p><script type="math/tex; mode=display"> S \mathrel{\&} \mathord{\sim} N </script></p>

<p>A value can be <em>conditionally</em> added or removed from the set <script type="math/tex">S</script> using the XOR operator. The value will be removed if it is already contained and added if it isn&#39;t.</p>

<p><script type="math/tex; mode=display"> S \oplus N </script></p>

<p>For example, given an array of numbers, each of which appears exactly three times <em>except</em> for one number, the number that appears only once can be obtained using a combination of the above operations.</p>

<p>There will be two sets. The <code>ones</code> set will contain those numbers that have been observed to appear once so far. The <code>twos</code> set will contain those numbers that have been observed to appear twice so far. It&#39;s not necessary to track those numbers that appear three times, as that is implicit.</p>

<p>For each number in the array, it will be added to the <code>ones</code> set if it has been seen exactly once. If a number is already in the <code>ones</code> set and is seen again, it&#39;s removed from the <code>ones</code> set and added to the <code>twos</code> set. If a number is already in the <code>twos</code> set and is seen again, it&#39;s removed from the <code>twos</code> set. Ultimately this will leave the <code>ones</code> set as a singleton set containing the number that appears only once.</p>

<p>First, the number being considered is checked to see if it has already been seen once so far:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="n">ones</span> <span class="o">&amp;</span> <span class="n">num</span>
</code></pre></figure>
<p>This would mean that this is the second time that this number has been seen. If the number is indeed in the <code>ones</code> set, the above expression evaluates to the number itself by nature of the AND operation, otherwise it evaluates to 0.</p>

<p>The result of the above expression can directly be used to add the number to the <code>twos</code> set using the OR operation, which adds the number to the set, or does nothing if the number is 0.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="n">twos</span> <span class="o">|=</span> <span class="n">ones</span> <span class="o">&amp;</span> <span class="n">num</span>
</code></pre></figure>
<p>The number is then <em>conditionally</em> added to or removed from the <code>ones</code> set using the XOR operation. If the <code>ones</code> set already contained the number, then the previous operation will have added the number to the <code>twos</code> set, in which case it&#39;s no longer needed inside the <code>ones</code> set, since the <code>ones</code> set only contains those numbers that have appeared <em>exactly</em> once. If the <code>ones</code> set didn&#39;t already contain the number, then the above presence check results in 0 which does nothing when added to the <code>twos</code> set.</p>

<p>Therefore, we can add the number to the <code>ones</code> set if it wasn&#39;t already contained, or remove it if it was contained.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="n">ones</span> <span class="o">^=</span> <span class="n">num</span>
</code></pre></figure>
<p>However, if this has been the <em>third</em> time that this number has been seen, then the number will have been in the <code>twos</code> set already but <em>not</em> in the <code>ones</code> set. The above expression would therefore <em>also</em> add it to the <code>ones</code> set. Therefore we can be sure that if the number was present in both the <code>ones</code> and <code>twos</code> sets after the above operation, then this is the <em>third</em> time that this number has been observed.</p>

<p>In this case, the number should be removed from both sets. This would ensure that the <code>ones</code> set really does only contain those numbers that have appeared <em>exactly</em> once, which is what we&#39;re interested in.</p>

<p>However, the <code>ones</code> set and the <code>twos</code> set may contain various numbers. We know that the one that appears in both is the one that has appeared three times, and hence the one we want to remove, so we can obtain this number by intersecting both sets.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">int</span> <span class="n">threes</span> <span class="o">=</span> <span class="n">twos</span> <span class="o">&amp;</span> <span class="n">ones</span><span class="o">;</span>
</code></pre></figure>
<p>We then want to remove this number from both sets:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="n">twos</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">threes</span><span class="o">;</span>
<span class="n">ones</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">threes</span><span class="o">;</span>
</code></pre></figure>
<p>Here is the full algorithm.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">singleNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">ones</span><span class="o">,</span> <span class="n">twos</span><span class="o">;</span>
  <span class="n">ones</span> <span class="o">=</span> <span class="n">twos</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">twos</span> <span class="o">|=</span> <span class="n">ones</span> <span class="o">&amp;</span> <span class="n">num</span><span class="o">;</span>
    <span class="n">ones</span> <span class="o">^=</span> <span class="n">num</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">threes</span> <span class="o">=</span> <span class="n">twos</span> <span class="o">&amp;</span> <span class="n">ones</span><span class="o">;</span>
    <span class="n">twos</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">threes</span><span class="o">;</span>
    <span class="n">ones</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">threes</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">ones</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure><h1 id="integers">
<span class="hash">#</span>
<a href="#integers" class="header-link">Integers</a>
</h1>
<p>It&#39;s possible to &quot;shift&quot; a number to the left by <script type="math/tex">n</script> digits by multiplying it with <script type="math/tex">\text {base}^\text {digits}</script>. For example, the number <script type="math/tex">321</script> can be shifted to the left by 2 digits to <script type="math/tex">32100</script> by multiplying it by <script type="math/tex">10^2</script>.</p>

<p><script type="math/tex; mode=display">\text {shifted left by n} = x * \text {base}^\text {digits}</script></p>

<p>Similarly, it&#39;s possible to get the last <script type="math/tex">n</script> digits of a number by getting the remainder of dividing it by <script type="math/tex">\text {base}^\text {digits}</script>. For example, the last 2 digits of <script type="math/tex">321</script> can be obtained by getting the remainder of dividing it (i.e. the modulo) by <script type="math/tex">10^2</script>.</p>

<p><script type="math/tex; mode=display">\text {right-most n digits} = x \bmod \text {base}^\text {digits}</script></p>

<p>The square root of a number can be found via binary search by searching from <script type="math/tex">[1.0, n]</script> for a number which, squared, is equal to the input (given some tolerance or until convergence). If the input is real and less than 1, the bounds change to <script type="math/tex">[n, 1.0]</script>.</p>

<p>The logarithm of a number can naively be computed by counting how many times the operand can be divided by the base without going below 1. For example, <script type="math/tex">\log_2 64</script> can divide <script type="math/tex">64 / 2</script> a total of six times until it reaches 1, doing it a seventh time causes the value to go below 1.</p>
<h1 id="arrays">
<span class="hash">#</span>
<a href="#arrays" class="header-link">Arrays</a>
</h1>
<p>The 2-SUM problem is one where the input is a sorted array of integers and a target value <script type="math/tex">k</script> and the objective is to determine if there is a pair of entries <script type="math/tex">i</script> and <script type="math/tex">j</script> such that:</p>

<p><script type="math/tex; mode=display">A[i] + A[j] = k</script></p>

<p>The brute-force approach would be to check if this is true for all possible pairs of values in the array, of which there are <script type="math/tex">n^2</script>. Alternatively, a <a href="#hash-tables">hash table</a> can be used.</p>

<p>Another approach is to iterate from both ends of the array. For example, at first, the first and last elements will be used. If their sum is greater than the target, the right end will be iterated leftward so as to attempt to obtain a smaller element. If instead their sum is less than the target, the left end will be iterated rightward in hopes of increasing their sum.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">right</span><span class="o">--</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">left</span><span class="o">++</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure><h1 id="sorting">
<span class="hash">#</span>
<a href="#sorting" class="header-link">Sorting</a>
</h1>
<p>Many problems can be reduced to sorting.</p>

<p><strong>Answers</strong>: Ordering a sequence into a specified order.</p>

<p><strong>Data Structure</strong>: Array or other sequence.</p>

<p>The following algorithms are described with the assumption that the sequence is an array of contiguous memory and constant access time. This is <em>noteworthy</em> because it is important to recognize algorithms can have different speeds depending on the underlying data structure.</p>

<p>For example, selection sort backed by a priority queue or balanced binary tree can help to speed up the operation of finding the smallest element in the unsorted region. Instead of being linear, the operation would be <script type="math/tex">\lg(n)</script>. Given that this is done at every element in the sequence, of which there are <script type="math/tex">N</script>, this means that selection sort backed by such a structure can be improved from <script type="math/tex">O(n^2)</script> to <script type="math/tex">O(n\lg(n))</script> <sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup>.</p>

<p>A sorting algorithm is known as <em>stable</em> if it maintains the same relative order of equal keys as it was before the sorting operation.</p>

<p>The best case complexity of comparison-based sorting is <script type="math/tex">O(n \log n)</script>. If the distribution of the data is known, sorting can be done much faster using counting or bucket sort, for example.</p>
<h2 id="selection-sort">
<span class="hash">#</span>
<a href="#selection-sort" class="header-link">Selection Sort</a>
</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Any</td>
<td style="text-align: left"><script type="math/tex">\Theta(n^2)</script></td>
</tr>
</tbody>
</table>

<p>This is a pretty naive algorithm that is mainly useful for didactic purposes.</p>

<p>Algorithm operation:</p>

<ol>
<li>go through entire sequence to find smallest element</li>
<li>swap element with the left-most unsorted element</li>
<li>repeat until the end of the sequence</li>
</ol>

<p>This essentially splits the sequence into a left sorted region and a right unsorted region.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">min</span><span class="o">])</span> <span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>

    <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">min</span><span class="o">]);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure><h2 id="insertion-sort">
<span class="hash">#</span>
<a href="#insertion-sort" class="header-link">Insertion Sort</a>
</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Best</td>
<td style="text-align: left"><script type="math/tex">\Theta(n)</script></td>
</tr>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(n^2)</script></td>
</tr>
</tbody>
</table>

<p>This is a <em>stable</em> algorithm that is still pretty straightforward but somewhat improves upon selection sort if the array is already sorted or if it&#39;s nearly sorted.</p>

<p>It operates as follows:</p>

<ol>
<li>go through the entire sequence until an element is found which is <strong>smaller than the previous element</strong></li>
<li>swap the smaller element with the one on the left until the element to its left is no longer larger than itself</li>
<li>repeat until the end of the sequence</li>
</ol>

<p>The benefit of insertion sort is that if the sequence is already sorted then the algorithm operates in linear time. Similarly, if the sequence is nearly sorted, the algorithm will perform better than the worst case.</p>

<p><strong>Performance Factors</strong>: order of the items</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span> <span class="n">j</span><span class="o">--)</span>
      <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]);</span>
<span class="o">}</span>
</code></pre></figure><h2 id="shell-sort">
<span class="hash">#</span>
<a href="#shell-sort" class="header-link">Shell Sort</a>
</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(n^{3/_2})</script></td>
</tr>
</tbody>
</table>

<p>While insertion sort can be faster than selection sort, one problem with it is that the swap operations are done one at a time. This means that in the worst case, when sorting position 1 of the array, the smallest element could be at the very end of the array, meaning a total of <script type="math/tex">N - 1</script> swaps where <script type="math/tex">N</script> is the length of the array.</p>

<p>Shell sort aims to mitigate this by doing the following:</p>

<ol>
<li>pick a large number <script type="math/tex">H</script> some constant factor less than the length of the sequence</li>
<li>consider every <script type="math/tex">H^{th}</script> element in the sequence and apply insertion sort to those elements</li>
<li>now consider every <script type="math/tex">(H + 1)^{th}</script> element and do the same</li>
<li>repeat incrementing <script type="math/tex">H</script> until the end of the array is reached</li>
<li>repeat steps 2 - 4 but with <script type="math/tex">H</script> reduced by some factor until the reduction reaches <script type="math/tex">1</script></li>
<li>ultimately do regular insertion sort, i.e. <script type="math/tex">H = 1</script></li>
</ol>

<p>The value picked for <script type="math/tex">H</script> and the factor which is used to reduce it form what is known as a <a href="http://en.wikipedia.org/wiki/Shellsort#Gap_sequences">gap sequence</a>. The overall worst-case time complexity <em>depends on the chosen gap sequence</em>. A commonly chosen gap sequence with a worst-case time complexity of <script type="math/tex">O(n^{3/_2})</script> is:</p>

<p><script type="math/tex; mode=display">\frac {(3^k - 1)} {2} \text{, not greater than}\ \lceil N/3 \rceil</script></p>

<p>This sequence begins at the largest increment less than <script type="math/tex">N/3</script> and decreases to 1. This means that for a sequence of length <script type="math/tex">16</script> the sequence is <script type="math/tex">13, 4, 1</script>.</p>

<p>The effect of shell sort is that it sorts elements that are <script type="math/tex">H</script> elements apart with one swap instead of <script type="math/tex">H</script>. The granularity of the sorting operation increases as <script type="math/tex">H</script> itself decreases such that every element is eventually sorted, but with the added benefit that as <script type="math/tex">H</script> decreases, the distance of the longest-distance swap decreases.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">/</span><span class="mi">3</span><span class="o">)</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">h</span><span class="o">];</span> <span class="n">j</span> <span class="o">-=</span> <span class="n">h</span><span class="o">)</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">h</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">3</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure><h2 id="merge-sort">
<span class="hash">#</span>
<a href="#merge-sort" class="header-link">Merge Sort</a>
</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(n\lg{n})</script></td>
</tr>
<tr>
<td style="text-align: left">Space</td>
<td style="text-align: left"><script type="math/tex">O(n)</script></td>
</tr>
</tbody>
</table>

<p>This is a <em>stable</em> algorithm and the first algorithm that is linearithmic in complexity. The general idea is that the sequence is split into many pieces and then they&#39;re all merged back together. The sorting occurs during the merging phase. The merging algorithm works such that the resultant merged piece is sorted.</p>

<p>The main drawback is that it has <script type="math/tex">O(n)</script> space complexity because an auxiliary sequence has to be created to facilitate the merging process.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
    <span class="n">aux</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
    <span class="k">if</span>      <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">)</span>         <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="o">)</span>          <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
    <span class="k">else</span>                      <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
<span class="o">}</span>
</code></pre></figure>
<p>The complexity is <script type="math/tex">O(n \log n)</script> because the number of subproblems is doubling at each level (i.e. the two recursive calls), but the work to be done by those subproblems is halving. That is, for a given level <script type="math/tex">j</script>, the amount of work done is:</p>

<p><script type="math/tex; mode=display"> 2^j \left( \frac n 2^j \right) = n </script></p>

<p>Given an input size of <script type="math/tex">n</script>, the number of levels in the recursion tree is <script type="math/tex">\log_2 n</script>, which means that at each of the <script type="math/tex">\log_2 n</script> levels in the tree there is <script type="math/tex">n</script> work being done, hence <script type="math/tex">n \log n</script>.</p>

<p>The number of <em>inversions</em> in an array can be counted in <script type="math/tex">O(n \log n)</script> by reducing the problem to merge sort. Specifically, during a merge, each time an element from the right half is merged and there are elements remaining in the left half, then the chosen element from the right half represents an inversion between each of the elements remaining on the left half.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="nl">left</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">]</span> <span class="nl">right</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>

<span class="c1">// after merging two from the left</span>
<span class="nl">merged</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span>

<span class="nl">left</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">]</span> <span class="nl">right</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>

<span class="c1">// the ones on the right are lesser, e.g. merge 6</span>
<span class="nl">merged</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span>

<span class="nl">left</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">]</span> <span class="nl">right</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>

<span class="c1">// the act of having merged 6 instead of [12, 13] means that</span>
<span class="c1">// the original array had two inversions concerning 6: 12⟷6 and 13⟷6</span>
</code></pre></figure>
<p>A possible implementation would have merge return the inversions it encountered, which has to be passed up the recursion tree by having the sort functions return the sum of the recursive sorts and merges.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">SortAndCount</span><span class="p">(</span><span class="n">array</span> <span class="n">A</span><span class="p">,</span> <span class="n">length</span> <span class="n">n</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">return</span> <span class="mi">0</span>
  <span class="k">else</span>
    <span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">SortAndCount</span><span class="p">(</span><span class="mi">1</span><span class="n">st</span> <span class="n">half</span> <span class="n">of</span> <span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">SortAndCount</span><span class="p">(</span><span class="mi">2</span><span class="n">nd</span> <span class="n">half</span> <span class="n">of</span> <span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">MergeAndCountSplitInv</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</code></pre></figure><h3 id="top-down">
<span class="hash">#</span>
<a href="#top-down" class="header-link">Top-Down</a>
</h3>
<p>This is a recursive approach that works by splitting the array into two pieces until the pieces consist of pairs of elements. On each recurrence, the two pieces that were split for that recurrence are merged back.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparable</span><span class="o">[</span><span class="n">seq</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="o">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>

  <span class="n">merge</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></figure><h4 id="merge-sort-improvements">
<span class="hash">#</span>
<a href="#merge-sort-improvements" class="header-link">Merge Sort Improvements</a>
</h4>
<p>There are a couple of improvements that can be made to top-down merge sort:</p>

<ul>
<li><strong>use insertion sort for small sub-arrays</strong>: create a cut-off, e.g. 15 elements, where the pieces are sorted with insertion sort instead of being broken down further</li>
<li><strong>test if sequence is already in order</strong>: skip the merging phase if <code>seq[mid] &lt;= seq[mid + 1]</code></li>
</ul>
<h3 id="bottom-up">
<span class="hash">#</span>
<a href="#bottom-up" class="header-link">Bottom-Up</a>
</h3>
<p>The other approach to merge sort is bottom-up, that is, starting with arrays consisting of one element and merging them together, then merging all of the arrays of size two, and so on until the entire array is merged.</p>

<ol>
<li>increments a counter <script type="math/tex">SZ</script> in the series of powers of two until <script type="math/tex">SZ < N</script></li>
<li>merges every sub-array of length <script type="math/tex">2SZ</script></li>
</ol>

<p>One <strong>advantage</strong> of bottom-up merge sort is that it can be modified to perform on linked-lists <strong>in place</strong>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparable</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">sz</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">+</span> <span class="n">sz</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="n">sz</span><span class="o">;</span> <span class="n">lo</span> <span class="o">+=</span> <span class="n">sz</span> <span class="o">+</span> <span class="n">sz</span><span class="o">)</span>
      <span class="n">merge</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">min</span><span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">sz</span> <span class="o">+</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></figure><h2 id="quick-sort">
<span class="hash">#</span>
<a href="#quick-sort" class="header-link">Quick Sort</a>
</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(n \log n)</script></td>
</tr>
<tr>
<td style="text-align: left">Space</td>
<td style="text-align: left"><script type="math/tex">O(\log n)</script></td>
</tr>
</tbody>
</table>

<p>QuickSort works by choosing an element in the array---the pivot---and partitioning the array such that all elements <em>less than</em> the pivot are moved to its left and all elements <em>greater than</em> the pivot are moved to its right. This has the effect that, at the end of this operation, the chosen element will be at its &quot;sorted order position,&quot; i.e. the position in which it would be if the entire array were already sorted.</p>

<p>Note that the elements are simply moved to the correct side of the pivot, but the order of neither side is defined, i.e. neither the left nor the right side are necessarily sorted after partitioning.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">shuffle</span><span class="o">(</span><span class="n">seq</span><span class="o">);</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>

  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></figure>
<p>The partition algorithm is similar to merge in merge sort in that it is what actually does the sorting.</p>

<p><img class="center" src="/images/notes/algorithms/quicksort/partition.png"></p>

<ol>
<li>choose a partition element separator <script type="math/tex">v</script></li>
<li>scan through the array from <script type="math/tex">i</script> to <script type="math/tex">j</script> in both directions

<ol>
<li>while <script type="math/tex">i < v</script> do <code>i++</code></li>
<li>while <script type="math/tex">j > v</script> do <code>j--</code></li>
<li>swap <script type="math/tex">i</script> and <script type="math/tex">j</script></li>
</ol></li>
<li>repeat step 2 until the iterators <script type="math/tex">i</script> and <script type="math/tex">j</script> cross</li>
<li>swap the partition element <script type="math/tex">v</script> with the final position of the right-side iterator <script type="math/tex">j</script></li>
</ol>

<p>The sorting algorithm then recurses on the two partitions. Note that <code>i</code> is set to <code>lo</code> and not <code>lo + 1</code> to ensure that the pivot at <code>lo</code> is skipped, since the first operation is <code>++i</code>. However, <code>j</code> is set to <code>hi + 1</code> to ensure that <code>hi</code> is <em>not</em> skipped, since it&#39;s not the pivot.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">private</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Comparable</span> <span class="n">v</span> <span class="o">=</span> <span class="n">seq</span><span class="o">[</span><span class="n">lo</span><span class="o">];</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">seq</span><span class="o">[++</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">hi</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[--</span><span class="n">j</span><span class="o">])</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">lo</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

    <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
  <span class="o">}</span>

  <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">lo</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
  <span class="k">return</span> <span class="n">j</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure><h3 id="quick-sort-improvements">
<span class="hash">#</span>
<a href="#quick-sort-improvements" class="header-link">Quick Sort Improvements</a>
</h3>
<ul>
<li><p><strong>use insertion sort for small sub-arrays</strong>: Adding a cutoff size for which to apply insertion sort to small sub-arrays can improve the performance of the algorithm.</p>

<p>Instead of:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</code></pre></figure>
<p>use:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span> <span class="n">insertionSort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span> <span class="k">return</span><span class="o">;</span> <span class="o">}</span>
</code></pre></figure>
<p>where <code>M</code> is the cutoff. Recommended sizes are between 5 and 15.</p></li>
<li><p><strong>median-of-three partitioning</strong>: Choose a sample of size 3 from the sequence and choose the middle element as the partitioning element.</p></li>
</ul>
<h3 id="three-way-partitioning">
<span class="hash">#</span>
<a href="#three-way-partitioning" class="header-link">Three-way Partitioning</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Best</td>
<td style="text-align: left"><script type="math/tex">O(n)</script></td>
</tr>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(n\lg{n})</script></td>
</tr>
<tr>
<td style="text-align: left">Space</td>
<td style="text-align: left"><script type="math/tex">O(\lg{n})</script></td>
</tr>
</tbody>
</table>

<p>One problem with quick sort as it is implemented above is that items with keys equal to that of the partition item are swapped anyways, unnecessarily. Three-way partitioning aims to resolve this by partitioning into three separate sub-arrays, the middle of which corresponds to those items with keys equal to the partition point. E. W. Dijkstra popularized this as the <em>Dutch National Flag</em> problem.</p>

<p><strong>Performance Factors</strong>: distribution of the keys</p>

<p><img class="center" src="/images/notes/algorithms/quicksort/3waypartition.png"></p>

<ol>
<li>perform a 3-way comparison between element <script type="math/tex">i</script> and <script type="math/tex">v</script>

<ol>
<li><script type="math/tex">seq[i] < v</script>: swap <script type="math/tex">lt</script> and <script type="math/tex">i</script> and <code>lt++</code> and <code>i++</code></li>
<li><script type="math/tex">seq[i] > v</script>: swap <script type="math/tex">i</script> and <script type="math/tex">gt</script> and <code>gt--</code></li>
<li><script type="math/tex">seq[i] = v</script>: <code>i++</code></li>
</ol></li>
<li>repeat step 1 until <script type="math/tex">i</script> and <script type="math/tex">gt</script> cross, i.e. while <script type="math/tex">i \leq gt</script></li>
<li>recurse on the left and right segments</li>
</ol>

<p>Quick sort performs a lot better than merge sort in sequences that have duplicate keys. Its time is reduced from linearithmic to linear for sequences with large numbers of duplicate keys.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="kt">int</span> <span class="n">lt</span> <span class="o">=</span> <span class="n">lo</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">gt</span> <span class="o">=</span> <span class="n">hi</span><span class="o">;</span>
  <span class="n">Comparable</span> <span class="n">v</span> <span class="o">=</span> <span class="n">seq</span><span class="o">[</span><span class="n">lo</span><span class="o">];</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">gt</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">-</span> <span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">v</span><span class="o">]);</span>

    <span class="k">if</span>      <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">lt</span><span class="o">++],</span> <span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">++]);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">],</span>    <span class="n">seq</span><span class="o">[</span><span class="n">gt</span><span class="o">--]);</span>
    <span class="k">else</span>              <span class="n">i</span><span class="o">++;</span>
  <span class="o">}</span>

  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">lt</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">gt</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></figure><h1 id="heaps">
<span class="hash">#</span>
<a href="#heaps" class="header-link">Heaps</a>
</h1>
<p>A priority queue is an abstract data type that allows adding elements and retrieving the smallest or largest element. Priority queues are useful for an unbounded sequence for which we want to retrieve the <script type="math/tex">M</script> smallest elements at any given moment.</p>

<p>The data structure commonly used to back a priority queue is an array embedding the contents of a <strong>complete binary tree</strong> in level-order that maintains two invariants:</p>

<ol>
<li>the parent of <script type="math/tex">k</script> is <script type="math/tex">\left\lfloor (k - 1)/2 \right\rfloor</script></li>
<li>the children of <script type="math/tex">k</script> are at <script type="math/tex">2k + 1</script> and <script type="math/tex">2k + 2</script></li>
</ol>
<h2 id="heap-insertion">
<span class="hash">#</span>
<a href="#heap-insertion" class="header-link">Heap Insertion</a>
</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(\lg{n})</script></td>
</tr>
</tbody>
</table>

<p>Swimming in a heap is when a node is checked to ensure the invariant that every node is smaller than its parent. If a node&#39;s value becomes larger than its parent, the node is swapped with its parent and the process is repeated at the new parent until the tree root is reached. This can be characterized as a new, larger node having to swim up the tree to its proper place.</p>

<p>To insert into the heap:</p>

<ol>
<li>add element to the end of the array</li>
<li>increment heap size</li>
<li>swim up the heap to restore heap order</li>
</ol>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">swim</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// go up tree as long as the parent `target / 2` is</span>
  <span class="c1">// smaller than the child</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">target</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span><span class="o">[(</span><span class="n">target</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">target</span><span class="o">])</span> <span class="o">{</span>
    <span class="c1">// swap parent and child</span>
    <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[(</span><span class="n">target</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">target</span><span class="o">]);</span>

    <span class="c1">// position is now that of previous parent</span>
    <span class="n">target</span> <span class="o">=</span> <span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure><h2 id="heap-removal">
<span class="hash">#</span>
<a href="#heap-removal" class="header-link">Heap Removal</a>
</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(\lg{n})</script></td>
</tr>
</tbody>
</table>

<p>From a different perspective, if a node&#39;s key becomes smaller than one or both of its children, the heap-order invariant will also be violated, because it conversely means that one or more of its children are larger than the parent. In this case, the node is simply swapped with the larger of its two children, a process known as sinking. This process is repeated for the new child all the way down the tree until the invariant holds.</p>

<p>To remove the maximum from the heap:</p>

<ol>
<li>take the largest item off of the top</li>
<li>put the item from the end of the heap at the top</li>
<li>decrement heap size</li>
<li>sink down the heap to restore heap order</li>
</ol>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Sink</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">target</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// identify child of target</span>
    <span class="kt">int</span> <span class="n">child</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">target</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// choose right child if left child is smaller than right</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vec</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">child</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="n">child</span><span class="o">++</span><span class="p">;</span>

    <span class="c1">// if the invariant holds, break</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">vec</span><span class="p">[</span><span class="n">child</span><span class="p">])</span> <span class="k">break</span><span class="p">;</span>

    <span class="c1">// otherwise swap with the larger child</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">target</span><span class="p">],</span> <span class="n">vec</span><span class="p">[</span><span class="n">child</span><span class="p">]);</span>

    <span class="c1">// position is now that of previously-larger child&#39;s</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">child</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure><h2 id="heap-sort">
<span class="hash">#</span>
<a href="#heap-sort" class="header-link">Heap Sort</a>
</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(n\lg{n})</script></td>
</tr>
</tbody>
</table>

<p>Heap sort is a sorting algorithm facilitated by a priority queue which performs well when backed by a binary heap. Heap sort more or less amounts to:</p>

<ol>
<li>feeding the sequence into a priority queue</li>
<li>extracting the sequence out of the priority queue</li>
</ol>

<p>However, there are certain details involved to make it operate faster. Usually these operations are performed in place to avoid using extra space.</p>

<p>First, the sequence has to be put into heap order, which is accomplished by walking up the tree (bottom-up) and sinking every root node with more than one child. The starting point for this is always <script type="math/tex">(N - 1) / 2</script>, which is the last node with two children. It&#39;s important to note that &quot;sinking a node&quot; doesn&#39;t mean that the node will definitively be swapped.</p>

<p>Assuming a maximum-oriented priority queue, the sorting is then accomplished by:</p>

<ol>
<li>swap the maximum with the last item in the heap</li>
<li>decrease logical heap size</li>
<li>sink the new root to ensure or repair heap order</li>
<li>repeat 1-3 until the priority queue becomes empty</li>
</ol>

<p>Note that the notion of a logical heap size is important, as the sorted sequence is increasingly added to the end of the same array that backs the heap, so it&#39;s necessary to make a distinction between the two regions of the array, to prevent the heap sink or swim operations from corrupting the sorted region. This is accomplished in this code by using a hypothetical <code>sink</code> method that takes an upper bound parameter, which corresponds to the end of the heap region, i.e. the logical heap size.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">kLastElement</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">kParentOfLastElement</span> <span class="o">=</span> <span class="p">(</span><span class="n">kLastElement</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// Arrange array into heap-order, starting from the last</span>
  <span class="c1">// node with two children and climbing up from there.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">kParentOfLastElement</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">--</span><span class="p">)</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>

  <span class="c1">// Move max to end of sorted region, which is to the right of</span>
  <span class="c1">// the unsorted region. Then sink the root node to ensure</span>
  <span class="c1">// heap order is preserved, but don&#39;t sink past the end of the</span>
  <span class="c1">// unsorted region, as that would corrupt the sorted region.</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vec</span><span class="p">[</span><span class="n">N</span><span class="o">--</span><span class="p">]);</span>
    <span class="n">sink</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure><h2 id="median-maintenance">
<span class="hash">#</span>
<a href="#median-maintenance" class="header-link">Median Maintenance</a>
</h2>
<p>The median of a streaming sequence of numbers can be computed in constant time by maintaining two heaps: a max-heap for the lower/left half and a min-heap for the upper/right half. This has the effect of keeping the elements sorted, and the top of the max-heap yields one of the overall middle elements, whereas the top of the min-heap yields the other middle element.</p>

<p>The elements must be kept equal in size, or the min-heap may be larger by one element, in which case there are an odd number of numbers, so the top of the min-heap is the middle element alone.</p>

<p>If one of the heaps grows larger, its top element should be popped and pushed onto the other heap to balance them.</p>
<h1 id="selection">
<span class="hash">#</span>
<a href="#selection" class="header-link">Selection</a>
</h1>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Average</td>
<td style="text-align: left"><script type="math/tex">\Theta(n)</script></td>
</tr>
</tbody>
</table>

<p>Selecting the <script type="math/tex">k^\text{th}</script> smallest item in a sequence can be accomplished by using QuickSort&#39;s partition algorithm. This is guaranteed by the invariant held by QuickSort&#39;s partition algorithm which states that given the partition index <script type="math/tex">j</script>, all elements to the left are less than or equal to <script type="math/tex">j</script> and all elements to the right are greater than or equal to <script type="math/tex">j</script>, effectively making the sub-sequence up to <script type="math/tex">j</script> consist of the smallest <script type="math/tex">j</script> elements in the sequence.</p>

<p>With that in mind, the desired index <script type="math/tex">k</script> is input to QuickSelect. After partitioning in <script type="math/tex">O(n)</script>, the resulting position <script type="math/tex">j</script> of the <script type="math/tex">k^\text{th}</script> element is compared to the input <script type="math/tex">k</script>. If the resulting position <script type="math/tex">j</script> is less than the desired <script type="math/tex">k</script> then QuickSelect is repeated on the right region <script type="math/tex">A[j ..]</script> with a compensated <script type="math/tex">k</script>, i.e. <script type="math/tex">k - j</script>. If the resulting position <script type="math/tex">j</script> is greater than the desired <script type="math/tex">k</script> then QuickSelect is repeated on the left region <script type="math/tex">A[.. j]</script> with the same <script type="math/tex">k</script>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">QuickSelect</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">begin</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Iter</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">Partition</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">pivot</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">distance</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">pivot</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// -1 to shift past pivot</span>
    <span class="k">return</span> <span class="n">QuickSelect</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span><span class="n">pivot</span><span class="p">),</span> <span class="n">end</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">distance</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">QuickSelect</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure><h1 id="binary-search-trees">
<span class="hash">#</span>
<a href="#binary-search-trees" class="header-link">Binary Search Trees</a>
</h1>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(n)</script></td>
</tr>
</tbody>
</table>

<p>This is the classical data structure consisting of a binary tree where each node has two children. The sub-tree to the left of each node consists of elements smaller than the node and the sub-tree to the right of each node consists of elements greater than the node.</p>

<p>The performance of BSTs greatly depends on the shape of the tree, which is a result of the distribution and order of the elements that are input.</p>

<p>The rank operation counts how many keys are less than or equal to the given value.</p>

<p>The predecessor of any node can be obtained easily if it has a left child, in which case the predecessor of the node is the maximum of the subtree rooted at the left child. If there is no left child, the predecessor is the first ancestor larger than the node (in other words, the first parent found for which the child is the right child). The successor can be found similarly, flipping left⟷right and maximum⟷minimum.</p>
<h2 id="bst-structure">
<span class="hash">#</span>
<a href="#bst-structure" class="header-link">BST Structure</a>
</h2>
<p>A perfect binary tree is one where every level has the maximum number of nodes.</p>

<p>The depth of a tree node is the number of edges from the root to the node, i.e. the level - 1, so the depth of the root node is 0. The level of a node in a tree is its depth + 1. The difference between levels and depth is that levels are the visual levels whereas depth is the number of edges from the root to the node.</p>

<p>The height of a tree node is the number of edges on the longest path from the node to a leaf. The height of an entire tree is the height of its root, i.e. the depth of the deepest node.</p>

<p>The number of levels in a binary tree with <script type="math/tex">n</script> nodes is <script type="math/tex">\log_2 n</script>.</p>

<p>In a perfect binary tree, the number of nodes at depth <script type="math/tex">d</script> is <script type="math/tex">2^d</script>.</p>

<p>In a perfect binary tree with <script type="math/tex">L</script> levels, the total number of nodes is <script type="math/tex">2^L - 1</script>. So if there are 3 levels, <script type="math/tex">2^3 - 1 = 7</script> total nodes.</p>
<h2 id="bst-traversal">
<span class="hash">#</span>
<a href="#bst-traversal" class="header-link">BST Traversal</a>
</h2>
<p>There are three main forms of traversing a BST. The <em>order</em> refers to the order in which the current node <script type="math/tex">C</script> is visited, that is, the time at which <script type="math/tex">C</script> is visited is the only thing that varies, so <script type="math/tex">L</script> is always visited before <script type="math/tex">R</script>.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Traversal</th>
<th style="text-align: left">Order</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">pre-order</td>
<td style="text-align: left"><script type="math/tex">C \to L \to R</script></td>
</tr>
<tr>
<td style="text-align: left">in-order</td>
<td style="text-align: left"><script type="math/tex">L \to C \to R</script></td>
</tr>
<tr>
<td style="text-align: left">post-order</td>
<td style="text-align: left"><script type="math/tex">L \to R \to C</script></td>
</tr>
</tbody>
</table>
<h3 id="morris-traversal">
<span class="hash">#</span>
<a href="#morris-traversal" class="header-link">Morris Traversal</a>
</h3>
<p>It&#39;s possible to perform an in-order traversal of a BST without using a stack or recursion by performing a Morris traversal. In essence, this traversal transforms the tree during the traversal so that the entire right branch of the BST forms the in-order traversal. The BST is returned to its original structure as the traversal takes place.</p>

<p><img src="/images/notes/algorithms/morris-traversal.png" class="center" width="75%"></p>

<ol>
<li><p>if left is <code>null</code></p>

<ol>
<li>visit <code>current</code></li>
<li>go right</li>
</ol></li>
<li><p>else:</p>

<ol>
<li>set <code>temp</code> to <code>current</code>&#39;s left</li>
<li><p>go right of <code>temp</code> until its right is <code>null</code> or <code>current</code></p>

<p>This finds the maximum of <code>current</code>&#39;s left, i.e. the in-order predecessor of <code>current</code>, or it finds the node whose right is <code>current</code>.</p></li>
<li><p>if <code>temp</code>&#39;s right is <code>null</code>:</p>

<p>This is the in-order predecessor of <code>current</code>. Transform the tree so that <code>temp</code> leads to <code>current</code> and is therefore in-order.</p>

<ol>
<li>set <code>temp</code>&#39;s right to <code>current</code></li>
<li><p>go left of <code>current</code></p>

<p>This &quot;rewinds&quot; back to the last known minimum.</p></li>
</ol></li>
<li><p>if <code>temp</code>&#39;s right is <code>current</code></p>

<p>This is a node that was previously transformed to be in-order by making its right be <code>current</code>. Repair transformation.</p>

<ol>
<li>visit <code>current</code></li>
<li>unset <code>temp</code>&#39;s right (previously <code>current</code>)</li>
<li>go right of <code>current</code></li>
</ol></li>
</ol></li>
</ol>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">visit</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">temp</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">temp</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">visit</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure><h2 id="bst-deletion">
<span class="hash">#</span>
<a href="#bst-deletion" class="header-link">BST Deletion</a>
</h2>
<p>Most operations such as insertion and lookup are very straightforward. Deletion is somewhat more involved.</p>

<p>To delete node <script type="math/tex">k</script>:</p>

<ol>
<li><script type="math/tex">k</script> <strong>has no children</strong>: remove it</li>
<li><script type="math/tex">k</script> <strong>has just one child</strong>: swap it with child and delete it</li>
<li><script type="math/tex">k</script> <strong>has two children</strong>:

<ol>
<li>compute <script type="math/tex">k</script>&#39;s predecessor <script type="math/tex">l</script>, i.e. maximum of left subtree</li>
<li>swap <script type="math/tex">k</script> and <script type="math/tex">l</script></li>
<li>delete <script type="math/tex">k</script></li>
<li>now <script type="math/tex">k</script> has no right child, recurse starting at 1</li>
</ol></li>
</ol>

<p>The transplant operation can be handled by simply associating the parent with the new child and vice versa:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-c"><span class="kt">void</span> <span class="nf">replace_node</span><span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">node</span> <span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">node</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">==</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">nil</span><span class="p">)</span>
    <span class="n">t</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
    <span class="n">u</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">u</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

  <span class="c1">// ignore this check in red-black trees</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">v</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure><h2 id="bst-select">
<span class="hash">#</span>
<a href="#bst-select" class="header-link">BST Select</a>
</h2>
<p>The BST can be augmented so that each node contains the count of notes rooted at it, including itself. Then the count can be computed for node <script type="math/tex">x</script> base by adding the count of left child <script type="math/tex">y</script> and right child <script type="math/tex">z</script> plus one for <script type="math/tex">x</script>:</p>

<p><script type="math/tex; mode=display">size(x) = size(y) + size(z) + 1</script></p>

<p>It&#39;s important to keep this augmented information up-to-date with the operations on the tree, such as insertion or deletion, by traversing up the parents from the affected node to increment or decrement their counts.</p>

<p>Selection of the <script type="math/tex">i^\text{th}</script> order statistic can be found easily by guiding the traversal of the tree with the augmented size information.</p>

<ul>
<li>the node in question is itself the ith order statistic, because <script type="math/tex">a = i - 1</script></li>
<li>the <script type="math/tex">i^\text{th}</script> order is somewhere in the left subtree, recurse</li>
<li>the <script type="math/tex">i^\text{th}</script> order is somewhere in the right subtree, recurse. Since the right
subtree only knows about itself, shift <script type="math/tex">i</script> to discard the left subtree and the
root node.</li>
</ul>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span> <span class="nf">Select</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">left_size</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">?</span> <span class="n">size</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// The current node is itself the ith order statistic</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">left_size</span> <span class="o">==</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// The ith order statistic is in the left subtree</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">left_size</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Select</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// The ith order statistic is in the right subtree.</span>
  <span class="c1">// The right subtree only knows about itself, so shift the ith order</span>
  <span class="c1">// appropriately.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">left_size</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Select</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">left_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure><h1 id="search-trees">
<span class="hash">#</span>
<a href="#search-trees" class="header-link">2-3 Search Trees</a>
</h1>
<p>While <strong>2-3 search tree</strong> can be implemented, they&#39;re mainly used to help understand the implementation of <a href="#red-black-trees">Red-Black Trees</a>, which have better performance.</p>

<p>A <strong>2-3 tree</strong> is either empty or:</p>

<ul>
<li><strong>2-node</strong>: one key and two links

<ul>
<li>left for keys smaller than the left key</li>
<li>right for keys larger than the right key</li>
</ul></li>
<li><strong>3-node</strong>: two keys and three links

<ul>
<li>left for keys smaller than the left key</li>
<li>middle for keys between the node&#39;s keys</li>
<li>right for keys larger than the right key</li>
</ul></li>
</ul>
<h2 id="tree-searching">
<span class="hash">#</span>
<a href="#tree-searching" class="header-link">2-3 Tree Searching</a>
</h2>
<p>Searching follows simply from the structure of the tree.</p>

<ol>
<li><strong>search hit</strong> if the key is in the node</li>
<li>if not, recurse into the appropriate link</li>
<li><strong>search miss</strong> if a null link is reached</li>
</ol>
<h2 id="tree-insertion">
<span class="hash">#</span>
<a href="#tree-insertion" class="header-link">2-3 Tree Insertion</a>
</h2>
<p>Insertion needs to take into consideration the fact that the tree must remain balanced after the operation. The general procedure is that the key is searched for until a node with a null link is reached at the bottom of the tree.</p>

<ul>
<li><strong>single 2-node</strong>

<ol>
<li>replace the 2-node with a 3-node containing the new key</li>
</ol></li>
<li><strong>single 3-node</strong>

<ol>
<li>create two 2-nodes out of each of the two keys</li>
<li>replace the 3-node with a 2-node consisting of the new key</li>
<li>set the 2-node&#39;s links to the two new 2-nodes</li>
</ol></li>
<li><strong>3-node with 2-node parent</strong> (slight variation of above)

<ol>
<li>create two 2-nodes out of each of the two keys</li>
<li>move the new key into the parent 2-node to make it a 3-node</li>
<li>set the middle link to the 3-node&#39;s left key and right link to the right key</li>
</ol></li>
<li><strong>3-node with 3-node parent</strong>

<ol>
<li>propagate the above operation until the root or a 2-node is encountered</li>
<li>if the root is encountered, split it as in the case of a single 3-node</li>
</ol></li>
</ul>

<p>Perfect balance is preserved because tree height increase occurs at the root, and additions at the bottom of the tree are performed in the form of splitting existing nodes such that the height remains the same.</p>

<p>The <strong>problem</strong> with implementing a direct representation of 2-3 trees is that there are many cases to handle and nodes have to be converted between various types. These operations can incur overhead that nullifies or even makes worse the performance of 2-3 trees compared to regular BSTs.</p>
<h1 id="red-black-trees">
<span class="hash">#</span>
<a href="#red-black-trees" class="header-link">Red-Black Trees</a>
</h1>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(2 \lg {n})</script></td>
</tr>
</tbody>
</table>

<p><a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black trees</a> are trees that guarantee near-perfect balance by maintaining 5 invariants:</p>

<ol>
<li>a node is either <strong>red</strong> or <strong>black</strong></li>
<li>root is <strong>black</strong></li>
<li>all leaves---represented as nil---are <strong>black</strong></li>
<li>both children of every <strong>red</strong> node are <strong>black</strong>, i.e. there must not be more than one <strong>red</strong> node in a row in any vertical path</li>
<li>every path from a given node to any of its descendant leaves contains the same number of <strong>black</strong> nodes</li>
</ol>

<p><img src="/images/notes/algorithms/red-black-trees/red-black-tree.png" class="center" /></p>

<p>These properties allow red-black trees to be nearly balanced in even the worst case, allowing them more performance than regular BSTs. A very neat implementation is <a href="https://github.com/prasanthmadhavan/Red-Black-Tree/blob/master/rbtree.c">available here</a>.</p>
<h2 id="red-black-tree-insertion">
<span class="hash">#</span>
<a href="#red-black-tree-insertion" class="header-link">Red-Black Tree Insertion</a>
</h2>
<p>The inserted node is attached in the same manner as for BSTs, except that every node is painted <strong>red</strong> on insertion. However, the inserted node has the possibility of violating any one of the 5 invariants, in which case the situation must be remedied. The following code representing the different cases that must be remedied are split into corresponding individual functions for didactic purposes.</p>

<p>There are three main scenarios that may arise from adding a node:</p>

<ol>
<li>first node added creates a <strong>red</strong> root, violating property <strong>2</strong> (root is <strong>black</strong>)</li>
<li>node is added as child of <strong>black</strong> node, operation completes successfully</li>
<li>consecutive <strong>red</strong> nodes, violating properties <strong>4</strong> (both children of <strong>red</strong> nodes are <strong>black</strong>) and <strong>5</strong> (equal number of <strong>black</strong> nodes per path)</li>
</ol>

<p>Note that scenarios 1 and 3 violate the properties of red-black trees.</p>

<p><strong>First</strong>, the inserted node may be the only node in the tree, making it the root. Since all nodes are inserted as <strong>red</strong>, it should be repainted <strong>black</strong> to satisfy property <strong>2</strong> (root is <strong>black</strong>):</p>
<figure class="codeblock">
<pre>
<code class="highlight language-c"><span class="kt">void</span> <span class="nf">insert_case1</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">insert_case2</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Second</strong>, if the parent of the inserted node is <strong>black</strong>, the insertion is complete because it is not possible for that to have violated any of the properties:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-c"><span class="kt">void</span> <span class="nf">insert_case2</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">insert_case3</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Third</strong>, it is possible that the inserted node creates two consecutive <strong>red</strong> nodes, violating property <strong>5</strong> (equal number of <strong>black</strong> nodes per path). For this, there are three different scenarios:</p>

<ol type="a">
 <li>parent and uncle are both red</li>
 <li>direction in which new node and parent lean differ</li>
 <li>new node and parent lean in the same direction</li>
</ol>

<p><strong>First</strong>, if the parent and its uncle are <strong>red</strong>, flip their colors and make the grandparent <strong>red</strong> instead. This allows the newly added <strong>red</strong> node to satisfy all properties, since its parent is <strong>black</strong>. However, making the grandparent <strong>red</strong> may possibly violate properties <strong>2</strong> (root is <strong>black</strong>) and <strong>4</strong> (both children of <strong>red</strong> nodes are <strong>black</strong>), so recurse the enforcement algorithm on the grandparent starting from case 1:</p>

<p><img src="/images/notes/algorithms/red-black-trees/insert_1.png" class="center"></p>
<figure class="codeblock">
<pre>
<code class="highlight language-c"><span class="kt">void</span> <span class="nf">insert_case3a</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">uncle</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="o">*</span><span class="n">g</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
    <span class="n">u</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">grandparent</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">g</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>

    <span class="n">insert_case1</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span>
    <span class="n">insert_case4</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Second</strong>, the new node could be added diagonal to a <strong>red</strong> parent node, meaning for example the parent node being <strong>red</strong> and the <strong>left child</strong> of its parent and the new node could be <strong>red</strong> (as always) and the <strong>right child</strong> of its parent.</p>

<p>This is ultimately resolved by two rotations, but the first rotation is made to get the new node leaning in the same direction as its parent. This is accomplished by rotating the new node in the direction of the parent&#39;s direction from its parent. In the above example, the new node is its parent&#39;s <strong>right child</strong> and the parent is the grandparent&#39;s <strong>left child</strong>, so the new node is <strong>rotated left</strong>.</p>

<p>There are still consecutive <strong>red</strong> nodes after this rotation, albeit leaning in the same direction. This makes it simple for case 3c to handle, provided it is applied to the ex-parent, i.e. the now-bottom node, since case 3c operates in a more general sense from the perspective of the grandchild.</p>

<p><img src="/images/notes/algorithms/red-black-trees/insert_2.png" class="center"></p>
<figure class="codeblock">
<pre>
<code class="highlight language-c"><span class="kt">void</span> <span class="nf">insert_case3b</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">g</span> <span class="o">=</span> <span class="n">grandparent</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rotate_left</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rotate_right</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">insert_case5</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Third</strong>, the new node could be added below a <strong>red</strong> parent node and leaning in the same direction. For example, the new node is the <strong>left child</strong> of its parent and its parent is the <strong>left child</strong> of its parent (grandparent of the new node) as well.</p>

<p>This is resolved by rotating the grandparent in the direction <strong>opposite</strong> to the direction in which the consecutive <strong>red</strong> links lean. This has the effect of making the parent be the new root of the subtree previously rooted by the grandparent.</p>

<p>The grandparent was known to be <strong>black</strong>, since the <strong>red</strong> parent could not have been a child of it otherwise. Knowing this, the parent---now the root---switches colors with the grandparent, such that the subtree now consists of the <strong>black</strong> root and two <strong>red</strong> children.</p>

<p><img src="/images/notes/algorithms/red-black-trees/insert_3.png" class="center"></p>
<figure class="codeblock">
<pre>
<code class="highlight language-c"><span class="kt">void</span> <span class="nf">insert_case3c</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">g</span> <span class="o">=</span> <span class="n">grandparent</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
  <span class="n">g</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
    <span class="n">rotate_right</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">rotate_left</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure><h2 id="red-black-tree-deletion">
<span class="hash">#</span>
<a href="#red-black-tree-deletion" class="header-link">Red-Black Tree Deletion</a>
</h2>
<p>Deletion is handled similar to deletion in BSTs, but is a <em>lot</em> more complicated because the tree has to be re-balanced if removing a node from the tree causes it to become unbalanced.</p>

<p>Every resource I looked at---books, sites, university slides---simply hand-waived the deletion process presumably due to its complexity. The one place that managed to somewhat explain it well was the classic CLRS book, but its implementation consisted of a big, difficult-to-follow while-loop. Instead I decided to go with <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal">wikipedia&#39;s</a> long and dense explanation of its relatively simple implementation which even the <a href="https://github.com/torvalds/linux/blob/master/lib/rbtree.c">Linux kernel uses</a>.</p>

<p><strong>First</strong>, if the node to be deleted has two children then it is replaced by its successor. The successor then has to be deleted, and by definition the successor will have at most one non-leaf child, otherwise it would not be the minimum in that subtree and the left child would have been followed.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-c"><span class="kt">void</span> <span class="nf">delete</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">if</span>      <span class="p">(</span><span class="o">*</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="n">delete</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span>  <span class="n">key</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="n">delete</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// replace with successor</span>
      <span class="n">node</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">minimum_node</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
      <span class="n">m</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
      <span class="n">delete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
</code></pre></figure>
<p><strong>Second</strong>, if the node to be deleted has one child, simply replace the successor with its child.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-c">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// replace with child, delete child</span>
      <span class="n">delete_one_child</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
</code></pre></figure>
<p><strong>Third</strong>, if the node to be deleted has no children, then it is possible to simply delete it.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-c">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// no children, just delete</span>
      <span class="n">free</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure><h3 id="red-black-tree-balance">
<span class="hash">#</span>
<a href="#red-black-tree-balance" class="header-link">Red-Black Tree Balance</a>
</h3>
<p>If the node is replaced with a successor, that successor is essentially removed from its original location, thereby possibly causing tree unbalanced. For this reason, the original successor node is removed using <code>delete_one_child</code> which re-balances the tree if necessary.</p>

<ul>
<li>node <script type="math/tex">M</script>: successor to the node to be deleted</li>
<li>node <script type="math/tex">C</script>: child of <script type="math/tex">M</script>, prioritized to be a non-leaf child if possible</li>
<li>node <script type="math/tex">N</script>: child <script type="math/tex">C</script> in its new position</li>
<li>node <script type="math/tex">P</script>: <script type="math/tex">N</script>&#39;s parent</li>
<li>node <script type="math/tex">S</script>: <script type="math/tex">N</script>&#39;s sibling</li>
<li>nodes <script type="math/tex">S_{L}</script> and <script type="math/tex">S_{R}</script>: <script type="math/tex">S</script>&#39;s left and right child respectively</li>
</ul>

<p><strong>First</strong>, if <script type="math/tex">M</script> is <strong>red</strong>, then simply replace it with its child <script type="math/tex">C</script> which must be <strong>black</strong> by property 4 (both children of <strong>red</strong> nodes are <strong>black</strong>). Any paths that passed through the deleted node will simply pass through one fewer <strong>red</strong> node, maintaining balance:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-c"><span class="kt">void</span> <span class="nf">delete_one_child</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="o">?</span> <span class="n">n</span><span class="o">-&gt;</span><span class="nl">left</span> <span class="p">:</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>

  <span class="n">replace_node</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
</code></pre></figure>
<p><strong>Second</strong>, if <script type="math/tex">M</script> is <strong>black</strong> and <script type="math/tex">C</script> is <strong>red</strong>, paint <script type="math/tex">C</script> <strong>black</strong> and put it in <script type="math/tex">M</script>&#39;s place. This preserves the same amount of <strong>black</strong> nodes along that path:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-c">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span>
      <span class="n">child</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
</code></pre></figure>
<p><strong>Third</strong>, the most complex case is when both <script type="math/tex">M</script> and <script type="math/tex">C</script> are <strong>black</strong>. Replacing one with the other effectively removes one <strong>black</strong> node along that path, unbalancing the tree. Begin by replacing <script type="math/tex">M</script> with its child <script type="math/tex">C</script>, then proceed to the first re-balancing case:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-c">    <span class="k">else</span>
      <span class="nf">delete_case1</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>

  <span class="n">free</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p>When both <script type="math/tex">M</script> and <script type="math/tex">C</script> are <strong>black</strong> nodes, four situations <sup id="fnref5"><a href="#fn5" rel="footnote">5</a></sup> can arise that require re-balancing, unless <script type="math/tex">C</script>&#39;s new position <script type="math/tex">N</script> is the new root. If <script type="math/tex">C</script> becomes the root it simply means that a <strong>black</strong> node was removed from all paths, effectively decreasing the black-height of every path by one and the tree therefore requires no re-balancing.</p>

<p><strong>First</strong>: <script type="math/tex">N</script>&#39;s sibling <script type="math/tex">S</script> is <strong>red</strong>. In this case, reverse the colors of <script type="math/tex">P</script> and <script type="math/tex">S</script> and rotate <script type="math/tex">P</script> left. Although all paths still have the same black-height, <script type="math/tex">N</script>&#39;s sibling <script type="math/tex">S</script> is now <strong>black</strong> and its parent <script type="math/tex">P</script> is <strong>red</strong>, allowing fall-through to case 4, 5, or 6:</p>

<p><img src="/images/notes/algorithms/red-black-trees/delete_1.png" class="center"></p>
<figure class="codeblock">
<pre>
<code class="highlight language-c"><span class="kt">void</span> <span class="nf">delete_case1</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="n">node</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sibling</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
      <span class="n">rotate_left</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="n">rotate_right</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">delete_case2</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Second</strong>: <script type="math/tex">P</script>, <script type="math/tex">S</script>, and <script type="math/tex">S</script>&#39;s children are all <strong>black</strong>. Repaint <script type="math/tex">S</script> <strong>red</strong> so that all paths passing through <script type="math/tex">S</script> have the same black-height as those that go through <script type="math/tex">N</script>.</p>

<p><img src="/images/notes/algorithms/red-black-trees/delete_2a.png" class="center"></p>

<p>If <script type="math/tex">P</script> is <strong>red</strong>, then the tree is violating property <strong>4</strong> (both children of <strong>red</strong> nodes are <strong>black</strong>), fix it by simply painting <script type="math/tex">P</script> <strong>black</strong>.</p>

<p><img src="/images/notes/algorithms/red-black-trees/delete_2b.png" class="center"></p>

<p>Otherwise, if <script type="math/tex">P</script> was already <strong>black</strong>, however, then after the painting of <script type="math/tex">S</script> to <strong>red</strong>, <script type="math/tex">P</script> now has effectively lost one level from its black-height, so case 1 should be applied to <script type="math/tex">P</script>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-c"><span class="kt">void</span> <span class="nf">delete_case2</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sibling</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span> <span class="o">&amp;&amp;</span>
      <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span> <span class="o">&amp;&amp;</span>
      <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span>
      <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span>
    <span class="k">else</span>
      <span class="n">delete_case1</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span>
    <span class="n">delete_case3</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Third</strong>: <script type="math/tex">S</script> is <strong>black</strong>, <script type="math/tex">S_{L}</script> is <strong>red</strong>, <script type="math/tex">S_{R}</script> is <strong>black</strong>, <script type="math/tex">N</script> is left child of its <script type="math/tex">P</script>. Rotate <script type="math/tex">S</script> right, then exchange colors of <script type="math/tex">S</script> and its new parent. This case just prepares the tree for falling into case 6, since <script type="math/tex">N</script> now has a <strong>black</strong> sibling---<script type="math/tex">S_{L}</script>---whose right child is <strong>red</strong>.</p>

<p><img src="/images/notes/algorithms/red-black-trees/delete_3.png" class="center"></p>
<figure class="codeblock">
<pre>
<code class="highlight language-c"><span class="kt">void</span> <span class="nf">delete_case3</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sibling</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span> <span class="o">&amp;&amp;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
      <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
      <span class="n">rotate_right</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="cm">/* symmetric to above */</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">delete_case4</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Fourth</strong>: <script type="math/tex">S</script> is <strong>black</strong>, <script type="math/tex">S_{R}</script> is <strong>red</strong>, <script type="math/tex">N</script> is left child of its <script type="math/tex">P</script>. Rotate <script type="math/tex">P</script> left, exchange colors of <script type="math/tex">P</script> and <script type="math/tex">S</script>, and make <script type="math/tex">S_{R}</script> <strong>black</strong>.</p>

<p>This unbalances the tree by increasing black-height of paths through <script type="math/tex">N</script> by one because either <script type="math/tex">P</script> became <strong>black</strong> or it was <strong>black</strong> and <script type="math/tex">S</script> became a <strong>black</strong> grandparent.</p>

<p><img src="/images/notes/algorithms/red-black-trees/delete_4.png" class="center"></p>
<figure class="codeblock">
<pre>
<code class="highlight language-c"><span class="kt">void</span> <span class="nf">delete_case4</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sibling</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span><span class="p">;</span>
  <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
    <span class="n">rotate_left</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
    <span class="n">rotate_right</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure><h1 id="hash-tables">
<span class="hash">#</span>
<a href="#hash-tables" class="header-link">Hash Tables</a>
</h1>
<p>Hash tables consist of an array coupled with a <em>hash function</em>---such as <a href="http://en.wikipedia.org/wiki/MurmurHash">MurmurHash</a> or <a href="http://en.wikipedia.org/wiki/CityHash">CityHash</a>---and a <em>collision resolution</em> scheme, both of which help map the key to an index within the array.</p>

<p>Hash Tables can be used for de-duplication, as well as keeping track of what states have already been seen in search algorithms, especially for those applications where it&#39;s not feasible to store all of the nodes.</p>

<p>In the 2-SUM problem, given an unsorted array of <script type="math/tex">n</script> integers and a target sum <script type="math/tex">t</script>, we need to find if there is a pair of integers that sum to <script type="math/tex">t</script>.</p>

<p>The brute-force approach is to check all possible pairs in <script type="math/tex">O(n^2)</script> to see if they add up to the target <script type="math/tex">t</script>.</p>

<p>Alternatively, we can sort the array in <script type="math/tex">O(n \log n)</script> and scan through the array, for each element <script type="math/tex">x</script> determine the required summand <script type="math/tex">r = t - x</script>, then look for <script type="math/tex">r</script> in the array using binary search <script type="math/tex">O(n \log n)</script>. If <script type="math/tex">r</script> is found, then there&#39;s a match, i.e. <script type="math/tex">x + r = t</script>.</p>

<p>This can be improved further by using a hash table. Put each element of the array into a hash table, then for each element <script type="math/tex">x</script> in the array compute the required summand <script type="math/tex">r = t - x</script> and check if <script type="math/tex">r</script> is present in the hash table. If so, then there&#39;s a match.</p>
<h2 id="hash-functions">
<span class="hash">#</span>
<a href="#hash-functions" class="header-link">Hash Functions</a>
</h2>
<p>Hash functions need to be consistent, efficient, and should uniformly distribute the set of keys.</p>

<p>A popular and simple hashing function is modular hashing of the form:</p>

<p><script type="math/tex; mode=display">h(k) = k \bmod M</script></p>

<p>where <script type="math/tex">k</script> is the key and <script type="math/tex">M</script> is the array size, used to avoid integer overflow, usually chosen to be prime. Multiple pieces of data can be combined into one hash by doing:</p>

<p><script type="math/tex; mode=display">(H * R + D) \bmod M</script></p>

<p>where <script type="math/tex">R</script> is a prime number such as a 31, <script type="math/tex">H</script> is the hash as constructed so far (initially set to some prime number) and <script type="math/tex">D</script> is the new piece of data.</p>

<p>For example, given a three properties---day, month, and year---the following hash computation could be used:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="n">hash</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">day</span>  <span class="o">)</span> <span class="o">%</span> <span class="n">M</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="n">hash</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">month</span><span class="o">)</span> <span class="o">%</span> <span class="n">M</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="n">hash</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">year</span> <span class="o">)</span> <span class="o">%</span> <span class="n">M</span><span class="o">;</span>

<span class="c1">// or</span>
<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(((((</span><span class="mi">0</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">day</span><span class="o">)</span> <span class="o">%</span> <span class="n">M</span><span class="o">)</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">month</span><span class="o">)</span> <span class="o">%</span> <span class="n">M</span><span class="o">)</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">year</span><span class="o">)</span> <span class="o">%</span> <span class="n">M</span><span class="o">;</span>
</code></pre></figure>
<p>Or to hash a given string:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
  <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">hash</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">%</span> <span class="n">M</span><span class="o">;</span>
</code></pre></figure>
<p>A simpler hashing scheme that doesn&#39;t account for integer overflow is:</p>

<p><script type="math/tex; mode=display">R * H</script></p>

<p>So for example, given a day, month, and year:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">R</span> <span class="o">+</span> <span class="n">day</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">month</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">year</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">((</span><span class="n">R</span> <span class="o">+</span> <span class="n">day</span><span class="o">)</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">month</span><span class="o">)</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">year</span><span class="o">;</span>
</code></pre></figure><h2 id="pathological-data-sets">
<span class="hash">#</span>
<a href="#pathological-data-sets" class="header-link">Pathological Data Sets</a>
</h2>
<p>It&#39;s possible to craft a pathological data set that can cause a denial of service attack on a hash table.</p>

<p>One way to mitigate this is to use a cryptographic hash function, which also has pathological data sets but it&#39;s less feasible to discover them.</p>

<p>Alternatively, design a family of hash functions and choose one randomly.</p>
<h2 id="load-factor">
<span class="hash">#</span>
<a href="#load-factor" class="header-link">Load Factor</a>
</h2>
<p>The <em>load factor</em> is defined by <script type="math/tex">\alpha = N/M</script> where <script type="math/tex">\alpha</script> is the percentage of table entries that are occupied, <script type="math/tex">N</script> is the number of objects in the hash table, and <script type="math/tex">M</script> is the number of buckets in the hash table.</p>

<p><script type="math/tex; mode=display">
\text {load factor}\ \alpha =
  \frac {\text {# of objects in hash table}}
        {\text {# of buckets in hash table}}
</script></p>

<p>Note that a load factor is still relevant in an open addressing scheme, in which case each bucket can only hold one value.</p>

<p>In linear probing, <script type="math/tex">\alpha</script> can never be 1 because if the table becomes full, a search miss would go into an infinite loop. Instead, array resizing is performed to ensure that the load factor is between <script type="math/tex">\frac {1} {8}</script> and <script type="math/tex">\frac {1} {2}</script>.</p>

<p>The average number of compares, or <em>probes</em>, in a linear-probing hash table of size <script type="math/tex">M</script> and <script type="math/tex">N = \alpha M</script> keys is:</p>

<p><script type="math/tex; mode=display">
\text {hits: ~} \frac {1} {2} \left( 1 + \frac {1} {1 - \alpha} \right) \\
\text {misses: ~} \frac {1} {2} \left( 1 + \frac {1} {\left( 1 - \alpha \right)^2} \right)
</script></p>

<p>Based on this, when <script type="math/tex">\alpha</script> is about 0.5 there will be 1.5 compares for a search hit and 2.5 compares for a search miss on average. For this reason, <script type="math/tex">\alpha</script> should be kept under 0.5 through the use of array resizing.</p>
<h2 id="separate-chaining">
<span class="hash">#</span>
<a href="#separate-chaining" class="header-link">Separate Chaining</a>
</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(\lg {n})</script></td>
</tr>
</tbody>
</table>

<p>This collision resolution strategy involves storing a linked-list at every entry in the array. The intent is to choose the size of the array large enough so that the linked-lists are sufficiently short.</p>

<p>Separate chaining consists of a two-step process:</p>

<ol>
<li>hash the key to get the index to retrieve the list</li>
<li>sequentially search the list for the key</li>
</ol>

<p>A property of separate chaining is that the average length of the lists is always <script type="math/tex">N/M</script> in a hash table with <script type="math/tex">M</script> lists and <script type="math/tex">N</script> keys.</p>
<h2 id="double-hashing">
<span class="hash">#</span>
<a href="#double-hashing" class="header-link">Double Hashing</a>
</h2>
<p>Double hashing is a form of open addressing in which two hash functions are used. If the first hash function incurs a collision, then the result of the second hash function serves as an offset at which to try insertion. For example, if <script type="math/tex">h_1(x) = 17</script> caused a collision, and <script type="math/tex">h_2(x) = 23</script>, then it will try inserting at position <script type="math/tex">17 + 23 = 40</script>, then <script type="math/tex">40 + 23 = 63</script>, and so on.</p>
<h2 id="linear-probing">
<span class="hash">#</span>
<a href="#linear-probing" class="header-link">Linear Probing</a>
</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(c \lg {n})</script></td>
</tr>
</tbody>
</table>

<p>Linear probing is a form of open addressing that relies on empty entries in the array for collision resolution. Linear probing simply consists of:</p>

<ol>
<li>hash the key to get the index</li>
<li>the element at the index determines three outcomes:

<ol>
<li>if it&#39;s an empty position, insert the element</li>
<li>if the position is not empty and the key is equal, replace the value</li>
<li>if the key is not equal, try the next entry and repeat until it can be inserted</li>
</ol></li>
</ol>
<h3 id="linear-probing-deletion">
<span class="hash">#</span>
<a href="#linear-probing-deletion" class="header-link">Linear Probing Deletion</a>
</h3>
<p>The insert and retrieval operations retrieve the index and perform the same operation until the entry is null. This has the consequence that deleting a node cannot <em>simply</em> entail setting the entry to null, or it would prematurely stop the lookup of other keys.</p>

<p>As a result, after setting the entry to null, every key to the right of the removed key also has to be removed, i.e. set to null, and then re-inserted into the hash table using the regular insertion operation.</p>
<h2 id="sparse-vectors">
<span class="hash">#</span>
<a href="#sparse-vectors" class="header-link">Sparse Vectors</a>
</h2>
<p>An application of hash tables can be to implement sparse vectors for the purpose of performing matrix-vector multiplications. In certain situations, the row-vector from a matrix can have a very small amount of non-zero elements. If the matrix was stored in a naive array format it would amount to an immense waste of space and computation.</p>

<p>Instead, sparse vectors are vectors backed by hash tables where the keys correspond to the index of a given element and the value corresponds to that element&#39;s value. This solution is used in Google&#39;s PageRank algorithm.</p>
<h1 id="bloom-filters">
<span class="hash">#</span>
<a href="#bloom-filters" class="header-link">Bloom Filters</a>
</h1>
<p>Bloom filters are useful for remembering which values have been seen; they don&#39;t store the actual values or keys, so they use very little space. There are no deletions.</p>

<p>Membership lookups can yield false-positives, but <em>not</em> false-negatives. So a bloom filter can answer if an element is <strong>possibly in the set</strong> or <strong>definitely not in the set</strong>.</p>

<p>For example, a bloom filter could be used to back a spell-checker. All correctly spelled words are inserted into the bloom filter, then a word can be checked for correct spelling by checking if it&#39;s in the bloom filter. However, since there is a small possibility of a false-positive, it may incorrectly determine that the word is correctly spelled even if it&#39;s not.</p>

<p>Bloom filters are often used in network routers for tasks such as keeping track of blocked IP addresses, the contents of a cache to avoid spurious lookups, and maintaining statistics to prevent denial of service attacks.</p>

<p>Bloom filters consist of a bitset, where each entry uses <script type="math/tex">\frac n {|S|}</script> bits. The bloom filter has <script type="math/tex">k</script> hash functions.</p>

<p>Insertion is accomplished by hashing the input with each of the <script type="math/tex">k</script> hash functions and turning on the bit at that position, regardless of whether that bit was already on.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">hash_function</span> <span class="p">:</span> <span class="n">hash_functions</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bits</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hash_function</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></figure>
<p>Lookup is accomplished by hashing the input with each hash function and checking if <em>all</em> of those positions is on.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">hash_function</span> <span class="p">:</span> <span class="n">hash_functions</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hash_function</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</code></pre></figure>
<p>Therefore the false-positives come about if other insertions set the same bits as those used by other elements.</p>
<h1 id="graphs">
<span class="hash">#</span>
<a href="#graphs" class="header-link">Graphs</a>
</h1>
<p>A <em>graph</em> is a set of <em>vertices</em> and a collection of <em>edges</em> that each connect a pair of vertices. This definition allows for <em>self-loops</em> (edges that connect a vertex to itself) and <em>parallel edges</em> (multiple edges connecting the same vertex pair).</p>

<p>Graphs with parallel edges are sometimes known as <em>multigraphs</em>, whereas graphs with no parallel edges or self-loops are <em>simple graphs</em>.</p>

<p>Two vertices connected by an edge are <em>adjacent</em>, and the edge is <em>incident</em> to both vertices. A vertex&#39; <em>degree</em> is the number of edges connected to it. A <em>subgraph</em> is a sub-set of edges and associated vertices that still constitutes a graph.</p>

<p>Paths in graphs are sequences of vertices connected by edges. <em>Simple paths</em> have no repeated vertices. A path forms a <em>cycle</em> if it has at least one edge whose first and last vertices are the same, and a <em>simple cycle</em> if the cycle consists of no repeated edges or vertices. The number of edges in a path determines its <em>length</em>.</p>

<p>A graph is <em>connected</em> if a path exists from every vertex to every other vertex. A graph that isn&#39;t connected consists of <em>connected components</em> which are connected subgraphs of the graph.</p>

<p><em>Acyclic graphs</em> are graphs with no cycles. A tree is an acyclic connected graph, and a disjoint set of trees is a <em>forest</em>.</p>

<p>A graph <script type="math/tex">G</script> with <script type="math/tex">V</script> vertices is a tree if any of the following are satisfied:</p>

<ul>
<li><script type="math/tex">G</script> has <script type="math/tex">V - 1</script> edges and no cycles</li>
<li><script type="math/tex">G</script> has <script type="math/tex">V - 1</script> edges and is connected</li>
<li><script type="math/tex">G</script> is connected but removing a single edge disconnects it</li>
<li><script type="math/tex">G</script> is acyclic but adding any edge creates a cycle</li>
<li>exactly one simple path connects each pair of vertices in <script type="math/tex">G</script></li>
</ul>

<p>A <em>spanning tree</em> of a connected graph is a subgraph that contains all of the vertices as a single tree. A <em>spanning forest</em> of a graph is the union of all spanning trees of its connected components.</p>

<p>A graph&#39;s <em>density</em> is its proportion of possible paris of vertices that are connected. A <em>sparse</em> graph has relatively few of the possible edges present compared to a <em>dense</em> one.</p>

<p>As a rule of thumb, a graph is considered sparse if it has an edge count closer to the number of its vertices <script type="math/tex">O(N)</script> and it&#39;s considered dense if it has an edge count closer to the number of vertices squared <script type="math/tex">O(N^2)</script>.</p>

<p>A <em>bipartite graph</em> is one whose vertices can be divided into two sets such that all edges connect a vertex in one set with a vertex in the other.</p>

<p>Oftentimes, the number of nodes/vertices is represented by <script type="math/tex">N</script> and the number of edges is represented by <script type="math/tex">M</script>.</p>

<p><strong>Answers</strong>:</p>

<ul>
<li>is there a way to connect one item to another by following the connections?</li>
<li>how many other items are connected to a given item?</li>
<li>what is the shortest chain of connections between two items?</li>
</ul>
<h2 id="undirected-graphs">
<span class="hash">#</span>
<a href="#undirected-graphs" class="header-link">Undirected Graphs</a>
</h2>
<p>An <em>undirected graph</em> is one in which the connections don&#39;t have an associated direction. There are various data structures that can be used represent graphs:</p>

<ul>
<li><strong>adjacency matrix</strong>: a <script type="math/tex">V \times V</script> boolean array where row <script type="math/tex">v</script> and column <script type="math/tex">w</script> are set to true if vertices <script type="math/tex">v</script> and <script type="math/tex">w</script> are connected with an edge.</li>
<li><strong>array of adjacency lists</strong>: a vertex-indexed array of lists of the vertices adjacent to each vertex, similar to hash tables with separate chaining</li>
<li><strong>array of edges</strong>: a collection of Edge objects each containing two instance variables for each of the connected vertices</li>
</ul>

<p>Adjacency lists have the best balance between space and time performance. They have space usage proportional to <script type="math/tex">V + E</script>, constant time to add an edge, and time proportional to the degree of <script type="math/tex">v</script> to iterate through adjacent vertices.</p>

<p>An undirected graph can have a minimum of <script type="math/tex">n - 1</script> edges and a maximum of <script type="math/tex">\binom N 2 = \frac {n (n - 1)} 2</script> edges.</p>
<h3 id="depth-first-search">
<span class="hash">#</span>
<a href="#depth-first-search" class="header-link">Depth-First Search</a>
</h3>
<p>Depth-First Search (DFS) is a graph traversal algorithm that visits a vertex, marks that vertex as visited, then visits all unmarked adjacent vertices.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Pre</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Post</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">DFS</span><span class="p">(</span><span class="n">Pre</span> <span class="n">pre</span><span class="p">,</span> <span class="n">Post</span> <span class="n">post</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">explored</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">edges_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">edges_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">node</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">explored</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="n">explored</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">this</span><span class="o">-&gt;</span><span class="n">DFS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">explored</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Pre</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Post</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">DFS</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">explored</span><span class="p">,</span> <span class="n">T</span> <span class="n">node</span><span class="p">,</span> <span class="n">Pre</span> <span class="n">pre</span><span class="p">,</span> <span class="n">Post</span> <span class="n">post</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">explored</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">edges_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">edges_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">neighbors</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>

  <span class="n">pre</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="nl">neighbor</span> <span class="p">:</span> <span class="n">neighbors</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">explored</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">neighbor</span><span class="p">.</span><span class="n">to</span><span class="p">)</span> <span class="o">==</span> <span class="n">explored</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">this</span><span class="o">-&gt;</span><span class="n">DFS</span><span class="p">(</span><span class="n">explored</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">.</span><span class="n">to</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">post</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p>To trace the paths in the graph, an array can be kept of size <script type="math/tex">V</script> indexed by a given vertex whose value is the vertex that connects to it. This array of edges represents a tree rooted at the source vertex.</p>
<h3 id="breadth-first-search">
<span class="hash">#</span>
<a href="#breadth-first-search" class="header-link">Breadth-First Search</a>
</h3>
<p>Breadth-First Search (BFS) traversal aids in finding the shortest path between two vertices. Its basic operation consists of:</p>

<ol>
<li>enqueue the source vertex</li>
<li>dequeue the current vertex</li>
<li>mark and enqueue all adjacent vertices</li>
<li>repeat 2-3 until the queue is empty</li>
</ol>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vertexQueue</span><span class="p">;</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">vertexQueue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">vertexQueue</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">vertexQueue</span><span class="p">.</span><span class="n">dequeue</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">w</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">edgeTo</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">vertexQueue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure><h3 id="connected-components">
<span class="hash">#</span>
<a href="#connected-components" class="header-link">Connected Components</a>
</h3>
<p>Depth-First Search can also be used to find connected components of a graph. This is accomplished by initiating DFS on every unmarked vertex and each time it is called on a vertex, set the vertex&#39; connected component identifier.</p>

<p>A run of DFS finds, and thus marks, every vertex in a connected component. Upon completing such a run, a counter variable signifying the connected componenet identifier is incremented and then it is called on the next unmarked vertex in the graph, i.e. a vertex not in a connected component found so far.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">FindConnectedComponents</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">components</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">explored</span><span class="p">;</span>

  <span class="n">components</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">());</span>
  <span class="n">explored</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">());</span>

  <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">();</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">explored</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">explored</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">explored</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">components</span><span class="p">);</span>
      <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">DFS</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">explored</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">components</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="o">*</span><span class="n">components</span><span class="p">)[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span> <span class="c1">// set connected component identifier</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">w</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">explored</span><span class="p">)[</span><span class="n">w</span><span class="p">])</span>
      <span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">explored</span><span class="p">,</span> <span class="n">components</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p>Compared to <a href="#dynamic-connectivity">Union-Find</a>, the DFS approach is theoretically faster because it provides a constant-time guarantee. However, in practice the difference is negligible and Union-Find tends to be faster because it doesn&#39;t have to build a full representation of a graph. Perhaps more importantly, the DFS approach has to preprocess the graph by running DFS on the separate connected components. As a result, Union-Find is an online algorithm where it can be queried even while new edges are added without having to re-preprocess the graph.</p>
<h3 id="cycle-detection">
<span class="hash">#</span>
<a href="#cycle-detection" class="header-link">Cycle Detection</a>
</h3>
<p>DFS can also be used to determine if there are cycles present in a graph. This is accomplished by keeping track of the vertex previous to the one being focused on by the DFS. If one of the current vertex&#39; neighbors is already marked and it is not the previous vertex, then it means that there is an edge to an already marked vertex, thus forming a cycle.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">bool</span> <span class="nf">detectCycles</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">();</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">w</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">!=</span> <span class="n">u</span><span class="p">)</span>
      <span class="n">hasCycle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure><h3 id="bipartite-detection">
<span class="hash">#</span>
<a href="#bipartite-detection" class="header-link">Bipartite Detection</a>
</h3>
<p>DFS can also be used to determine whether or not the graph is bipartite. Another way to frame the question is: can the vertices of the graph be assigned one of two colors such that no edge connects vertices of the game color?</p>

<p>This is accomplished by maintaining a vertex-indexed array that will store that vertex&#39; color. As DFS traverses the graph, it will alternate the color of every vertex it visits. The graph starts out as assumed to be bipartite, and only if DFS encounters a marked vertex whose color is the same as the current vertex does it conclude that the graph is not bipartite.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">bool</span> <span class="nf">bipartiteDetect</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">();</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">w</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">color</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">==</span> <span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">isBipartite</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure><h2 id="directed-graphs">
<span class="hash">#</span>
<a href="#directed-graphs" class="header-link">Directed Graphs</a>
</h2>
<p>The edges in <em>directed graphs</em> have an associated one-way direction, such that edges are defined by an ordered pair of vertices that define a one-way adjacency. A directed graph (or <em>digraph</em>) is a set of vertices and a collection of directed edges, each connecting an ordered pair of vertices. The <em>outdegree</em> of a vertex is the number of edges pointing from it, while the <em>indegree</em> is the number of edges pointing to it.</p>

<p>The first vertex in a directed edge is the <em>head</em> and the second vertex is the <em>tail</em>. Edges are drawn as arrows pointing from head to tail, such as <script type="math/tex">v \rightarrow w</script>.</p>

<p>Directed graphs can be represented by adjacency lists with the stricter property that if node <script type="math/tex">w</script> is present in the adjacency list corresponding to <script type="math/tex">v</script>, it simply means that there is a directed edge <script type="math/tex">v \rightarrow w</script>, but not vice versa unless explicitly defined.</p>
<h3 id="digraph-reachability">
<span class="hash">#</span>
<a href="#digraph-reachability" class="header-link">Digraph Reachability</a>
</h3>
<p>The same exact implementation of reachability testing by DFS used in undirected graphs can be used for digraphs, and can be expanded to allow for reachability testing from multiple sources which has applications in regular expression matchers or mark-and-sweep garbage collection strategies, for example.</p>

<p>Mark-and-sweep garbage collection (GC) strategies typically reserve one bit per object for the purpose of garbage collection. The GC then periodically <em>marks</em> a set of potentially accessible objects by running digraph reachability tests on the graph of object references, then it <em>sweeps</em> through all of the unmarked objects, collecting them for reuse for new objects.</p>
<h3 id="directed-cycle-detection">
<span class="hash">#</span>
<a href="#directed-cycle-detection" class="header-link">Directed Cycle Detection</a>
</h3>
<p>A digraph with no directed cycles is known as a directed acyclic graph (DAG). For this reason, checking a digraph for directed cycles answers the question of whether the digraph is  DAG.</p>

<p>Directed cycle detection is accomplished by maintaining a boolean array representing whether or not a directed path belongs to the same connected component. Then during DFS if the encountered vertex is already marked and is part of the same component, it returns the path from the current vertex through the cycle back to the current vertex. If no such cycle exists, the graph is a DAG.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">onStack</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">w</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hasCycle</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">edgeTo</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">onStack</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">cycle</span> <span class="o">=</span> <span class="k">new</span> <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">w</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">cycle</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

      <span class="n">cycle</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
      <span class="n">cycle</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="n">onStack</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>Currency arbitrage can be discovered if the problem is modeled as a graph where the nodes are the different kinds of currency and the edge weights are the logarithm of the exchange rate. In this case, an instance of arbitrage is one where there is a cycle with positive weight.</p>
<h3 id="topological-order">
<span class="hash">#</span>
<a href="#topological-order" class="header-link">Topological Order</a>
</h3>
<p>Topological sort puts the vertices of a digraph in order such that all of its directed edges point from a vertex earlier in the order to a vertex later in the order. Three different orders are possible, which are accomplished by saving each vertex covered by the DFS in a queue or stack, depending on the desired order:</p>

<ul>
<li><strong>preorder</strong>: put the vertex on a queue before the recursive calls</li>
<li><strong>postorder</strong>: put the vertex on a queue after the recursive calls</li>
<li><strong>reverse postorder</strong>, aka <em>topological order</em>: put the vertex on a stack after the recursive calls</li>
</ul>

<p>This ability of DFS follows from the fact that DFS covers each vertex exactly once when run on digraphs.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TopologicalOrder</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">reverse_post_order</span><span class="p">;</span>
  <span class="n">reverse_post_order</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">edges_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="k">this</span><span class="o">-&gt;</span><span class="n">DFS</span><span class="p">([](</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{},</span>
            <span class="p">[</span><span class="o">&amp;</span><span class="n">reverse_post_order</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">reverse_post_order</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="p">});</span>

  <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">reverse_post_order</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">reverse_post_order</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

  <span class="k">return</span> <span class="n">reverse_post_order</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>For example, consider an alien or unknown alphabet and we&#39;re given an array of words which are <em>sorted</em> according to the lexigraphical order of the alphabet. In order to to reconstruct, or extract, the lexicographical order of this unknown alphabet, first treat the lexicographical order simply as a &quot;relationship&quot;. Graphs can model relationships, so start by creating a node for each character.</p>

<p>Information about the lexicographical order of the alphabet can be inferred from the sorted order of the input. Word <script type="math/tex">A</script> comes before <script type="math/tex">B</script> because <script type="math/tex">A</script> mismatches with <script type="math/tex">B</script> at some character position <script type="math/tex">i</script> such that <script type="math/tex">A[i] < B[i]</script>, by definition of a lexicographical sorted order.</p>

<p>What&#39;s necessary then is to determine the mismatching characters <script type="math/tex">A[i]</script> and <script type="math/tex">B[i]</script> for each pair of adjacent words in the input and to establish a relationship between those two characters which denotes precedence, i.e. a directed edge <script type="math/tex">A[i] \to B[i]</script> to mean that <script type="math/tex">A[i]</script> comes before <script type="math/tex">B[i]</script> in the alphabet.</p>

<p>Once this is all done, the topological order of the graph can be obtained to determine the full order of the alphabet.</p>
<h3 id="strong-connectivity">
<span class="hash">#</span>
<a href="#strong-connectivity" class="header-link">Strong Connectivity</a>
</h3>
<p>Two vertices <script type="math/tex">v</script> and <script type="math/tex">w</script> are <em>strongly connected</em> if they are mutually reachable, i.e. <script type="math/tex">v \leftrightarrow w</script>. Consequently, an entire digraph is <em>strongly connected</em> if <em>all</em> of its vertices are strongly connected to one another. Further, <em>strong components</em> are connected components of a graph that are strongly connected.</p>

<p>The <a href="http://en.wikipedia.org/wiki/Kosaraju%27s_algorithm">Kosaraju-Sharir</a> algorithm is able to find strongly connected components in digraphs in <script type="math/tex">O(m + n)</script>. The algorithm operates as follows:</p>

<ol>
<li>given digraph <script type="math/tex">G</script> and its reverse digraph <script type="math/tex">G^R</script>, compute the reverse postorder of <script type="math/tex">G^R</script></li>
<li>run standard DFS on <script type="math/tex">G</script> on the vertices in the order generated by step 1</li>
<li>all vertices visited on a recursive DFS call from the constructor are a strong component, so identify them</li>
</ol>

<p>The algorithm can answer the following questions:</p>

<ul>
<li>are two given vertices strongly connected?</li>
<li>how many strong components does the digraph contain?</li>
</ul>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">findStrongComponents</span><span class="p">(</span><span class="k">const</span> <span class="n">Digraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Digraph</span> <span class="n">reverse</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">reverse</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">reverse</span><span class="p">.</span><span class="n">reversePost</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
      <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">Digraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">id</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">w</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p>The algorithm can be understood by considering a kernel DAG, or <em>condensation digraph</em>, associated with each digraph, formed by collapsing all vertices in each strong component to a single vertex. This DAG can then be put into reverse topological order. Remember that reverse postorder of a DAG is equivalent to topological sort.</p>

<p>The algorithm begins by finding a vertex that is in a sink component of the kernel DAG. A <em>sink component</em> is one that has no edges pointing from it. Running DFS from this vertex only visits the vertices in that component. DFS then marks the vertices in that component, effectively removing them from further consideration in that digraph. It then repeats this by finding another sink component in the resulting kernel DAG.</p>

<p>The first vertex in a reverse postorder of <script type="math/tex">G</script> is in a <em>source</em> component of the kernel DAG, whereas the first vertex in a reverse postorder of the <em>reverse</em> digraph <script type="math/tex">G^R</script> is in a <em>sink</em> component of the kernel DAG.</p>
<h3 id="all-pairs-reachability">
<span class="hash">#</span>
<a href="#all-pairs-reachability" class="header-link">All-Pairs Reachability</a>
</h3>
<p>All-Pairs reachability asks: given a digraph, is there a directed path from a given vertex <script type="math/tex">v</script> to another given vertex <script type="math/tex">w</script>? This can be answered by creating a separate graph representation known as a transitive closure, which allows for straightforward checking of which vertex is reachable by others.</p>

<p><img src="/images/notes/algorithms/graphs/transitive-closure.png" class="right"></p>

<p>The <em>transitive closure</em> of digraph <script type="math/tex">G</script> is another digraph with the same set of vertices but with an edge from <script type="math/tex">v</script> to <script type="math/tex">w</script> in the transitive closure if and only if <script type="math/tex">w</script> is reachable from <script type="math/tex">v</script> in <script type="math/tex">G</script>. Transitive closures are generally represented as a matrix of booleans where row <script type="math/tex">v</script> at column <script type="math/tex">w</script> is true if <script type="math/tex">w</script> is reachable from <script type="math/tex">v</script> in the digraph.</p>

<p>Finding the transitive closure of a digraph can be accomplished by running DFS on every vertex of the digraph and storing the resulting reachability array for each each vertex from which DFS was run. However, it can be impractical for large graphs because it uses space proportional to <script type="math/tex">V^2</script> and time proportional to <script type="math/tex">V(V + E)</script>.</p>
<h2 id="dynamic-connectivity">
<span class="hash">#</span>
<a href="#dynamic-connectivity" class="header-link">Dynamic Connectivity</a>
</h2>
<p><strong>Answers</strong>: Is a pair of nodes connected?</p>

<p><strong>Data Structure</strong>: Array, indexed by any given site to the value corresponding to the component its a part of: <code>id[site] = component</code>. All sites are initially set to be members of their own component, i.e. <code>id[5] = 5</code>.</p>

<p><strong>General Flow</strong>: Sites are all partitioned into singleton sets. Successive <code>union()</code> operations merge sets together. The <code>find()</code> operation determines if a given pair of sites are from the same component.</p>

<p>A <em>site</em> is an element or node in a disjoint set. The disjoint set is known as a <em>component</em>, which typically models a set or graph. Two sites are <em>connected</em> if they are part of the same component.</p>
<h3 id="quick-find">
<span class="hash">#</span>
<a href="#quick-find" class="header-link">Quick-Find</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Operation</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Find</td>
<td style="text-align: left"><script type="math/tex">O(1)</script></td>
</tr>
<tr>
<td style="text-align: left">Union</td>
<td style="text-align: left"><script type="math/tex">O(n)</script></td>
</tr>
</tbody>
</table>

<p>This algorithm favors a quick <code>find()</code> operation by sacrificing the <code>union()</code> operation.</p>

<p>Union operates as follows:</p>

<ol>
<li>of the two sites <script type="math/tex">P</script> and <script type="math/tex">Q</script>, <em>arbitrarily</em> choose one to merge under the other</li>
<li>gets the associated components of <script type="math/tex">P</script> and <script type="math/tex">Q</script></li>
<li>goes through the whole array, setting sites which were part of <script type="math/tex">P</script>&#39;s component to now be part of <script type="math/tex">Q</script>&#39;s</li>
<li>decrements the number of components in the disjoint-set</li>
</ol>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">site</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">id</span><span class="o">[</span><span class="n">site</span><span class="o">];</span> <span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">pID</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">qID</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">pID</span> <span class="o">==</span> <span class="n">qID</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">id</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">id</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">pID</span><span class="o">)</span> <span class="n">id</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">qID</span><span class="o">;</span>

  <span class="n">count</span><span class="o">--;</span>
<span class="o">}</span>
</code></pre></figure><h3 id="quick-union">
<span class="hash">#</span>
<a href="#quick-union" class="header-link">Quick-Union</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Operation</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Find</td>
<td style="text-align: left"><script type="math/tex">\text{tree height}</script></td>
</tr>
<tr>
<td style="text-align: left">Union</td>
<td style="text-align: left"><script type="math/tex">\text{tree height}</script></td>
</tr>
</tbody>
</table>

<p>This algorithm aims to speed up the <code>union()</code> operation by avoiding the act of going through the whole array to change the component of every affected site.</p>

<p>This is accomplished by creating a tree-like relationship between sites. With a tree representation, sites are added as direct leaves to the root node of the component to which they were merged.</p>

<p>As a result of this, the <code>find()</code> operation needs to walk up the tree from any given site to find the root note which designates the component to which the given site belongs to. The walk is terminated when it encounters a site whose component is itself.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">])</span> <span class="n">p</span> <span class="o">=</span> <span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">];</span>
  <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="n">id</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>

  <span class="n">count</span><span class="o">--;</span>
<span class="o">}</span>
</code></pre></figure><h3 id="weighted-quick-union">
<span class="hash">#</span>
<a href="#weighted-quick-union" class="header-link">Weighted Quick-Union</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Operation</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Find</td>
<td style="text-align: left"><script type="math/tex">\lg(n)</script></td>
</tr>
<tr>
<td style="text-align: left">Union</td>
<td style="text-align: left"><script type="math/tex">\lg(n)</script></td>
</tr>
</tbody>
</table>

<p>The problem with vanilla Quick-Union is that the trees are merged arbitrarily. This can cause bad performance depending on which tree is merged under the other.</p>

<p>Given the arbitrary form in which components are merged in Quick-Union, input of the form 0-1, 0-2, 0-3, ... 0-N can have worst-case effects:</p>

<ol>
<li>0-1 can connect component 0 under component 1</li>
<li>0-2 can connect component 1 under component 2</li>
<li>0-3 can connect component 2 under component 3</li>
</ol>

<p>This input eventually creates a linked-list, where the deepest node in the tree incurs the cost of having to traverse the entire list of sites before determining the component to which it belongs.</p>

<p>Weighted Quick-Union fixes this by keeping track of each component&#39;s size in a separate array. With this information it then chooses to merge the smaller component under the larger one.</p>

<p>In the example above, by step 2, component 1 is size 2, so component 2, being size 1, is merged under component 1 and not the other way around.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">sz</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span> <span class="n">id</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span> <span class="n">sz</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">sz</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="o">}</span>
  <span class="k">else</span>               <span class="o">{</span> <span class="n">id</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">sz</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">sz</span><span class="o">[</span><span class="n">j</span><span class="o">];</span> <span class="o">}</span>

  <span class="n">count</span><span class="o">--;</span>
<span class="o">}</span>
</code></pre></figure><h4 id="path-compression">
<span class="hash">#</span>
<a href="#path-compression" class="header-link">Path Compression</a>
</h4>
<table>
<thead>
<tr>
<th style="text-align: left">Operation</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Union</td>
<td style="text-align: left"><script type="math/tex">\approx 1</script></td>
</tr>
</tbody>
</table>

<p>A further improvement can be done called <em>path compression</em> in which every site traversed due to a call to <code>find()</code> is directly linked to the component root.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">])</span>
    <span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">]);</span>

  <span class="k">return</span> <span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></figure><h2 id="minimum-cut">
<span class="hash">#</span>
<a href="#minimum-cut" class="header-link">Minimum Cut</a>
</h2>
<p>Adding an edge to a tree creates a cycle and removing an edge from a tree breaks it into two separate subtrees. Knowing this, a <em>cut</em> of a graph is a partition of its vertices into two nonempty disjoint sets, connected by a <em>crossing edge</em>. A graph with <script type="math/tex">n</script> vertices has <script type="math/tex">2^n</script> cuts because each vertex <script type="math/tex">n</script> has two choices as to which set it&#39;s placed in, left or right, i.e. <script type="math/tex">n</script> blanks to be filled with one of two values.</p>

<p>A minimum cut (min-cut) is the cut with the fewest number of crossing edges, with parallel edges allowed, i.e. edges which connect the same vertices. Min-cuts are useful for identifying weaknesses in networks (i.e. hotspots), identifying tightly-knit communities in social networks, and image segmentation.</p>

<p>The minimum cut can (potentially) be obtained through a randomized algorithm known as random contraction. It works by, as long as more than 2 vertices remain in the graph, picking a random remaining edge and merging or &quot;contracting&quot; them into a single vertex, removing any self-loops. When only 2 vertices remain, the cut represented by them is returned.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">while</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">:</span>
  <span class="n">edge</span> <span class="o">=</span> <span class="n">random_edge</span><span class="p">()</span>
  <span class="n">node</span> <span class="o">=</span> <span class="n">merge_vertices</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">from</span><span class="p">,</span> <span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">)</span>
  <span class="n">remove_self_loops</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

<span class="k">return</span> <span class="n">cut</span>
</code></pre></figure>
<p>It&#39;s possible that random contraction will not find the minimum cut. This is mitigated by running it a large number of times, since it is very fast, and returning the smallest cut found. The largest number of min-cuts that a graph with <script type="math/tex">n</script> vertices can have is <script type="math/tex">\binom n 2 = \frac {n (n - 1)} 2</script>.</p>
<h2 id="minimum-spanning-trees">
<span class="hash">#</span>
<a href="#minimum-spanning-trees" class="header-link">Minimum Spanning Trees</a>
</h2>
<p>An <em>edge-weighted graph</em> is a graph where the edges have associated weights or costs. Edge-weighted graphs can be represented with adjacency lists containing edge objects which contain the two vertices, one of which is the index of the adjacency list, as well as the weight for that edge.</p>

<p>A <em>spanning tree</em> is a connected subgraph with no cycles that includes all of the vertices in the graph. A <em>minimum spanning tree</em> (MST) is a spanning tree whose weight---the sum of all of its edges&#39; weights---is no larger than the weight of any other spanning tree for that graph.</p>
<h3 id="prim39s-algorithm">
<span class="hash">#</span>
<a href="#prim39s-algorithm" class="header-link">Prim&#39;s Algorithm</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(E \lg {E})</script></td>
</tr>
<tr>
<td style="text-align: left">Space</td>
<td style="text-align: left"><script type="math/tex">O(E)</script></td>
</tr>
</tbody>
</table>

<p>This method of finding the MST operates by attaching a new edge to a growing tree at each step. Starting with any vertex from the graph to create a single-vertex tree, each time taking the minimum-weight edge that connects a vertex on the tree to a vertex not yet on the tree.</p>

<p>The vertices in the tree being built are represented using a vertex-indexed boolean array where an element is set to true if the vertex is in the tree. The edges in the tree can be represented with a queue that collects edges or a vertex-indexed array of edge objects. Crossing edges are held in a minimum priority queue, making the operation of choosing the edge with the lowest weight particularly straightforward.</p>

<p>The act of adding an edge to the tree corresponds to adding a vertex to the tree. When this occurs, all edges from the newly added vertex to all vertices not in the tree must be added to the crossing edges priority queue. Furthermore, any edges previously in the priority queue that connected the newly added vertex to a vertex already in the tree become <em>ineligible</em>---otherwise they would create a cycle---and should be ignored or removed.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">prim</span><span class="p">(</span><span class="n">EdgeWeightedGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">explored</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">mst</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span> <span class="n">frontier</span><span class="p">;</span>

  <span class="n">visit</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">explored</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frontier</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">frontier</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">frontier</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
    <span class="n">frontier</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">explored</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">)</span> <span class="o">!=</span> <span class="n">explored</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">mst</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
    <span class="n">visit</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">explored</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frontier</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">mst</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">EdgeWeightedGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">explored</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span> <span class="o">*</span><span class="n">frontier</span><span class="p">,</span>
           <span class="n">Node</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">explored</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">Edge</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adjacent</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">explored</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">)</span> <span class="o">==</span> <span class="n">explored</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span>
      <span class="n">frontier</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p>Instead of storing edges in the priority queue, it&#39;s faster to store vertices that have not been explored/spanned yet which are on the other end of edges crossing the cut. If a new vertex is visited which has incident edges which are shorter to reach a vertex <script type="math/tex">w</script> for which an edge-to already existed in the heap, that edge must be replaced with the new shorter edge. This way, the shortest edge is always at the top of the heap.</p>

<p>This is very similar to what is done in Dijkstra&#39;s algorithm.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">visit</span><span class="p">(</span><span class="n">EdgeWeightedGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">explored</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span> <span class="o">*</span><span class="n">frontier</span><span class="p">,</span>
           <span class="n">Node</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">explored</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">Edge</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adjacent</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">explored</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">)</span> <span class="o">==</span> <span class="n">explored</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// check if an edge to this adjacent node already exists</span>
      <span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">([</span><span class="o">&amp;</span><span class="n">e</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">edge</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">edge</span><span class="p">.</span><span class="n">to</span> <span class="o">==</span> <span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">;</span>
      <span class="p">});</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">Edge</span> <span class="n">old</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">-&gt;</span><span class="k">delete</span><span class="p">(</span><span class="n">found</span><span class="p">);</span>

      <span class="c1">// if so, we must ensure that shortest of the two edges is kept</span>
      <span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">shortest</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>

      <span class="n">frontier</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure><h4 id="eager-prim39s-algorithm">
<span class="hash">#</span>
<a href="#eager-prim39s-algorithm" class="header-link">Eager Prim&#39;s Algorithm</a>
</h4>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(E \lg {E})</script></td>
</tr>
<tr>
<td style="text-align: left">Space</td>
<td style="text-align: left"><script type="math/tex">O(V)</script></td>
</tr>
</tbody>
</table>

<p>The above implementation is lazy with respect to ignoring ineligible edges in the priority queue. That approach leaves ineligible edges in the priority queue until they&#39;re dequeued for consideration and discarded if they are ineligible.</p>

<p>By contrast, an <em>eager approach</em> would make sure those edges aren&#39;t present in the priority queue from the beginning. The eager version of Prim&#39;s algorithm uses two vertex-index arrays:</p>

<ul>
<li>an array for the shortest edges to vertices which are reachable from the tree within one edge</li>
<li>an array for the weight of the shortest edge stored in the aforementioned array</li>
</ul>

<p>For each vertex present in the above arrays, the vertex index associated with its weight are stored in a minimum priority queue, such that when the minimum weight is removed the associated index is returned. The implication of maintaining the priority queue this way is that given the next minimum-weight crossing edge returned by the priority queue, its associated vertex is the next one to add to the MST.</p>

<p>An improvement from the lazy implementation is that the eager implementation uses space proportional to <script type="math/tex">V</script> whereas the lazy implementation uses <script type="math/tex">E</script>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">primEager</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">distTo</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
  <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">);</span>

  <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span>
    <span class="n">visit</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">());</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// v-w is ineligible</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
      <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">w</span><span class="o">))</span> <span class="n">pq</span><span class="o">.</span><span class="na">changeKey</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
      <span class="k">else</span>                <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure><h3 id="kruskal39s-algorithm">
<span class="hash">#</span>
<a href="#kruskal39s-algorithm" class="header-link">Kruskal&#39;s Algorithm</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(E \lg {E})</script></td>
</tr>
<tr>
<td style="text-align: left">Space</td>
<td style="text-align: left"><script type="math/tex">O(E)</script></td>
</tr>
</tbody>
</table>

<p>An alternative method for finding the MST is to process the edges in increasing order of their weight values, each time taking an edge for the MST that doesn&#39;t form a cycle, stopping once <script type="math/tex">V-1</script> edges have been aggregated. The edges form a forest of trees, gradually growing into a single tree (the MST). The algorithm can be thought of as starting with a forest of <script type="math/tex">V</script> single-vertex trees, and on each step finding an edge to connect two trees until there is only one left (the MST).</p>

<p>The implementation uses a priority queue of edges based on their weight, a union-find data structure to identify potential cycles, and a queue to collect edges for for the MST.</p>

<p>Despite the simplicity of Kruskal&#39;s algorithm, it is generally slower than Prim&#39;s because it has to check if an edge is already connected using the union-find data structure on each edge that is considered for the MST.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">kruskal</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">mst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
  <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
  <span class="n">uf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UF</span><span class="o">(</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">());</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">edges</span><span class="o">())</span>
    <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>

  <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">mst</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span> <span class="c1">// fetch edge with lowest weight</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">either</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">uf</span><span class="o">.</span><span class="na">connected</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// check if already connected</span>
    <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span> <span class="c1">// if not, merge them in the union-find data structure</span>
    <span class="n">mst</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">e</span><span class="o">);</span> <span class="c1">// add the edge to result</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure><h2 id="shortest-paths">
<span class="hash">#</span>
<a href="#shortest-paths" class="header-link">Shortest Paths</a>
</h2>
<p>The <em>shortest path</em> from vertex <script type="math/tex">s</script> to <script type="math/tex">t</script> in an edge-weighted digraph is a directed path from <script type="math/tex">s</script> to <script type="math/tex">t</script> such that no other such path has a lower weight. A <em>shortest-path tree</em> (SPT) for a source vertex <script type="math/tex">s</script> is a subgraph containing <script type="math/tex">s</script> and all the vertices reachable from <script type="math/tex">s</script> that forms a directed tree rooted at <script type="math/tex">s</script> such that every path is a shortest path in the digraph.</p>

<p><em>Edge relaxation</em> refers to replacing an existing edge that reaches <script type="math/tex">w</script> with a new edge <script type="math/tex">v \rightarrow w</script> if the new edge makes the path from the source vertex to <script type="math/tex">w</script> be of lower cost than it was previously.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
    <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p><em>Vertex relaxation</em> is similar to edge relaxation except that it relaxes all of the edges pointing from a given vertex.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
      <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure><h3 id="dijkstra39s-algorithm">
<span class="hash">#</span>
<a href="#dijkstra39s-algorithm" class="header-link">Dijkstra&#39;s Algorithm</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(E \lg {V})</script></td>
</tr>
<tr>
<td style="text-align: left">Space</td>
<td style="text-align: left"><script type="math/tex">O(V)</script></td>
</tr>
</tbody>
</table>

<p>Dijkstra&#39;s alrogithm is similar to Prim&#39;s algorithm for finding the MST. Dijkstra&#39;s algorithm finds the SPT by finding the lowest-weight non-tree vertex as provided by an index minimum-priority queue and relaxing that vertex.</p>

<p>Dijkstra&#39;s algorithm <em>requires</em> that edges be non-negative.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">Dijkstra</span><span class="p">(</span><span class="n">T</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">distances</span><span class="p">{{</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">}};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">explored</span><span class="p">{</span><span class="n">start</span><span class="p">};</span>
  <span class="n">Heap</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">edge</span> <span class="p">:</span> <span class="o">*</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Incident</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">edges</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
    <span class="n">log</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">(</span><span class="s">&quot;added incident edge to frontier: {}&quot;</span><span class="p">,</span> <span class="n">edge</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">edges</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Edge</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">Top</span><span class="p">();</span>
    <span class="n">edges</span><span class="p">.</span><span class="n">Pop</span><span class="p">();</span>

    <span class="n">explored</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">);</span>

    <span class="c1">// Record the distance to the target from this shortest edge.</span>
    <span class="n">distances</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">edge</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>

    <span class="c1">// After absorbing the new node, there may now be more more suitable edges</span>
    <span class="c1">// that can be used to reach other nodes.</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">neighbor</span> <span class="p">:</span> <span class="o">*</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Incident</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// See if there&#39;s an edge already in the heap which also goes to</span>
      <span class="c1">// neighbor.to</span>
      <span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span>
          <span class="p">[</span><span class="o">&amp;</span><span class="n">neighbor</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">e</span><span class="p">.</span><span class="n">to</span> <span class="o">==</span> <span class="n">neighbor</span><span class="p">.</span><span class="n">to</span><span class="p">;</span> <span class="p">});</span>

      <span class="c1">// There wasn&#39;t any such edge, so this one simply goes into the heap.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">edges</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">neighbor</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// There was an edge in the heap already which also goes to neighbor.to</span>
      <span class="c1">// This means that we must compare them to determine which is the</span>
      <span class="c1">// shortest one, so that the one in the heap is the shortest one.</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Obtain the edge from the heap that also goes to neighbor.to</span>
        <span class="n">Edge</span> <span class="n">old</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="n">found</span><span class="p">);</span>

        <span class="c1">// Remove it from the heap for now.</span>
        <span class="n">edges</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="n">found</span><span class="p">);</span>

        <span class="c1">// Determine if the pre-existing edge is shorter than the new edge</span>
        <span class="c1">// `neighbor` which is incident to the edge we just explored.</span>
        <span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">shortest</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span>
            <span class="n">neighbor</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">distances</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edge</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="n">distances</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">.</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">o</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
            <span class="p">});</span>

        <span class="c1">// Insert the shorter of the two edges back into the heap.</span>
        <span class="n">edges</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">shortest</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">distances</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure><figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">dijkstra</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
    <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
  <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>

  <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">);</span>

  <span class="k">while</span> <span class="o">(!</span><span class="n">pg</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span>
    <span class="n">relax</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">());</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
      <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">w</span><span class="o">))</span> <span class="n">pq</span><span class="o">.</span><span class="na">changeKey</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
      <span class="k">else</span>                <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>To specifically find the shortest path from the source vertex to an arbitrary vertex, simply terminate the search as soon as the target vertex comes off of the priority queue.</p>
<h3 id="topological-sort">
<span class="hash">#</span>
<a href="#topological-sort" class="header-link">Topological Sort</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(E + V)</script></td>
</tr>
<tr>
<td style="text-align: left">Space</td>
<td style="text-align: left"><script type="math/tex">O(V)</script></td>
</tr>
</tbody>
</table>

<p>Shortest paths can be found much more efficiently in acyclic graphs, specifically, the single-source problem can be solved in linear time, negative edge weights are easily handled, and other related problems such as finding the longest paths are solvable. This is possible by relaxing vertices in topological order.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">shortestPathAcyclic</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
    <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
  <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">topologicalOrder</span><span class="o">())</span>
    <span class="n">relax</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></figure>
<p>This approach can be used for finding the longest path between two vertices in a DAG, accomplished by creating a copy of the DAG and negating the weight of every edge.</p>
<h3 id="parallel-job-scheduling">
<span class="hash">#</span>
<a href="#parallel-job-scheduling" class="header-link">Parallel Job Scheduling</a>
</h3>
<p>The <em>critical path method</em> for parallel job scheduling consists of encoding the constraints of the scheduling problem in a DAG. Both a source vertex <script type="math/tex">s</script> and a sink vertex <script type="math/tex">t</script> are created on either ends of the graph. Jobs are encoded in the graph as a pair of nodes connected by an edge whose weight corresponds to that job&#39;s duration. For each precedence constraint <script type="math/tex">v \rightarrow w</script>, add a zero-weight edge from <script type="math/tex">v</script> to <script type="math/tex">w</script>. Finally, add a zero-weight edge from the source to every job&#39;s start vertex and from every job&#39;s end vertex to the sink.</p>

<p>When the scheduling problem is encoded in this manner, it can be solved by scheduling each job at the time corresponding to its longest path from the source vertex.</p>

<p>Relative deadlines can be encoded as a negative weighted edge going from the constrained job (vertex) to the job (vertex) which the deadline is relative to. However, relative deadlines can quickly make solutions infeasible with the aforementioned algorithms (Dijkstra&#39;s and Acyclic Shortest Paths).</p>
<h3 id="bellman-ford-algorithm">
<span class="hash">#</span>
<a href="#bellman-ford-algorithm" class="header-link">Bellman-Ford Algorithm</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(VE)</script></td>
</tr>
<tr>
<td style="text-align: left">Average</td>
<td style="text-align: left"><script type="math/tex">O(E + V)</script></td>
</tr>
<tr>
<td style="text-align: left">Space</td>
<td style="text-align: left"><script type="math/tex">O(V)</script></td>
</tr>
</tbody>
</table>

<p>The problem of finding the shortest paths can be generalized to graphs containing negative cycles. The Bellman-Ford algorithm accomplishes this by adding the source vertex to a queue and entering a loop where a vertex is dequeued and relaxed, and any vertex affected by that relaxation gets enqueued.</p>

<p>A <em>negative cycle</em> is a directed cycle with net negative weight. No shortest path between <script type="math/tex">s</script> and <script type="math/tex">v</script> can consist of a vertex that lies within a negative cycle, or the weight of the path can be made arbitrarily low and a <em>shortest</em> path would &quot;never&quot; be achieved.</p>

<p>To prevent the Bellman-Ford algorithm from looping infinitely due to negative cycles, it has to ensure to terminate after <script type="math/tex">V</script> passes either by keeping track with a counter or by detecting negative cycles within a subgraph.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">bellmanFord</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
  <span class="n">onQ</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">this</span><span class="o">.</span><span class="na">hasNegativeCycle</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
    <span class="n">onQ</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="n">relax</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
      <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>

      <span class="k">if</span> <span class="o">(!</span><span class="n">onQ</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
        <span class="n">onQ</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">cost</span><span class="o">++</span> <span class="o">%</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">findNegativeCycle</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>If the queue is not empty after <script type="math/tex">V</script> passes through each edge then there is a negative cycle. By extension, if a negative cycle is present in a graph, the Bellman-Ford algorithm can end up in an infinite loop, continuously lowering the weight of each affected path.</p>

<p>This is mitigated by checking for negative cycles on every <script type="math/tex">V^{th}</script> call to relax, as on line 26 of the above code listing. On every such interval, a <a href="#directed-cycle-detection">cycle finder</a> is initiated on the sub-graph denoted by the edges so-far considered by Bellman-Ford.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">findNegativeCycle</span><span class="o">()</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">V</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="n">EdgeWeightedDigraph</span> <span class="n">spt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EdgeWeightedDigraph</span><span class="o">(</span><span class="n">V</span><span class="o">);</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">edgeTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
      <span class="n">spt</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">edgeTo</span><span class="o">[</span><span class="n">v</span><span class="o">]);</span>

  <span class="n">EdgeWeightedCycleFinder</span> <span class="n">cf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EdgeWeightedCycleFinder</span><span class="o">(</span><span class="n">spt</span><span class="o">);</span>

  <span class="n">cycle</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="na">cycle</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></figure><h2 id="constraint-satisfaction-problems">
<span class="hash">#</span>
<a href="#constraint-satisfaction-problems" class="header-link">Constraint Satisfaction Problems</a>
</h2>
<p><em>Constraint Satisfaction Problems</em> (CSP) <sup id="fnref6"><a href="#fn6" rel="footnote">6</a></sup> are a special subset of search problems where the state is defined by variables <script type="math/tex">X_i</script> with corresponding values from a domain <script type="math/tex">D</script> (which may depend on <script type="math/tex">i</script>), and the goal test is a set of constraints specifying the allowable combinations of values for the variables. A solution in this case is simply an assignment to all variables which satisfies the constraints.</p>

<p>Example problems that may be modeled as CSPs are map coloring, N-Queens, and Sudoku. <a href="http://en.wikipedia.org/wiki/Map_coloring">Map coloring</a> consists of coloring in different regions in a map such that their bordering regions don&#39;t have the same color. In this case, the variables would be the individual regions and the domain would consist of the possible set of colors, e.g. <script type="math/tex">D = \{\text{red}, \text{green}, \text{blue}\}</script>. The constraints could then be modeled implicitly in the form Region1 ≠ Region2 where Region2 borders Region1, or by explicitly specifying every legitimate configuration.</p>

<p><a href="http://en.wikipedia.org/wiki/Eight_queens_puzzle">N-Queens</a> looks for a possible configuration of an N×N chess board with N queens on it such that there is one queen on each row and none of them threaten each other, i.e. they cannot be on the same row, column, or diagonal. This problem can be modeled so that there is one variable <script type="math/tex">Q_k</script> for each queen taking on a value from the domain <script type="math/tex">D = \{1, 2, \ldots N\}</script> which corresponds to the column the queen is on. The constraints can be modeled implicitly with <script type="math/tex">\forall_{i,j}\ \text {non-threatening} (Q_i, Q_j)</script>.</p>
<h3 id="backtracking-search">
<span class="hash">#</span>
<a href="#backtracking-search" class="header-link">Backtracking Search</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(d^n)</script></td>
</tr>
</tbody>
</table>

<p><aside class="table-caption">where <script type="math/tex">d</script> is domain size</aside></p>

<p>Given a state tree of the constraint satisfaction problem, all of the solutions would be at the bottom, so BFS would experience the worst-case. DFS with its backtracking gets to the bottom quicker, but it must be adapted to the context of CSPs in order to be optimal.</p>

<p>This adaptation is known as <em>backtracking search</em>. Backtracking search only considers one variable at a time and checks the constraints at each step, so that only values that don&#39;t conflict with previous assignments are considered. Backtracking naturally occurs if there are no more successors. A naive implementation of this, that will be optimized later, follows:</p>

<ol>
<li>start with an empty solution</li>
<li>if the solution is complete, return it</li>
<li>select an unassigned variable</li>
<li>try giving it a value from its domain that hasn&#39;t been tried:

<ol>
<li>if there are no more values in the domain, return failure (no successors). This goes back to the previous variable, i.e. backtracking, so that it may try another value for it (and backtracking again if there are no more).</li>
<li>if the value satisfies the constraints, set it</li>
<li>recurse starting at #2 and get its result

<ol>
<li>if the result didn&#39;t fail, return it</li>
<li>otherwise unset the variable and go to #4 to try another value</li>
</ol></li>
</ol></li>
</ol>

<p>This algorithm can be optimized further by ordering the variables in a specific way, filtering out values from domains as other variables are set in order to detect failure earlier, and exploiting the problem&#39;s structure.</p>

<p><em>Forward checking</em> keeps track of domains for unassigned variables and removes from them values which would violate a constraint when added to the existing assignment. This is done whenever a new variable is assigned. For example, in a map coloring problem, if the domain is <script type="math/tex">D = \{\text{red}, \text{green}, \text{blue}\}</script> and Region1 is set to red, then red would be removed from the domain of Region2 which borders it, since setting Region2 to red would violate the constraints.</p>

<p><em>Constraint propagation</em> takes this further by propagating these effects farther, in order to detect potential failures earlier. This is done by having a notion of an <em>arc</em> which leads from other variables on the constraint graph to the variable in question, so that the <em>head</em> of the arc is the variable in question and the tail is the other variable. Then it is said that a given arc <script type="math/tex">X \to Y</script> is <em>consistent</em> iff for <em>every</em> <script type="math/tex">x</script> in the tail&#39;s domain, there is some <script type="math/tex">y</script> in the head&#39;s domain which could be assigned without violating the constraint.</p>

<p><em>Forward checking</em> uses this concept so that, when a new variable is assigned, arc consistency is enforced for each variable by removing values from their domain which would otherwise make them inconsistent. Naturally, when a value is removed from a varible&#39;s domain, all neighbors of that variable (incoming arcs) have to be re-enforced. Arc consistency is run after every assignment in backtracking search.</p>

<p>The algorithm, known as the <a href="http://en.wikipedia.org/wiki/AC-3_algorithm">AC-3 algorithm</a> for enforcing arc consistency follows (specifically for binary CSPs, where there are at most two variables per constraint):</p>

<ol>
<li>create a queue containing all of the arcs in the CSP</li>
<li>while the queue is not empty:

<ol>
<li>retrieve an arc from the queue</li>
<li>for each value <script type="math/tex">x</script> in the tail&#39;s domain:

<ol>
<li>if no value <script type="math/tex">y</script> in the head&#39;s domain satisfies the constraints given <script type="math/tex">x</script>:

<ol>
<li>delete <script type="math/tex">x</script> from the tail&#39;s domain</li>
</ol></li>
</ol></li>
<li>if there were values removed, then add an arc to the queue for each neighbor (i.e. each incoming arc)</li>
</ol></li>
</ol>

<p><em>Variable Ordering</em> refers to optimizing by prioritizing some variables over others. <em>Minimum Remaining Values</em> (MRV) consists of prioritizing variables which have the fewest legal values left in their domain. This is so that, if backtracking becomes necessary, the amount of backtracking will be much less.</p>

<p><em>Value Ordering</em> refers to optimizing by prioritizing certain values in a domain. <em>Least Constraining Value</em> refers to choosing the value which rules out the fewest values in the remaining variables. Knowledge of this may require re-running filtering.</p>
<h3 id="k-consistency">
<span class="hash">#</span>
<a href="#k-consistency" class="header-link">K-Consistency</a>
</h3>
<p>There are increasing degrees of consistency. For example, <em>1-Consistency</em> (Node Consistency) is when each single variable&#39;s (node) domain has a value which meets that node&#39;s unary constraints. <em>2-Consistency</em> (Arc Consistency) is when any consistent assignment for one variable can be extended to the other for each pair of nodes. <em>K-Consistency</em> is the generalized notion where any consistent assignment to <script type="math/tex">k - 1</script> variables can be extended to the <script type="math/tex">k^{th}</script> node for each <script type="math/tex">k</script> nodes, i.e. whatever is done at the tail <script type="math/tex">k - 1</script> variables can be extended to the head.</p>

<p><em>Strong N-Consistency</em> requires that all of the lower orders of K-Consistency are also satisfied, e.g. <script type="math/tex">k - 1</script>, <script type="math/tex">k - 2</script>, etc. This would mean that the CSP could be solved without backtracking, since the constraints could be enforced further and further until the entire constraint graph is enforced. Naturally this is very difficult to accomplish, though a good middle ground is where <script type="math/tex">k = 3</script>, referred to as <em>path consistency</em>.</p>
<h3 id="tree-structured-csps">
<span class="hash">#</span>
<a href="#tree-structured-csps" class="header-link">Tree-Structured CSPs</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(n d^2)</script></td>
</tr>
</tbody>
</table>

<p><aside class="table-caption">where <script type="math/tex">d</script> is domain size</aside></p>

<p>The CSP can be solved <em>much</em> faster if there are no cycles in the constraint graph, specifically linear in the size of the graph and quadratic in the size of the domains.</p>

<p>The tree must first be re-ordered by choosing a root variable so that all parents precede children by replacing the undirected connections with directed connections. Once the constraint graph is structured in this manner, the algorithm is simple:</p>

<ol>
<li>all nodes are traversed one level at a time, starting at the lowest level and going towards but not including the root

<ol>
<li>for a given node, its incoming arc&#39;s consistency is enforced</li>
</ol></li>
<li>set all of the nodes starting at the root. Each node is guaranteed by step #1 to have at least one valid value</li>
</ol>
<h3 id="cutset-conditioning">
<span class="hash">#</span>
<a href="#cutset-conditioning" class="header-link">Cutset Conditioning</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(d^c\ (n - c)\ d^2)</script></td>
</tr>
</tbody>
</table>

<p><aside class="table-caption">where <script type="math/tex">c</script> is cutset size</aside></p>

<p>This optimization only applies to tree-structured CSPs, but not all problems are tree-structured. However, sometimes a constraint graph can easily be converted into a tree-structured CSP by removing a particular set of nodes. This is accomplished by setting the value of the variable and then severing the connection to its neighbors, imposing an additional unary constraint on the neighbors reflecting the value the node was set to, essentially removing the now-invalid values from the domains of the neighbors.</p>

<p><em>Cutset conditioning</em> is an algorithm that accomplishes this transformation, which essentially works by instantiating (in all ways) a set of variables so that the remaining constraint graph is a tree.</p>

<ol>
<li>choose a cutset</li>
<li>instantiate the cutset in all possible ways</li>
<li>compute residual CSP by removing instantiated nodes and replacing their constraints with smaller constraints over remaining neighboring variables (NP-Hard)</li>
<li>solve residual tree-structured CSP</li>
</ol>
<h3 id="iterative-algorithms">
<span class="hash">#</span>
<a href="#iterative-algorithms" class="header-link">Iterative Algorithms</a>
</h3>
<p>Iterative algorithms begin with a constraint graph where every variable is set to a value, whether or not the value satisfies the constraints.</p>

<ol>
<li>while not solved:

<ol>
<li>select a conflicted variable</li>
<li>choose a new value (min-conflicts heuristic)

<ol>
<li>choose value that violates the fewest constraints (i.e. hill climb with h(n) = total number of violated constraints)</li>
</ol></li>
</ol></li>
</ol>

<p>This approach to CSP solving is <em>very</em> performant for any randomly-generated CSP particularly if there are many variables but few constraints or vice versa, but <em>not</em> when both are the case:</p>

<p><script type="math/tex; mode=display"> R = \frac {\text {# of constraints}} {\text {# of variables}} </script></p>
<h1 id="strings">
<span class="hash">#</span>
<a href="#strings" class="header-link">Strings</a>
</h1>
<p>Strings have special properties which necessitate more efficient algorithms for sorting and searching. Other subjects concerning strings include tries, regular expressions, and data compression.</p>
<h2 id="string-rotation">
<span class="hash">#</span>
<a href="#string-rotation" class="header-link">String Rotation</a>
</h2>
<p>A string such as <code>&quot;house&quot;</code> can be rotated as <code>&quot;sehou&quot;</code>. An quick way to determine if a string is a rotation of another is by concatenating the original string to itself and then looking for the rotated string within it. For example, the concatenation would be <code>&quot;househouse&quot;</code>, which clearly contains <code>&quot;sehou&quot;</code> as a substring.</p>
<h2 id="string-sorting">
<span class="hash">#</span>
<a href="#string-sorting" class="header-link">String Sorting</a>
</h2>
<p>Certain properties of strings and alphabets can make for more efficient sorting algorithms for strings.</p>
<h3 id="counting-sort">
<span class="hash">#</span>
<a href="#counting-sort" class="header-link">Counting Sort</a>
</h3>
<p>Counting sort, also known as key-indexed counting, essentially involves computing a histogram of the number of occurrences of each character, then regenerating the array in sorted order using that information.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

<span class="kt">int</span><span class="o">[]</span> <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

<span class="c1">// count occurrences</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
  <span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">key</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]++;</span>

<span class="c1">// compute key ranges</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
  <span class="n">count</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>

<span class="c1">// populate sorted array</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
  <span class="n">aux</span><span class="o">[</span><span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">key</span><span class="o">()]++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

<span class="c1">// copy back to original array</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
  <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</code></pre></figure><h3 id="least-significant-digit-sort">
<span class="hash">#</span>
<a href="#least-significant-digit-sort" class="header-link">Least Significant Digit Sort</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(NW)</script></td>
</tr>
<tr>
<td style="text-align: left">Space</td>
<td style="text-align: left"><script type="math/tex">O(N)</script></td>
</tr>
</tbody>
</table>

<p>Least Significant Digit (LSD) sort works by sorting the strings based on the last character and then repeating this operation up until the first character. This is accomplished by modifying the counting sort algorithm so that it does a pass for every character in the string. This is mainly useful if all strings are the same length <script type="math/tex">W</script> and relatively small alphabet size <script type="math/tex">R</script>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">W</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">256</span><span class="o">;</span>

  <span class="n">String</span><span class="o">[]</span> <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">W</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">d</span><span class="o">--)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

    <span class="c1">// count occurrences</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
      <span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]++;</span>

    <span class="c1">// compute key ranges</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
      <span class="n">count</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>

    <span class="c1">// populate sorted array</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
      <span class="n">aux</span><span class="o">[</span><span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">)]++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

    <span class="c1">// copy back to original array</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
      <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure><h3 id="most-significant-digit-sort">
<span class="hash">#</span>
<a href="#most-significant-digit-sort" class="header-link">Most Significant Digit Sort</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Best</td>
<td style="text-align: left"><script type="math/tex">\Omega (N)</script></td>
</tr>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(Nw)</script></td>
</tr>
<tr>
<td style="text-align: left">Space</td>
<td style="text-align: left"><script type="math/tex">O(N + WR)</script></td>
</tr>
</tbody>
</table>

<p><aside class="table-caption">Table: <script type="math/tex">w:</script> average string length</aside></p>

<p>Most Significant Digit (MSD) sort is similar to LSD except that it operates in left-to-right order instead, meaning it works fine for variable-length strings. This is accomplished by performing counting sort to sort the array of strings based on their first character, then recursively performing the same operation on the sub-array of strings with the same first letter.</p>

<p>Because MSD works left-to-right and strings may be of variable length, the possibility of reaching the end of the string requires special handling. This is solved by observing the fact that a smaller string <script type="math/tex">S_1</script> that is a prefix of larger string <script type="math/tex">S_2</script> should naturally come before it in lexicographically sorted order. For example, <em>sea</em> should come before <em>seashore</em>.</p>

<p>This order is maintained by keeping a separate count of such strings that have had all of their characters sorted. This count is held at <code>count[1]</code>. A string has had all of its characters sorted if the character position currently being sorted is past the length of the string currently being considered. Once the counts are converted to key ranges, such strings will naturally be inserted at the beginning of the sorted sub-array.</p>

<p>On each recursion of the sorting operation, an array for counts is allocated whose size is proportional to the alphabet size, occurrences are counted, transformed to key ranges, and so on. The point is that these operations can come to dominate the sorting operation, which makes having a cutoff for small sub-arrays crucial. After the cutoff, insertion sort takes over, with the slight modification that it only operates on the <script type="math/tex">d^{th}</script> character position onward.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">charAt</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// cut off point for just running insertion sort</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Insertion</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">R</span> <span class="o">+</span> <span class="mi">2</span><span class="o">];</span>

  <span class="c1">// count occurrences</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">count</span><span class="o">[</span><span class="n">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">d</span><span class="o">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">]++;</span>

  <span class="c1">// compute key ranges</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
    <span class="n">count</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>

  <span class="c1">// populate sorted array</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">aux</span><span class="o">[</span><span class="n">count</span><span class="o">[</span><span class="n">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">d</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

  <span class="c1">// copy back to original array</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">lo</span><span class="o">];</span>

  <span class="c1">// recurse for each remaining character value</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
    <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">],</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></figure><h3 id="three-way-string-quicksort">
<span class="hash">#</span>
<a href="#three-way-string-quicksort" class="header-link">Three-way String QuickSort</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align: left">Case</th>
<th style="text-align: left">Growth</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Best</td>
<td style="text-align: left"><script type="math/tex">\Omega (N)</script></td>
</tr>
<tr>
<td style="text-align: left">Worst</td>
<td style="text-align: left"><script type="math/tex">O(Nw \lg {R})</script></td>
</tr>
<tr>
<td style="text-align: left">Space</td>
<td style="text-align: left"><script type="math/tex">O(W + \lg {N})</script></td>
</tr>
</tbody>
</table>

<p><aside class="table-caption">Table: <script type="math/tex">w:</script> average string length</aside></p>

<p>Three-way quicksort can be adapted to work on a per-character basis similar to MSD. The advantages of this are that the algorithm doesn&#39;t use extra space---unlike MSD---and that the number of sub-arrays per recurse is bounded at three.</p>

<p>A direct result of only splitting into three sub-arrays is that more data movements are required to get elements into their correct position compared to MSD. However, three-way quicksort&#39;s three-way splits adapt well to handling equal keys, keys with small arrays, and keys that fall into a small range.</p>

<p>Research has shown that no algorithm can beat 3-way string quicksort by more than a constant factor.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">stringQuickSort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="kt">int</span> <span class="n">lt</span> <span class="o">=</span> <span class="n">lo</span><span class="o">,</span> <span class="n">gt</span> <span class="o">=</span> <span class="n">hi</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">lo</span><span class="o">],</span> <span class="n">d</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">gt</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">d</span><span class="o">);</span>

    <span class="k">if</span>      <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">)</span> <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lt</span><span class="o">++,</span> <span class="n">i</span><span class="o">++);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">v</span><span class="o">)</span> <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">gt</span><span class="o">--);</span>
    <span class="k">else</span>            <span class="n">i</span><span class="o">++;</span>
  <span class="o">}</span>

  <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">lt</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lt</span><span class="o">,</span> <span class="n">gt</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">gt</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></figure><h2 id="tries">
<span class="hash">#</span>
<a href="#tries" class="header-link">Tries</a>
</h2>
<p>Trie structures exploit string properties to provide much faster string search, with hits taking time proportional to the length of the key and where misses require examining only a few characters.</p>

<p><img src="/images/notes/algorithms/tries/trie.png" class="right"></p>

<p>The structure of tries is comprised of a tree where every node has <script type="math/tex">R</script> <em>links</em> where <script type="math/tex">R</script> is the size of the alphabet. Every node also has an associated <em>label</em> corresponding to the character value consumed to reach the node. The root node has no such label as there is no link pointing to it. Every node also also has an associated <em>value</em> corresponding to the value associated with the key denoted by the path ending at the particular node.</p>

<p>A <em>search hit</em> occurs when the trie search arrives at the final node and that node&#39;s value is not empty. A <em>search hit</em> occurs both if the final node&#39;s value is empty or if the search terminated on a null link.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="n">Value</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
<span class="o">}</span>

<span class="n">Node</span> <span class="nf">get</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">key</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></figure>
<p>Trie insertion simply consists of searching for the key and setting the value. If the key does not already exist, then create nodes for every character not yet in the trie.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span> <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="o">}</span>

<span class="n">Node</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
  <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure>
<p>Tries also allow operations for collecting keys with a common prefix. This is accomplished by finding the node at the end of the prefix&#39; path and then recursively performing BFS on every node and enqueueing any node that has a non-empty value.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">keysWithPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
  <span class="n">collect</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">prefix</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">q</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
    <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">c</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></figure>
<p>This can also be modified to allow wildcard pattern matches, for example, keys that match <code>fin.</code> could include <code>fine</code>, <code>find</code>, etc.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">keysWithPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
  <span class="n">collect</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="s">&quot;&quot;</span><span class="o">,</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">q</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span><span class="o">;</span>

  <span class="kt">char</span> <span class="n">next</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">||</span> <span class="n">next</span> <span class="o">==</span> <span class="n">c</span><span class="o">)</span>
      <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">c</span><span class="o">,</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></figure><h3 id="trie-deletion">
<span class="hash">#</span>
<a href="#trie-deletion" class="header-link">Trie Deletion</a>
</h3>
<p>Deletion is a straightforward process in tries, simply involving finding the node and emptying its value. If this operation makes the node&#39;s parent&#39;s children all be null, then the same operation must be run on the parent.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span> <span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="o">}</span>

<span class="n">Node</span> <span class="nf">delete</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
    <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
    <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">key</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
      <span class="k">return</span> <span class="n">x</span><span class="o">;</span>

  <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure><h3 id="ternary-search-trees">
<span class="hash">#</span>
<a href="#ternary-search-trees" class="header-link">Ternary Search Trees</a>
</h3>
<p>Ternary Search Trees (TSTs) seek to avoid the excessive space cost of regular R-way tries demonstrated above. TSTs are structured such that each node has only three links for characters less than, equal to, and greater than the node.</p>

<p>R-way tries can provide the fastest search, finishing the operation with a constant number of compares. However, space usage increases rapidly with larger alphabets TSTs are preferable, sacrificing a constant number of compares for a logarithmic number of compares.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="n">Node</span> <span class="nf">get</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>

  <span class="k">if</span>      <span class="o">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">key</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">mid</span><span class="o">,</span>   <span class="n">key</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
  <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure>
<p>Insertion is similar to insertion with tries except that only one of three links can be taken, instead of <script type="math/tex">R</script> links.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span> <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="o">}</span>

<span class="n">Node</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span> <span class="o">}</span>

  <span class="k">if</span>      <span class="o">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span>  <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
                    <span class="n">x</span><span class="o">.</span><span class="na">mid</span>   <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">mid</span><span class="o">,</span>   <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure><h2 id="substring-search">
<span class="hash">#</span>
<a href="#substring-search" class="header-link">Substring Search</a>
</h2>
<p>Searching for a string within another string is a very common operation that can also benefit from exploiting certain properties of strings.</p>
<h3 id="brute-force-substring-search">
<span class="hash">#</span>
<a href="#brute-force-substring-search" class="header-link">Brute-Force Substring Search</a>
</h3>
<p>The most straightforward approach is a brute-force algorithm where every character in the text is checked to see if the pattern&#39;s first character matches, and if so, checks to see if the second character in the pattern matches, and so on.</p>

<p>If any character in the pattern matches during this check, the pattern iterator is not incremented and instead the text iterator is set back the amount of spaces equal to the pattern iterator, which essentially moves the text iterator one position past the position where the match checking was initiated. The pattern iterator is then reset to zero.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">j</span><span class="o">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span>
      <span class="n">j</span><span class="o">++;</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="n">i</span> <span class="o">-=</span> <span class="n">j</span><span class="o">;</span>
      <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">M</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">M</span><span class="o">;</span>
  <span class="k">else</span>        <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure><h3 id="knuth-morris-pratt">
<span class="hash">#</span>
<a href="#knuth-morris-pratt" class="header-link">Knuth-Morris-Pratt</a>
</h3>
<p>The Knuth-Morris-Pratt (KMP) substring search algorithm considers that it&#39;s probably not necessary to backtrack all the way to the beginning, since the characters along that stretch of the sequence have already been seen. One way to know the correct distance to backtrack is accomplished using a Deterministic Finite-State Automaton (DFA). There are other methods that either <a href="http://algs4.cs.princeton.edu/53substring/KMPplus.java.html">build an NFA</a> or build a <a href="http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/kmpen.htm">partial-match table</a>.</p>
<h4 id="kmp-dfa-composition">
<span class="hash">#</span>
<a href="#kmp-dfa-composition" class="header-link">KMP DFA Composition</a>
</h4>
<p>The DFA is constructed such that every state corresponds to the characters in the patterns, storing their position in the pattern. At each state there exists a transition to the next state corresponding with the character consumed in the pattern. At each state there are also transitions going back to previous states, corresponding to backtracking on a pattern mismatch. Finally, the end state corresponds to the halt state and as such has no transitions leaving it.</p>

<p>The DFA is essentially represented by a table <code>dfa[c][j]</code> such that <code>c</code> corresponds to the character in the text currently being considered and <code>j</code> corresponds to the position of the character currently being considered in the pattern, i.e. the state in the DFA. In effect, <code>dfa[c][j]</code> determines which state to proceed to when at state <code>j</code> considering character <code>c</code>.</p>

<p>The value stored at <code>dfa[c][j]</code> therefore is the identifier of the state that the algorithm should jump to, which could mean either backtracking in the case of a mismatch when <script type="math/tex">C \neq pattern[J]</script> or a progression to the next state when <script type="math/tex">C = pattern[J]</script>.</p>
<h4 id="preventing-backtracking-in-kmp">
<span class="hash">#</span>
<a href="#preventing-backtracking-in-kmp" class="header-link">Preventing Backtracking in KMP</a>
</h4>
<p>In a normal brute-force algorithm when a pattern matching a segment of the text starting at <code>t[i]</code> mismatches at position <code>j</code>, the entire pattern is re-checked starting on the character to the right: <code>t[i + 1]</code>, effectively having to re-check characters <code>t[i + 1]</code> to <code>t[i + j - 1]</code>.</p>

<p>For example, the following mismatches at position 4:</p>

<p>So in a brute-force algorithm the pattern would have to be shifted to the right by one position:</p>

<p>However, this essentially means that the text segment from position 1 to 3 has to be rechecked, which we would prefer to avoid. The important observation to make is that the text had <em>already matched</em> the pattern <em>up to</em> (but not including) position <code>j</code> where the mismatch occurred. That is, the text segment <code>t[i .. i + j - 1]</code> is equal to <code>p[0 .. j - 1]</code> where <code>p</code> is the pattern. Since we would have to shift to the right one character, this means that the text that would have to be rechecked corresponds to <code>p[1 .. j - 1]</code>. Feeding this to the DFA takes us to the state where we can appropriately handle <code>t[i + j]</code>.</p>

<p><em>Based on this observation</em>, we can conclude that at every state we can add transitions for mismatch cases based on the transitions that would be made for the equivalent mismatch that would occur at the state we would arrive at if we had fed the input <code>p[0 .. j - 1]</code> to the DFA. For this reason, a &quot;pointer&quot; to this state is kept at every iteration of the DFA construction, where each iteration is comprised of defining all transitions for a given state.</p>
<h4 id="kmp-dfa-construction">
<span class="hash">#</span>
<a href="#kmp-dfa-construction" class="header-link">KMP DFA Construction</a>
</h4>
<p>Given the important observation above, the construction of the DFA is very straightforward. A pointer to a fall-back state <code>X</code> is maintained to appropriately establish transitions in the event of a mismatch.</p>

<ol>
<li>the first transition is established: <code>dfa[p[0]][0] = 1</code></li>
<li>for each character in the pattern, a state is created

<ol>
<li>for every character in the alphabet, a transition is established based on the transition that would be taken at state <code>X</code>, since these are the mismatch transitions</li>
<li>a match transition is created for the current pattern character</li>
<li>the pointer to the fall-back state is updated to the state arrived at by following the transition corresponding to the current pattern character from the previous fall-back state</li>
</ol></li>
</ol>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">constructDFA</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">dfa</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">dfa</span><span class="o">[</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
      <span class="n">dfa</span><span class="o">[</span><span class="n">c</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">[</span><span class="n">c</span><span class="o">][</span><span class="n">X</span><span class="o">];</span>

    <span class="n">dfa</span><span class="o">[</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">[</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)][</span><span class="n">X</span><span class="o">];</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure><h4 id="kmp-search">
<span class="hash">#</span>
<a href="#kmp-search" class="header-link">KMP Search</a>
</h4>
<p>Now that the DFA is constructed, a string can be searched easily. It simply iterates the text pointer on each iteration, while the pattern&#39;s pointer iterates based on the output from the DFA given the current text character as input. Iteration ends when the full length of either the text or the pattern is exhausted. If the full pattern was consumed then there was a match and the pointer to the start of the match is returned.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">M</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">[</span><span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)][</span><span class="n">j</span><span class="o">];</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">M</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">M</span><span class="o">;</span>
  <span class="k">else</span>        <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure><h3 id="boyer-moore">
<span class="hash">#</span>
<a href="#boyer-moore" class="header-link">Boyer-Moore</a>
</h3>
<p>The Boyer-Moore substring search algorithm works by reading the pattern for comparison in reverse order while skipping through the text accordingly to facilitate this. When a comparison mismatches, the algorithm looks in a skip table to determine how far ahead to jump forward to begin the next match attempt. This behavior is known as the mismatched character heuristic.</p>
<h4 id="bm-skip-table">
<span class="hash">#</span>
<a href="#bm-skip-table" class="header-link">BM Skip Table</a>
</h4>
<p>The mismatched character heuristic makes use of the aforementioned skip table. The table is indexed by a character from the alphabet and gives the index of its rightmost occurrence in the pattern, or -1 if not present. That very value defines how far ahead to skip if that character from the text caused the mismatch.</p>

<p>The table is constructed by first setting all entries to -1, then for every character in the pattern, set that character&#39;s entry to its position in the pattern.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">constructSkipTable</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">R</span><span class="o">];</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
    <span class="n">right</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
    <span class="n">right</span><span class="o">[</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure><h4 id="bm-search">
<span class="hash">#</span>
<a href="#bm-search" class="header-link">BM Search</a>
</h4>
<p>The searching algorithm, as previously stated, iterates the text pointer <code>i</code> from left-to-right and the pattern pointer <code>j</code> right-to-left. If there is a mismatch with character <code>c</code> in the text, then one of three things can occur:</p>

<ol>
<li><strong>if <code>c</code> is not in the pattern</strong>: increment <code>i</code> by <code>j + 1</code> to effectively skip that segment of the text that will not match</li>
<li><strong>if <code>c</code> is in the pattern</strong>: use the <code>right</code> array to line up the pattern with the text such that the right-most occurrence of <code>c</code> in the pattern is lined up with <code>c</code> in the text</li>
<li><strong>if <code>i</code> is not increased due to the above case</strong>: then just increment <code>i</code> instead so that the pattern always slides at least one position to the right</li>
</ol>

<p>The above cases are handled with the simple statement <code>skip = j - right[text.charAt(i + j)]</code>. Case 1 is handled because characters not present in the pattern are stored as -1 in the table, thereby turning the statement into <code>skip = j + 1</code>. Case 2 is handled normally by finding the right-most occurrence&#39; position of <code>c</code> in the table and subtracting that from <code>j</code>. Case 3 is handled by simply checking if <code>skip</code> is less than one and if so setting it to one. If <code>skip</code> was never changed from its initial value of zero, then a match was found.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="kt">int</span> <span class="n">skip</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">M</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">skip</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">!=</span> <span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">right</span><span class="o">[</span><span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">)];</span> <span class="c1">// determine skip distance</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">skip</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="n">skip</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// ensure text traversal</span>
        <span class="k">break</span><span class="o">;</span> <span class="c1">// mismatch; stop trying to match the rest</span>
      <span class="o">}</span>
  
    <span class="c1">// no skip distance set, therefore text matched</span>
    <span class="c1">// i is position where the match began</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">skip</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure><h3 id="rabin-karp">
<span class="hash">#</span>
<a href="#rabin-karp" class="header-link">Rabin-Karp</a>
</h3>
<p>The Rabin-Karp algorithm conceptually works by computing a hash of the pattern and then hashing every equal-lengthed substring in the text to find a match. The key idea is that a string of length <script type="math/tex">M</script> corresponds to an <script type="math/tex">M</script>-digit base-<script type="math/tex">R</script> number. So a proper hash function would convert an <script type="math/tex">M</script>-digit base-<script type="math/tex">R</script> number to an integer value between <script type="math/tex">0</script> and <script type="math/tex">Q - 1</script> where <script type="math/tex">Q</script> is some very large prime number. This is possible with a simple modular hashing scheme, by taking the remainder of dividing the number by <script type="math/tex">Q</script>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">long</span> <span class="nf">hash</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">long</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="o">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">h</span> <span class="o">+</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">%</span> <span class="n">Q</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure>
<p>The problem with using the above approach for the text is that it incurs the cost of multiplication, addition, and remainder calculations for <em>each character</em>. Instead, for an <script type="math/tex">M</script>-character substring of the text where <script type="math/tex">t_i</script> corresponds to <code>text.charAt(i)</code> the hash <script type="math/tex">x_i</script> can be computed as:</p>

<p><script type="math/tex; mode=display"> x_i = t_i R^{M - 1} + t_{i + 1} R^{M - 2} + \ldots + t_{i + M - 1} R^0 </script></p>

<p>From the above formula it&#39;s apparent that the hash is constructed by individual <em>hash components</em> derived from each character in the text. It stands to reason, then, that the hash of the text shifted one character to the right is:</p>

<p><script type="math/tex; mode=display"> x_{i + 1} = \left( x_i - t_i R^{M - 1} \right) R + t_{i + M} </script></p>

<p>That is, the original hash minus the hash component of the first character of the previous text, plus the hash component of the new ending character.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="kt">long</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">longRandomPrime</span><span class="o">();</span>
  <span class="kt">long</span> <span class="n">RM</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">RM</span> <span class="o">=</span> <span class="o">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">RM</span><span class="o">)</span> <span class="o">%</span> <span class="n">Q</span><span class="o">;</span> <span class="c1">// compute R^(M - 1) % Q</span>
  <span class="kt">long</span> <span class="n">patHash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">pattern</span><span class="o">,</span> <span class="n">M</span><span class="o">);</span>

  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="kt">long</span> <span class="n">txtHash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">txt</span><span class="o">,</span> <span class="n">M</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">patHash</span> <span class="o">==</span> <span class="n">txtHash</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// match</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">M</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">txtHash</span> <span class="o">=</span> <span class="o">(</span><span class="n">txtHash</span> <span class="o">+</span> <span class="n">Q</span> <span class="o">-</span> <span class="n">RM</span> <span class="o">*</span> <span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">M</span><span class="o">)</span> <span class="o">%</span> <span class="n">Q</span><span class="o">)</span> <span class="o">%</span> <span class="n">Q</span><span class="o">;</span>
    <span class="n">txtHash</span> <span class="o">=</span> <span class="o">(</span><span class="n">txtHash</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">%</span> <span class="n">Q</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">patHash</span> <span class="o">==</span> <span class="n">txtHash</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
       <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// match</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// return true for Monte Carlo</span>
<span class="c1">// or check pattern vs text[i .. i - M + 1] for Las Vegas</span>
<span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="o">}</span>
</code></pre></figure><h2 id="regular-expressions">
<span class="hash">#</span>
<a href="#regular-expressions" class="header-link">Regular Expressions</a>
</h2>
<p>A Regular Expression pattern can be represented as a Non-Deterministic Finite-State Automaton (NFA) where every character in the pattern corresponds to a state in the NFA, followed by an accept state. Characters from the alphabet have an outgoing edge (match transition) going to the next state (character) in the pattern. Metacharacters such as parentheses, pipes, and asterisks have at least one outgoing edge (<script type="math/tex">\epsilon</script>-transition) going to another state that represents their purpose.</p>

<p>NFA traversal in this context occurs as follows:</p>

<ul>
<li><strong>match transitions</strong>: if current state corresponds to a character in the alphabet and the current character in the text matches it, the automaton can transition from it, i.e. consume the character</li>
<li><strong><script type="math/tex">\epsilon</script>-transitions</strong>: if no match is made in the pattern, any transition can be taken from a metacharacter, so called for effectively matching the empty string <script type="math/tex">\epsilon</script></li>
</ul>

<p>The traversal of the NFA is handled in the following manner:</p>

<ol>
<li><strong>at the start state</strong>: find all set of states reachable via <script type="math/tex">\epsilon</script> transitions</li>
<li>consume pattern character if there&#39;s a match in one of the possible states</li>
<li><strong>from each match state</strong>:

<ol>
<li>add set of states reachable via match transitions</li>
<li>add set of states reachable via <script type="math/tex">\epsilon</script> transitions</li>
</ol></li>
<li>repeat at 2</li>
</ol>

<p>As the text input is fed to the NFA, on input character the following conditions can arise:</p>

<ul>
<li><strong>set of states contains accept state</strong>: the NFA therefore <em>accepts</em> the text, i.e. there was a match</li>
<li><strong>set of states doesn&#39;t contain the accept state</strong>: feed it the next character</li>
<li><strong>the end of the text has been reached</strong>: there was no match</li>
</ul>

<p>The NFA is simply represented by the pattern string and a digraph representing the <script type="math/tex">\epsilon</script>-transitions.</p>
<h3 id="regex-match-checking">
<span class="hash">#</span>
<a href="#regex-match-checking" class="header-link">Regex Match Checking</a>
</h3>
<p>From this information, it is possible to create an algorithm that determines whether a regular expression matches the provided text. Reachability is determined by a Directed DFS implementation <sup id="fnref7"><a href="#fn7" rel="footnote">7</a></sup>. This is straightforward because the DFS would only operate on the digraph, which only represents <script type="math/tex">\epsilon</script>-transitions.</p>

<p>First, the set of states reachable via <script type="math/tex">\epsilon</script>-transitions from the start state are collected:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">boolean</span> <span class="nf">match</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
  <span class="n">DirectedDFS</span> <span class="n">dfs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedDFS</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">.</span><span class="na">marked</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="n">pc</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">matches</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
</code></pre></figure>
<p>As the text is fed into the NFA one character at a time, the set of reachable states is checked for a match with the current character. For each match, its next state is added to the collection of matches representing the set of states reachable from the current state(s).</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java">    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">pc</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="o">&amp;&amp;</span> <span class="n">re</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">||</span> <span class="n">re</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="o">)</span>
        <span class="n">matches</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
</code></pre></figure>
<p>Each of the states reachable via <script type="math/tex">\epsilon</script>-transitions from each of the states collected are added to the collection:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java">    <span class="n">pc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
    <span class="n">dfs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedDFS</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">matches</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">.</span><span class="na">marked</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
        <span class="n">pc</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></figure>
<p>Once the entire text has been consumed, the final iteration of the above loop would leave the final set of reachable states intact. If this set contains the final, <em>accept</em> state, then the NFA accepts the text. Otherwise, there wasn&#39;t a match.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java">  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">pc</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">M</span><span class="o">)</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure><h3 id="regex-nfa-construction">
<span class="hash">#</span>
<a href="#regex-nfa-construction" class="header-link">Regex NFA Construction</a>
</h3>
<p>The construction of the NFA is accomplished similar to how Djikstra&#39;s <a href="http://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard algorithm</a> works for evaluating mathematical expressions in infix notation by using two stacks: one for operators and another for values.</p>

<p>In this context, a stack is maintained for the operators and a digraph the size of the length of the pattern plus one (to account for the accept state) is maintained to represent the NFA&#39;s <script type="math/tex">\epsilon</script>-transitions. <em>Concatenation</em> is already handled implicitly by nature of how the pattern is stored.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="n">Digraph</span> <span class="nf">NFA</span><span class="o">(</span><span class="n">String</span> <span class="n">regex</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ops</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
  <span class="n">re</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="n">G</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Digraph</span><span class="o">(</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// +1 for accept state</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">lp</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</code></pre></figure>
<p>For <em>parentheses</em> and <em>or expressions</em>, the position of the <code>(</code> or <code>|</code> is pushed.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java">    <span class="k">if</span> <span class="o">(</span><span class="n">re</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;(&#39;</span> <span class="o">||</span> <span class="n">re</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;|&#39;</span><span class="o">)</span>
      <span class="n">ops</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</code></pre></figure>
<p>If a <code>)</code> is encountered and it signified the end of an <em>or expression</em>, then the appropriate edges must be created. A regex <code>(A | B)</code> is handled by adding two <script type="math/tex">\epsilon</script>-transitions: one from the <code>(</code> to the <code>B</code> and the other from the <code>|</code> to the <code>)</code>. Push the position of the <code>|</code> (having previously pushed the <code>(</code>).</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java">    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">re</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;)&#39;</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">or</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">re</span><span class="o">[</span><span class="n">or</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;|&#39;</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lp</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="n">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">lp</span><span class="o">,</span> <span class="n">or</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">or</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
      <span class="o">}</span> <span class="k">else</span> <span class="n">lp</span> <span class="o">=</span> <span class="n">or</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></figure>
<p><em>Closures</em> are detected by looking ahead of the current state (if possible). If one is found, then an edge is created to the <code>*</code> and another is created from the <code>*</code> to the current state.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java">    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">re</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">lp</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
      <span class="n">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">lp</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></figure>
<p>Finally, <code>)</code>, <code>*</code>, and <code>)</code> each also have an <script type="math/tex">\epsilon</script>-transition leading to the next state in the pattern.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java">    <span class="k">if</span> <span class="o">(</span><span class="n">re</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;(&#39;</span> <span class="o">||</span> <span class="n">re</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="o">||</span> <span class="n">re</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;)&#39;</span><span class="o">)</span>
      <span class="n">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">G</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></figure><h2 id="data-compression">
<span class="hash">#</span>
<a href="#data-compression" class="header-link">Data Compression</a>
</h2>
<p>Universally good lossless data compression is impossible because, for example, it would mean that data could be compressed over and over again until eventually reaching a compressed length of 0. Instead, lossless compression aims to exploit the known structure of the target data for the best compression ratio.</p>
<h3 id="run-length-encoding">
<span class="hash">#</span>
<a href="#run-length-encoding" class="header-link">Run-Length Encoding</a>
</h3>
<p>Run-Length Encoding (RLE) is a classic method of encryption that replaces repeat occurrences of characters with their repeat count. For example, the following consists of 15 zeros, 7 ones, 7 zeros, and 11 ones:</p>

<p>With RLE, given a count size of 4 bits, it can be replaced with 15 (<code>1111</code>), 7 (<code>0111</code>), 7, and 11 (<code>1011</code>):</p>

<p>In general, each count is encoded in one byte. If a run of repeated characters is greater than the maximum size representable by the count size (i.e. 255), the first 255 is encoded, then a zero-lengthed run of the alternate character, then again the next chunk of the original long repeated character.</p>
<h3 id="huffman-compression">
<span class="hash">#</span>
<a href="#huffman-compression" class="header-link">Huffman Compression</a>
</h3>
<p>Huffman Compression exploits the frequency of individual characters. For example, in <code>ABRACADABRA!</code>, the most frequently occurring character <code>A</code> could be represented by <code>0</code>, <code>B</code> by <code>1</code>, <code>R</code> with <code>00</code>, <code>C</code> with <code>01</code>, <code>D</code> with <code>10</code>, and <code>!</code> with <code>11</code>, resulting in <code>01000010100100011</code>.</p>

<p>The problem with the above representation is that the interpretation of the above encoded data is ambiguous because the characters aren&#39;t delimited and some of the characters&#39; codes are prefixes of others. For example, <code>A</code> is <code>0</code>, <code>B</code> is <code>1</code>, and <code>C</code> is <code>01</code>, so when <code>01</code> is read, it isn&#39;t clear if it is meant to be interpreted as <code>AB</code> or <code>C</code>.</p>

<p>Instead, a property known as <em>prefix-free code</em> is enforced for the encodings, which prevents any code from being a prefix of another. In the above, a possible representation could be <code>A</code> with <code>0</code>, <code>B</code> with <code>1111</code>, <code>C</code> with <code>110</code>, <code>D</code> with <code>100</code>, <code>R</code> with <code>1110</code>, and <code>!</code> with <code>101</code>, yielding the encoding <code>011111110011001000111111100101</code>. While this is a slightly longer representation, it is unambiguous.</p>

<p>Prefix-free codes can be easily represented using a trie where left links are <code>0</code> and right links are <code>1</code>. Leave nodes contain the character represented by the bits of the edges of the path used to reach them. Each node in the trie has an associated frequency (used during construction) and character (for leaves).</p>

<p>Constructing the trie consists of first creating a forest of 1-node trees---all of which are leaves---one for each character in the input, with its frequency variable set to the number of times it appears in the input. The trie is then constructed from the bottom-up by merging the two least frequent characters (nodes) with a new parent node with its frequency set to their sum. This is greatly facilitated by a priority queue:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="n">Node</span> <span class="nf">buildTrie</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">freq</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;();</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">freq</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">freq</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">));</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>
    <span class="n">Node</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>

    <span class="n">Node</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="sc">&#39;\0&#39;</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="na">freq</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="na">freq</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></figure>
<p>Then label left branches with a 0 and right edges with a 1. The path of this bitstring to a leaf represents that leaf&#39;s Huffman code.</p>

<p>The way in which the trie is constructed ensures that the more frequent characters (nodes) are closer to the root, and as a result are encoded with fewer bits.</p>

<p>One thing to recognize is that the trie has to somehow be encoded in the compressed data so that it can then be decompressed. The trie can be encoded in a bitstream by performing pre-order traversal (root → left → right), and at each node:</p>

<ul>
<li>if the node is a leaf, output a <code>1</code> and then the binary representation of the character</li>
<li>otherwise, write a <code>0</code> then recurse on the left node then the right (i.e. pre-order)</li>
</ul>

<p>Reading the trie into an actual trie structure is just as straightforward, where the type of node to create is determined by the leading bit.</p>

<p><em>Decompression</em> consists of simply traversing the trie as each bit is read. If a leaf is encountered, output the character and restart traversal from the root.</p>

<p><em>Compression</em> requires the existence of a code table mapping each character to the appropriate code. This table is derived from the trie by traversing the trie, keeping track of the bitstring along its path, and when a leaf node is encountered, the bitstring is associated with that character in the code table. Compression then simply requires looking up each character from the data in the code table and outputting the appropriate code.</p>

<p>Alternatively, left child edges are 0 and right child edges are 1.</p>
<h3 id="lzw-compression">
<span class="hash">#</span>
<a href="#lzw-compression" class="header-link">LZW Compression</a>
</h3>
<p>LZW <em>compression</em> works by having variable-length code words for fixed-length input patterns. Code words are kept in a trie as with Huffman compression. A code counter is maintained and incremented after each new code is added to the trie. The initial trie is constructed from the alphabet, one node being created from each character with its code stored within. The rest of the trie is constructed as the input is read:</p>

<ol>
<li>the longest prefix of the input present in the trie is found and its value output to the compressed stream</li>
<li>if the length of the prefix is shorter than the remaining input length, a new code is added for the string consisting of the prefix concatenated with the next character in the input stream. This is a simple operation, essentially done by adding a new node with the new code to the node at which the prefix ends</li>
</ol>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">compress</span><span class="o">(</span><span class="n">String</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">TST</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TST</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">st</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;&quot;</span> <span class="o">+</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>

  <span class="kt">int</span> <span class="n">code</span> <span class="o">=</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">longestPrefixOf</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="n">BinaryStdOut</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">),</span> <span class="n">W</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">input</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">&lt;</span> <span class="n">L</span><span class="o">)</span>
      <span class="n">st</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">code</span><span class="o">++);</span>

    <span class="n">input</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="n">BinaryStdOut</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">R</span><span class="o">,</span> <span class="n">W</span><span class="o">);</span>
  <span class="n">BinaryStdOut</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></figure>
<p><em>Decompression</em> depends on a table indexed by codes and valued by strings (prefixes), this is constructed from the alphabet. The code of the first character in the input stream is read and its associated string is retrieved from the table. Decompression continues until the EOF character is encountered, on each iteration doing the following:</p>

<ol>
<li>the string associated with the code is output</li>
<li>another code is read, break if EOF</li>
<li>the string associated with the code is retrieved</li>
<li>if the current code counter is equal to the next (lookahead) code---therefore making it impossible to read what the next code&#39;s first character is, since it&#39;s in the process of being constructed---then first character of the string currently being constructed is appended to its end, following basic logic</li>
<li>a new code is added to the table at an incremented code corresponding to the previously read string concatenated with the first character of the current string&#39;s first character</li>
</ol>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">decompress</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">String</span><span class="o">[]</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">L</span><span class="o">];</span>
  <span class="kt">int</span> <span class="n">codeword</span> <span class="o">=</span> <span class="n">BinaryStdIn</span><span class="o">.</span><span class="na">readInt</span><span class="o">(</span><span class="n">W</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">st</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> <span class="o">+</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span><span class="n">i</span><span class="o">;</span>

  <span class="n">st</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="s">&quot; &quot;</span><span class="o">;</span>

  <span class="n">String</span> <span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="o">[</span><span class="n">codeword</span><span class="o">];</span>

  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">BinaryStdOut</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
    <span class="n">codeword</span> <span class="o">=</span> <span class="n">BinaryStdIn</span><span class="o">.</span><span class="na">readInt</span><span class="o">(</span><span class="n">W</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">codeword</span> <span class="o">==</span> <span class="n">R</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

    <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">st</span><span class="o">[</span><span class="n">codeword</span><span class="o">];</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">codeword</span><span class="o">)</span>
      <span class="n">s</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">val</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">L</span><span class="o">)</span>
      <span class="n">st</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">BinaryStdOut</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></figure><h1 id="greedy-algorithms">
<span class="hash">#</span>
<a href="#greedy-algorithms" class="header-link">Greedy Algorithms</a>
</h1>
<p>Greedy algorithms are ones which make &quot;myopic&quot; decisions, i.e. they seemed like good decisions at the time and there&#39;s a hope that everything works out in the end.</p>

<p>Dijkstra&#39;s shortest-path algorithm is greedy for example because it processes each destination once, it doesn&#39;t backtrack to find a different path.</p>
<h1 id="b-trees">
<span class="hash">#</span>
<a href="#b-trees" class="header-link">B-Trees</a>
</h1>
<p>A B-Trees of order <script type="math/tex">M</script> is a tree consisting of internal and external <script type="math/tex">k</script>-nodes each consisting of <script type="math/tex">k</script> keys where <script type="math/tex">2 \leq k \leq M - 1</script> at the root and <script type="math/tex">M/2 \leq k \leq M - 1</script> at every other node. <em>Internal nodes</em> contain copies of keys, where every key is greater than or equal to its parent node&#39;s associated key, but not greater than the parent node&#39;s next largest key. <em>External nodes</em> are the leaves of the tree that associate keys with data. A <em>sentinel key</em> is created to be less than all other keys and is the first key in the root node.</p>
<h2 id="b-tree-insertion">
<span class="hash">#</span>
<a href="#b-tree-insertion" class="header-link">B-Tree Insertion</a>
</h2>
<p>To insert a key, the tree is recursively descended by following the link pertaining to the interval upon which the inserted key falls until an external node is reached. The tree is balanced on the way up the tree after the recursive call. If a node is full it is split into two <script type="math/tex">M/2</script>-nodes and attached to a parent 2-node (if at the root) or a <script type="math/tex">(k + 1)</script>-node where <script type="math/tex">k</script> was the original size of the full node&#39;s parent. Whenever a node is split, the smallest key in the new node (or both smallest keys from both nodes if at the root) is inserted into the parent node.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">add</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">isFull</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">Page</span> <span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="n">Page</span> <span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">split</span><span class="o">();</span>

    <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Page</span><span class="o">();</span>
    <span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
    <span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Page</span> <span class="n">h</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">isExternal</span><span class="o">())</span> <span class="o">{</span> <span class="n">h</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">);</span> <span class="k">return</span><span class="o">;</span> <span class="o">}</span>

  <span class="n">Page</span> <span class="n">next</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">next</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
  <span class="n">add</span><span class="o">(</span><span class="n">next</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">isFull</span><span class="o">())</span>
    <span class="n">h</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">split</span><span class="o">());</span>

  <span class="n">next</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></figure><h1 id="suffix-arrays">
<span class="hash">#</span>
<a href="#suffix-arrays" class="header-link">Suffix Arrays</a>
</h1>
<p>Suffix arrays are arrays of suffixes of a given text which help with procedures such as finding the longest repeated substring in some text.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">class</span> <span class="nc">SuffixArray</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span><span class="o">[]</span> <span class="n">suffixes</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">N</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">SuffixArray</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="n">suffixes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">suffixes</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="n">Array</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">suffixes</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lcp</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="n">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lcp</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">lcp</span><span class="o">(</span><span class="n">suffixes</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">suffixes</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]);</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rank</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* binary search */</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">select</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">suffixes</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">index</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">N</span> <span class="o">-</span> <span class="n">suffixes</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>Using this suffix array class, the longest repeated substring can be found efficiently:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">String</span> <span class="n">text</span> <span class="o">=</span> <span class="n">StdIn</span><span class="o">.</span><span class="na">readAll</span><span class="o">();</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="n">SuffixArray</span> <span class="n">sa</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SuffixArray</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
  <span class="n">String</span> <span class="n">lrs</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">sa</span><span class="o">.</span><span class="na">lcp</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">lrs</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
      <span class="n">lrs</span> <span class="o">=</span> <span class="n">sa</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="n">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lrs</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></figure><h1 id="network-flow">
<span class="hash">#</span>
<a href="#network-flow" class="header-link">Network-Flow</a>
</h1>
<p>The Network-Flow problem concerns itself with finding the settings in a network that maximize the flow from source to sink. At each junction in the network there are switches that control the flow&#39;s distribution between it&#39;s outgoing edges. The problem can be modeled as an edge-weighted digraph with a single source and sink pair, where the weights correspond to the capacity of the edge.</p>

<p>An <em>st-flow</em> is a set of edge flows for the network that represent the distribution of flow values for each edge. An <em>st-flow value</em> is the sink&#39;s inflow. The network-flow problem can be described as finding an st-flow such that no other st-flow has a larger st-flow value. Such an st-flow can be referred to as a <em>maxflow</em>.</p>
<h2 id="ford-fulkerson">
<span class="hash">#</span>
<a href="#ford-fulkerson" class="header-link">Ford-Fulkerson</a>
</h2>
<p>The Ford-Fulkerson algorithm, also known as the <em>augmenting-path algorithm</em>, works by increasing flows incrementally along paths from the source to the sink. It works by considering that each edge consists of a <em>forward edge</em> and a <em>backward edge</em>.</p>

<p>A path is found in the network in which there are no full forward edges and no empty backward edges. The flow of the network can then be increased by an amount <script type="math/tex">X</script>, by increasing flow in forward edges by <script type="math/tex">X</script> and decreasing flow in backward edges by <script type="math/tex">X</script> in this path. The value of <script type="math/tex">X</script> is the minimum of the unused capacities in forward edges and backward edges in the path. This path that can be used to increase flow in the network is known as an <em>augmenting path</em>.</p>

<p>Following from this, the maxflow can be found by starting with zero flow everywhere and gradually increase the flow along any augmenting path from source to sink until there are no more augmenting paths.</p>

<p>A <em>residual network</em> has the same vertices as the original. For every edge in the original network: if its flow is positive, an edge should be created in the residual with an opposite direction and capacity equal to the flow. Also, if its flow is less than its capacity, an edge should be added in the same direction as the original edge with capacity equal to the difference between its capacity and flow.</p>

<p>This means that if, in the original, an edge&#39;s flow is zero then there&#39;ll only be one edge (in the same direction) and if instead the flow is full there&#39;ll only be one edge (in the opposite direction).</p>

<p>The residual network is useful because any path in it from source to sink corresponds directly to an augmenting path in the original network. As an augmenting path&#39;s flow is incremented, when an edge in the path becomes full or empty, it corresponds to changing direction or disappearing in the residual network.</p>

<p>The <em>shortest-augmenting-path</em> method finds the maxflow by finding an augmenting path using BFS and incrementing it.</p>
<h1 id="geometric-algorithms">
<span class="hash">#</span>
<a href="#geometric-algorithms" class="header-link">Geometric Algorithms</a>
</h1><h2 id="augmented-bst-as-interval-tree">
<span class="hash">#</span>
<a href="#augmented-bst-as-interval-tree" class="header-link">Augmented BST as Interval Tree</a>
</h2>
<p>An interval search tree stores ranges and provides operations for searching for overlaps of a given range within the tree. A binary search tree can be augmented into an interval search tree. The lower bound of a range is used as the node key. Each node also stores the maximum upper bound of its children, similar to the rank.</p>

<p>For searching, the input interval is checked to see if it overlaps with the current node. If not, and the left node is null, search proceeds on the right child. If the left node&#39;s max upper bound is less than the input interval&#39;s lower bound, search proceeds on the right node. Otherwise search proceeds on the left node.</p>

<ol>
<li>if input interval <script type="math/tex">[l, r]</script> overlaps current node, return</li>
<li>if left node is <code>null</code> or left&#39;s max upper &lt; <script type="math/tex">l</script>: go right<br>
else: go left</li>
</ol>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="n">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>

<span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">interval</span><span class="o">.</span><span class="na">overlaps</span><span class="o">(</span><span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">))</span> <span class="k">return</span> <span class="n">current</span><span class="o">.</span><span class="na">interval</span><span class="o">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>         <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">max</span> <span class="o">&lt;</span> <span class="n">lo</span><span class="o">)</span>        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
  <span class="k">else</span>                                   <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
<span class="o">}</span>

<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</code></pre></figure><h2 id="interval-trees">
<span class="hash">#</span>
<a href="#interval-trees" class="header-link">Interval Trees</a>
</h2>
<p>Interval trees are useful for efficiently finding all intervals that overlap with any given interval or point.</p>

<p>To construct the tree, the median of the entire range of all of the set of ranges is found. Those ranges in the set that are intersected by the median are stored in the current node. Ranges that fall completely to the left of the median are stored in the left child node, and vice versa with the right node.</p>

<p>At any given node representing the set of ranges intersected by the median at that node, two sorted lists are maintained: one containing all beginning points and the other containing all end points.</p>
<h2 id="intersection-queries">
<span class="hash">#</span>
<a href="#intersection-queries" class="header-link">Intersection Queries</a>
</h2>
<p>The general operation for queries is to test the set of ranges in a node and then test those in the appropriate child node if the query isn&#39;t equal to the median.</p>

<p>Given a <em>point</em> query, the current node is compared with the median. If it&#39;s equal, then every range in that node matches and the search is complete. If the query is less than the median, then the list of beginning points is searched for those beginning points that start before the query point, all of which are matches. Then the search continues into the left child.</p>

<p>Given an <em>interval query</em>, the set of beginning and end points are searched to see if they fall within the query interval. These ranges are matches, and they have potential for duplicates if the matched interval begins and ends within the query interval. Finally, to match for ranges which possibly contain the query interval, a point is chosen in the query interval, perhaps the begin or end point, and that point is used as a point query as in the aforementioned point query algorithm.</p>
<h2 id="one-dimensional-range-count">
<span class="hash">#</span>
<a href="#one-dimensional-range-count" class="header-link">One-Dimensional Range Count</a>
</h2>
<p>This can be modeled as a BST where each node maintains a <em>rank</em>: the count of children that are strictly less than the node. It&#39;s possible to determine how many keys fall within a given range by subtracting the rank of the node containing the lower bound from the rank of the node containing the higher bound, adding one if the current node is the higher bound.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span><span class="n">Key</span> <span class="n">lo</span><span class="o">,</span> <span class="n">Key</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">contains</span><span class="o">(</span><span class="n">hi</span><span class="o">))</span> <span class="k">return</span> <span class="n">rank</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span> <span class="o">-</span> <span class="n">rank</span><span class="o">(</span><span class="n">lo</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
  <span class="k">else</span>              <span class="k">return</span> <span class="n">rank</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span> <span class="o">-</span> <span class="n">rank</span><span class="o">(</span><span class="n">lo</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></figure><h2 id="line-segment-intersection">
<span class="hash">#</span>
<a href="#line-segment-intersection" class="header-link">Line Segment Intersection</a>
</h2>
<p>Given a collection of line segments, it&#39;s possible to determine which pairs of line segments intersect by using a <em>sweep-line</em> algorithm. The coordinates could be sorted by x-coordinate or added to a priority queue. For each distinct x-coordinate encountered, its accompanying y-coordinate is added to a BST. If the same x-coordinate is encountered again, its accompanying y-coordinate is removed from the BST. If a vertical segment is encountered, a range search is performed on the BST to see if any y-coordinates fall within the vertical segment&#39;s y-coordinate endpoints.</p>
<h2 id="rectangle-intersection">
<span class="hash">#</span>
<a href="#rectangle-intersection" class="header-link">Rectangle Intersection</a>
</h2>
<p>Checking for rectangle intersection is similar to line segment intersection. The left edge of a rectangle prompts the vertical range of the rectangle is checked for overlaps in an interval search tree, and added if none are detected. The rectangle&#39;s vertical range is removed from the interval search tree when the right edge of the rectangle is encountered.</p>
<h1 id="dynamic-programming">
<span class="hash">#</span>
<a href="#dynamic-programming" class="header-link">Dynamic Programming</a>
</h1>
<p>It&#39;s important to reason about the structure of an optimal solution, in terms of optimal solutions of smaller subproblems. In other words, imagine that optimal solutions to two subproblems were already provided.</p>

<p>First it&#39;s important to identify a suitable <em>small</em> collection of subproblems.</p>

<p>Second it&#39;s important to quickly and correctly solve &quot;larger&quot; subproblems given solutions to &quot;smaller&quot; subproblems.</p>

<p>Third it&#39;s important to compute the final solution after solving all subproblems.</p>
<h2 id="maximum-weight-independent-set">
<span class="hash">#</span>
<a href="#maximum-weight-independent-set" class="header-link">Maximum-Weight Independent Set</a>
</h2>
<p>Example problem: given a path graph <script type="math/tex">G = (V, E)</script> with non-negative weights on the vertices, produce a subset of the graph&#39;s vertices so that <strong>no two vertices are adjacent</strong> and that the subset has the <strong>maximum total weight</strong> of every such subset.</p>

<p><img src="http://i.imgur.com/kQkyCTD.png" class="center" /></p>

<p>A brute-force search would be exponential in the number of vertices.</p>

<p>A greedy approach would be to iteratively choose the maximum-weight vertex that is not adjacent to any previously chosen vertex. However, this wouldn&#39;t give the correct answer (consider above it would choose the first and third vertices, although the second and fourth is the answer).</p>

<p>A divide-and-conquer approach would be problematic when attempting to combine the results of subproblems.</p>

<p>Let <script type="math/tex">S \subseteq V</script> be a max-weight independent set (IS). Let <script type="math/tex">v_n</script> be the last/right-most/final vertex of the path. Either <script type="math/tex">v_n</script> is in <script type="math/tex">S</script> or it isn&#39;t.</p>

<p>Suppose <script type="math/tex">v_n \not\in S</script> and let <script type="math/tex">G'</script> be the graph with <script type="math/tex">v_n</script> deleted off of the end (since <script type="math/tex">v_n</script> is the last vertex on the path). Then <script type="math/tex">S</script> is also an independent set of <script type="math/tex">G'</script>, specifically a max-weight independent set.</p>

<p>Suppose <script type="math/tex">v_n \in S</script>, then the penultimate vertex <script type="math/tex">v_{n - 1} \not\in S</script>, since it is adjacent to <script type="math/tex">v_n</script>. Then let <script type="math/tex">G''</script> be the graph with <script type="math/tex">v_{n - 1}</script> and <script type="math/tex">v_n</script> deleted.</p>

<p><img src="http://i.imgur.com/J0oxqD1.png" class="center" /></p>

<p>Unlike the earlier claim that if <script type="math/tex">v_n \not\in S</script> then <script type="math/tex">S</script> is also an independent set of <script type="math/tex">G'</script>, it&#39;s not true that if <script type="math/tex">v_{n - 1} \not\in S</script> then <script type="math/tex">S</script> is also an independent set of <script type="math/tex">G''</script>, because the <script type="math/tex">v_n \in S</script> but <script type="math/tex">v_n \not\in G''</script>.</p>

<p>However <script type="math/tex">S - \{v_n\}</script> is an independent set of <script type="math/tex">G''</script>, specifically a max-weight independent set.</p>

<p>This means that if we knew whether or not <script type="math/tex">v_n</script> was in the max-weight independent set, we could recursively compute the max-weight independent set of <script type="math/tex">G'</script> or <script type="math/tex">G''</script>. We can try both possibilities and return the better solution.</p>

<p>Essentially, recursively compute <script type="math/tex">S_1</script> as the max-weight independent set of <script type="math/tex">G'</script> as well as <script type="math/tex">S_2</script> as the max-weight independent set of <script type="math/tex">G''</script>. Then return max of <script type="math/tex">S_1</script> or <script type="math/tex">S_2 \cup v_n</script>.</p>

<p>However, this would take exponential time because very little work is done before recursing.</p>

<p>A realization is that there is only a linear number of distinct subproblems, one for each prefix of the graph since the recursion only plucks vertices off from the right. This causes repeated work for the same prefixes.</p>

<p>This can be mitigated by caching the solution to the subproblem in a global table for subsequent <script type="math/tex">O(1)</script>-time lookup, i.e. <em>memoization</em>, where there is an array of solutions to subproblems where index <script type="math/tex">i</script> holds the solution to the <script type="math/tex">i^\text{th}</script> subproblem.</p>

<p>This is more straightforward if it&#39;s reformulated as a bottom-up iterative algorithm.</p>

<p>Let <script type="math/tex">G_i</script> be the first <script type="math/tex">i</script> vertices of <script type="math/tex">G</script>. Then populate an array <code>A</code> from left-to-right with <code>A[i]</code> set to the value of the max-weight independent set of <script type="math/tex">G_i</script>. Naturally <code>A[0]</code> is an empty set so it&#39;s set to weight 0, and <code>A[1]</code> is a single-vertex graph so it&#39;s set to the weight of the first vertex.</p>

<p>After adding another vertex, determine the max-weight independent set for this new <script type="math/tex">G</script>. This will be the maximum of either <script type="math/tex">A[i - 1]</script> or <script type="math/tex">A[i - 1] + w_i</script>. If it&#39;s <script type="math/tex">A[i - 1]</script> then it means that the max-weight independent set is of <script type="math/tex">G_{i - 1}</script>. If it&#39;s <script type="math/tex">A[i - 2] + w_i</script> then it means that the max-weight independent set is of <script type="math/tex">G_{i - 2}</script>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">for</span> <span class="n">i</span> <span class="n">from</span> <span class="mi">2</span> <span class="n">to</span> <span class="n">and</span> <span class="n">including</span> <span class="nl">n</span><span class="p">:</span>
  <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">w_i</span><span class="p">)</span>
</code></pre></figure>
<p>One problem is that this only produces a total weight, but not the actual set of vertices. This can be reconstructed from the completed array by walking backwards from right-to-left starting at the last element, since that was the answer/result.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">let</span> <span class="n">S</span> <span class="o">=</span> <span class="err">∅</span>

<span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">:</span>
  <span class="c1">// case 1 wins: skip v_i and go back to the chosen vertex v_{i - 1}</span>
  <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nl">w_i</span><span class="p">:</span>
    <span class="o">--</span><span class="n">i</span>

  <span class="c1">// case 2 wins: v_i was indeed used, add it to S and go back to v_{i - 2}</span>
  <span class="k">else</span><span class="o">:</span>
    <span class="n">S</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v_i</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">-=</span> <span class="mi">2</span>

<span class="k">return</span> <span class="n">S</span>
</code></pre></figure><h2 id="knapsack-problem">
<span class="hash">#</span>
<a href="#knapsack-problem" class="header-link">Knapsack Problem</a>
</h2>
<p>There are <script type="math/tex">n</script> items and each has a value:</p>

<ul>
<li>value <script type="math/tex">v_i</script> (non-negative)</li>
<li>size <script type="math/tex">w_i</script> (non-negative and integral)</li>
<li>capacity <script type="math/tex">W</script> (non-negative and integral)</li>
</ul>

<p>The output should be a subset <script type="math/tex">S \subset \{1, 2, 3, \ldots, n\}</script> that maximizes the sum of the values that are selected <script type="math/tex">\sum_{i \in S} v_i</script> while preventing the sum of the weights from exceeding the capacity <script type="math/tex">\sum_{i \in S} w_i \le W</script>.</p>

<p>This is useful for whenever we have a budget of a resource that we can use and we want to use it in the smartest way possible.</p>

<p>First we&#39;ll formulate a recurrence---an optimal solution as a function of solutions to smaller subproblems---based on the structure of an optimal solution.</p>

<p>Let <script type="math/tex">S</script> be the max-value solution to an instance of knapsack, and let <script type="math/tex">n</script> be the final selected item.</p>

<p>Suppose <script type="math/tex">n \not\in S</script>, then <script type="math/tex">S</script> must be optimal with the first <script type="math/tex">(n - 1)</script> items.</p>

<p>Suppose <script type="math/tex">n \in S</script>, then <script type="math/tex">S - \{n\}</script> must be an optimal solution with respect to the first <script type="math/tex">(n - 1)</script> items with capacity <script type="math/tex">W - w_n</script>.</p>

<p>The solution <script type="math/tex">V_{i,x}</script> is the value of the best solution that:</p>

<ol>
<li>uses only the first <script type="math/tex">i</script> items</li>
<li>has total capacity <script type="math/tex">\le x</script></li>
</ol>

<p>Therefore:</p>

<p><script type="math/tex; mode=display">
V_{i,x} = \max
\begin{cases}
V_{(i - 1), x} & \text {case 1, item i excluded} \\
v_i + V_{(i - 1), x - w_i} & \text {case 2, item i included}
\end{cases}
</script></p>

<p>However, an edge case exists in that if <script type="math/tex">w_i > x</script>, then we must use case 1.</p>

<p>Now given the above recurrence, the <script type="math/tex">O(nW)</script> algorithm can be implemented.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="n">D</span><span class="o">-</span><span class="n">array</span><span class="p">.</span> <span class="n">first</span> <span class="n">dimension</span> <span class="n">is</span> <span class="n">item</span> <span class="n">count</span><span class="p">,</span> <span class="n">second</span> <span class="n">is</span> <span class="n">capacity</span>

<span class="c1">// if no items are used selected, the weight is 0 regardless</span>
<span class="c1">// of total capacity</span>
<span class="n">Set</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">W</span>

<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...,</span> <span class="nl">n</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...,</span> <span class="nl">w</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">w_i</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span>
      <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
    <span class="k">else</span><span class="o">:</span>
      <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">w_i</span><span class="p">]</span> <span class="o">+</span> <span class="n">v_i</span><span class="p">)</span>

<span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">W</span><span class="p">]</span>
</code></pre></figure><h1 id="np-complete-problems">
<span class="hash">#</span>
<a href="#np-complete-problems" class="header-link">NP-Complete Problems</a>
</h1>
<ul>
<li><strong>clique problem</strong>: find complete subgraphs, or <em>cliques</em>, in a graph</li>
<li><strong>vertex cover</strong>: find a set of vertices in a graph such that each edge in the graph is incident to at least one vertex in the set</li>
<li><strong>travelling salesman problem</strong>: find the shortest possible path cycle that visits every vertex in a graph</li>
<li><strong>graph coloring</strong>: color every vertex--edge in a graph such that no two adjacent vertices--edges have the same color</li>
<li><strong>knapsack</strong>: given a set of items with different values and a container of a maximum capacity, find the combination of items that fits in the container and has the largest total value.</li>
</ul>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p><a href="http://courses.csail.mit.edu/6.851/spring12/">MIT CSAIL 6.861: Advanced Data Structures</a>&nbsp;<a href="#fnref1" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

<li id="fn2">
<p><a href="http://www.cs.umd.edu/class/spring2008/cmsc420/">University of Maryland, CMSC 420</a>&nbsp;<a href="#fnref2" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

<li id="fn3">
<p><a href="http://wwwisg.cs.uni-magdeburg.de/ag/lehre/WS1011/GDS/">Universität Magdeburg, Geometric Datastructures</a>&nbsp;<a href="#fnref3" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

<li id="fn4">
<p>Skiena p. 109, § 4.3&nbsp;<a href="#fnref4" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

<li id="fn5">
<p>The <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal">Wikipedia implementation&#39;s</a> 6 cases were condensed to 4 as was done in the Linux kernel <a href="https://github.com/torvalds/linux/blob/master/lib/rbtree.c">Red-Black tree implementation</a>. Cases 1 and 2 were merged since case 1 is simply a check to see if the node is the root. Cases 3 and 4 were merged because they handle the same scenario, with case 4 simply being a handler for a special case of 3.&nbsp;<a href="#fnref5" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

<li id="fn6">
<p>See <a href="https://courses.edx.org/courses/BerkeleyX/CS188.1x/2012_Fall/courseware/Week_3/Lecture_4_CSPs/">Week 3</a> of CS 188.1x for more information.&nbsp;<a href="#fnref6" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

<li id="fn7">
<p>Sedgewick p. 570, algorithm 4.4&nbsp;<a href="#fnref7" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

</ol>
</div>
</div>
  <div class="meta">
    <div class="meta-component"><i class="fa fa-calendar fa-fw"></i> July 15, 2013</div>
    <div class="meta-component"><i class="fa fa-code-fork fa-fw"></i> <a href="https://github.com/blaenk/site/commits/master/input/notes/algorithms.markdown">History</a><span class="hash">, <a href="https://github.com/blaenk/site/commit/d43064c" title="polishing up and adding new sections
">d43064c</a></span></div>
    <div class="meta-component"><i class="fa fa-pencil fa-fw"></i> <a href="..">Notes</a></div>
  </div>
</article>



    
    <footer id="footer">
  <div id="social">
    <a href="https://github.com/blaenk" title="github"><i class="fa fa-github-alt"></i></a>
    &middot;
    <a href="http://stackoverflow.com/users/101090/jorge-israel-pena" title="stackoverflow"><i class="fa fa-stack-overflow"></i></a>
    &middot;
    <a href="https://twitter.com/blaenk" title="twitter"><i class="fa fa-twitter"></i></a>
    &middot;
    <a href="mailto:jorge.israel.p@gmail.com" title="email"><i class="fa fa-envelope"></i></a>
    &middot;
    <a href="/rss.xml" title="feed"><i class="fa fa-rss-square"></i></a>
  </div>
  <!-- <div id="credit">
    Designed by <a href="http://www.blaenkdenum.com">Jorge Israel Peña</a>
  </div> -->
</footer>


<!-- this should instead be something like connectWS("{{{path}}}") -->


<script type="text/javascript">
  jQuery(function (){
    var ws = new WebSocket('ws://' + window.location.hostname + ':9160/notes/algorithms.markdown');

    ws.onmessage = function (e) {
      var content = jQuery('article .entry-content');
      content.html(e.data);

      window.refresh();

      MathJax.Hub.Queue(["Typeset", MathJax.Hub, jQuery('article .entry-content')[0]]);

      if (window.jumpDown)
        window.scrollDown();
    };
  });
</script>




<!-- google analytics -->
<script async="true" type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37339861-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

<!--MathJax CDN-->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    messageStyle: "none"
  });

  MathJax.Hub.Register.MessageHook('End Process', function() {
    jQuery('#MathJax_Font_Test').empty();
    jQuery('.MathJax_Display').parent().addClass('mathjax');
  });
</script>

  </div>
</body>
</html>
