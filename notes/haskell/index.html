<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Haskell - Blaenk Denum</title>
  <meta name="author" content="Jorge Israel Peña">
  <meta name="description" content="AKA Blaenk Denum">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="/favicon.png" rel="shortcut icon">
  <link href='http://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Merriweather:900italic,900,700italic,400italic,700,400,300italic,300' rel='stylesheet' type='text/css'>
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='/css/screen.css' rel='stylesheet' type='text/css' media='screen' />
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src='/js/blaenk.js' type='text/javascript'></script>
</head>
<body>
  <div class="page-wrapper">
    <header id="header">
  <div id="stamp">
    <h1 id="name">
      <a href="/">
        <span class="emboldened">Jorge</span>.Israel.<span class="emboldened">Peña</span>
      </a>
    </h1>
    <h4 id="pseudonym">
      AKA <span class="emboldened">Blaenk</span>.Denum
    </h4>
  </div>
  <nav id="main-nav">
    <ul class="main">
      <li><a href="/about/">About</a></li>
      <li><a href="/notes/">Notes</a></li>
      <li><a href="/work/">Work</a></li>
      <li><a href="/lately/">Lately</a></li>
      <li><a id="search_btn">Search</a></li>
    </ul>
  </nav>
  <nav id="mobile-nav">
    <div class="menu">
      <a class="button">Menu</a>
      <div class="container">
        <ul class="main">
          <li><a href="/about/">About</a></li>
          <li><a href="/notes/">Notes</a></li>
          <li><a href="/work/">Work</a></li>
          <li><a href="/lately/">Lately</a></li>
        </ul>
      </div>
    </div>
    <div class="search">
      <a class="button"></a>
      <div class="container">
        <form action="http://google.com/search" method="get">
          <input type="text" name="q" results="0">
          <input type="hidden" name="q" value="site:blaenkdenum.com">
        </form>
      </div>
    </div>
  </nav>
</header>
<form class="desk_search" action="http://google.com/search" method="get">
  <input id="search" type="text" name="q" results="0" placeholder="Search" autocomplete="off" spellcheck="false">
  <input type="hidden" name="q" value="site:blaenkdenum.com">
</form>

    
        <article class="post">
  <h2 class="title"><a href="/notes/haskell"><span>Haskell</span></a></h2>
  <div class="entry-content"><p>I originally chose <a href="/notes/erlang">Erlang</a> as the first functional programming language to attempt learning. However, the combination of different programming paradigm, obscure Prolog-like syntax, and unfamiliar concurrency paradigm made it particularly difficult for me to see the big picture of functional programming.</p>

<p>I&rsquo;m actually familiar with Haskell now. This very site is written in Haskell, and I have worked on a few other Haskell projects. That said, Haskell is also a programming language theory (<abbr title="Programming Language Theory">PLT</abbr>) playground. To that end, <abbr title="Glasgow Haskell Compiler">GHC</abbr> contains various Haskell language extensions which I&rsquo;m not entirely familiar with. This page of notes will therefore not necessarily cover the more basic aspects and instead will cover language extensions, popular libraries, idiomatic patterns, modules, parallelism and concurrency, and so on.</p>

<nav id="toc">
<h3>Contents</h3><ol>
<li>
<a href="#user-guide">User Guide</a>
</li>
<li>
<a href="#type-classes">Type Classes</a>
<ol>
<li>
<a href="#functors">Functors</a>
</li>
<li>
<a href="#applicative-functors">Applicative Functors</a>
</li>
</ol>
</li>
<li>
<a href="#parallelism">Parallelism</a>
<ol>
<li>
<a href="#threadscope">ThreadScope</a>
</li>
<li>
<a href="#eval-monad">Eval Monad</a>
</li>
<li>
<a href="#sparks">Sparks</a>
</li>
<li>
<a href="#deepseq">Deepseq</a>
</li>
<li>
<a href="#evaluation-strategies">Evaluation Strategies</a>
<ol>
<li>
<a href="#parameterized-strategies">Parameterized Strategies</a>
</li>
</ol>
</li>
</ol>
</li>
<li>
<a href="#documentation">Documentation</a>
<ol>
<li>
<a href="#haddock-markup">Haddock Markup</a>
</li>
<li>
<a href="#haddock-options">Haddock Options</a>
</li>
</ol>
</li>
<li>
<a href="#abbr-titleglasgow-haskell-compilerghcabbr-extensions"><abbr title="Glasgow Haskell Compiler">GHC</abbr> Extensions</a>
<ol>
<li>
<a href="#named-field-puns">Named-Field Puns</a>
</li>
<li>
<a href="#record-wildcards">Record WildCards</a>
</li>
<li>
<a href="#tuple-sections">Tuple Sections</a>
</li>
<li>
<a href="#package-imports">Package Imports</a>
</li>
<li>
<a href="#overloaded-strings">Overloaded Strings</a>
</li>
<li>
<a href="#lambda-case">Lambda Case</a>
</li>
<li>
<a href="#multi-way-if">Multi-Way If</a>
</li>
<li>
<a href="#bang-patterns">Bang Patterns</a>
</li>
<li>
<a href="#view-patterns">View Patterns</a>
</li>
<li>
<a href="#pattern-guards">Pattern Guards</a>
</li>
<li>
<a href="#explicit-universal-quantification">Explicit Universal Quantification</a>
</li>
<li>
<a href="#scoped-type-variables">Scoped Type Variables</a>
</li>
<li>
<a href="#liberal-type-synonyms">Liberal Type Synonyms</a>
</li>
<li>
<a href="#rank-n-types">Rank-N Types</a>
</li>
<li>
<a href="#empty-data-declarations">Empty Data Declarations</a>
<ol>
<li>
<a href="#phantom-types">Phantom Types</a>
</li>
</ol>
</li>
</ol>
</li>
<li>
<a href="#resources">Resources</a>
</li>
</ol>
</nav>
<h1 id="user-guide">
<span class="hash">#</span>
<a href="#user-guide" class="header-link">User Guide</a>
</h1>
<p>It&rsquo;s possible to build an EPUB eBook of the <a href="https://www.haskell.org/ghc/docs/latest/html/users_guide/"><abbr title="Glasgow Haskell Compiler">GHC</abbr> User Guide</a>. You&rsquo;ll need to have the <a href="https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation/Linux">required dependencies</a> to build the documentation. In my experience I ended up having to boot an Ubuntu VM because the xsltproc packages on arch were too new. It&rsquo;s necessary to <a href="https://ghc.haskell.org/trac/ghc/wiki/Building/Docs">build the documentation</a> at least once to generate the necessary files, which unfortunately ends up building <abbr title="Glasgow Haskell Compiler">GHC</abbr> itself it seems. See this <a href="https://www.ibm.com/developerworks/xml/tutorials/x-epubtut/">IBM article</a> for more information on building eBooks with docbook.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-bash"><span class="nv">$ </span>./configure
<span class="nv">$ </span><span class="nb">cd </span>docs/users_guide
<span class="nv">$ </span>make html <span class="nv">stage</span><span class="o">=</span><span class="m">0</span> <span class="nv">FAST</span><span class="o">=</span>YES
<span class="nv">$ </span><span class="nb">cd</span> ..
<span class="nv">$ </span>/usr/bin/xsltproc <span class="se">\</span>
    --stringparam base.dir docs/users_guide/users_guide/ <span class="se">\</span>
    --stringparam use.id.as.filename <span class="m">1</span> <span class="se">\</span>
    --stringparam html.stylesheet fptools.css <span class="se">\</span>
    --nonet <span class="se">\</span>
    --stringparam toc.section.depth <span class="m">3</span> <span class="se">\</span>
    --stringparam section.autolabel <span class="m">1</span> <span class="se">\</span>
    --stringparam section.label.includes.component.label <span class="m">1</span> <span class="se">\</span>
    http://docbook.sourceforge.net/release/xsl/current/epub3/chunk.xsl <span class="se">\</span>
    docs/users_guide/users_guide.xml
<span class="nv">$ </span><span class="nb">cd </span>docs/users_guide
<span class="nv">$ </span>rm *.html
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;application/epub+zip&quot;</span> &gt; mimetype
<span class="nv">$ </span>zip -0Xq ghc.epub mimetype
<span class="nv">$ </span>zip -Xr9D ghc.epub *
<span class="nv">$ </span>stat ghc.epub
</code></pre></figure><h1 id="type-classes">
<span class="hash">#</span>
<a href="#type-classes" class="header-link">Type Classes</a>
</h1>
<p>Many types can be reasoned about with a core set of type classes. This section goes over the <a href="http://www.haskell.org/haskellwiki/Typeclassopedia">typeclassopedia</a>.</p>
<h2 id="functors">
<span class="hash">#</span>
<a href="#functors" class="header-link">Functors</a>
</h2>
<p>A functor represents a computational context. The functor laws ensure that the <code>fmap</code> operation doesn&rsquo;t change the structure of the container, only its elements. The functor laws aren&rsquo;t enforced at the type level. Actually, satisfying the first law automatically satisfies the second.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>

<span class="c1">-- functor laws</span>
<span class="nf">fmap</span> <span class="n">id</span> <span class="ow">=</span> <span class="n">id</span>
<span class="nf">fmap</span> <span class="p">(</span><span class="n">g</span> <span class="o">.</span> <span class="n">h</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">g</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">h</span><span class="p">)</span>
</code></pre></figure>
<p>A way of thinking of <code>fmap</code> is that it <em>lifts</em> a function into one that operates over contexts. This is evident from the type signature that explicitly emphasizes the fact that it is partially applied.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span>  <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span>

     <span class="n">g</span> <span class="ow">::</span>   <span class="n">a</span> <span class="ow">-&gt;</span>   <span class="n">b</span>
<span class="nf">fmap</span> <span class="n">g</span> <span class="ow">::</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></figure><h2 id="applicative-functors">
<span class="hash">#</span>
<a href="#applicative-functors" class="header-link">Applicative Functors</a>
</h2>
<p>Applicative functors lie somewhere between functors and monads in expressivity. While functors allow the lifting of a normal function to a function on a computational context, applicative functors allow for the application of a function within a computational context. The type class includes a function <code>pure</code> for embedding values in a default, effect free context. Applicatives are functors by definition.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">pure</span>  <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></figure>
<p>The <code>&lt;*&gt;</code> function is essentially function application within a computational context.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="p">(</span><span class="o">$</span><span class="p">)</span>   <span class="ow">::</span>   <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span>   <span class="n">a</span> <span class="ow">-&gt;</span>   <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></figure>
<p>It&rsquo;s straightforward enough to create a convenient infix function that can be used like the regular function application <code>$</code> by embedding a regular function in a computational context before applying it to the parameter:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="n">g</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">pure</span> <span class="n">g</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span>
</code></pre></figure>
<p>However, this is what <code>fmap</code> already does based on its type. For this reason, the <code>&lt;$&gt;</code> convenience function is simply an infix alias for <code>fmap</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="nf">fmap</span>  <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">fmap</span>
</code></pre></figure>
<p>Note that in a monadic context, the effects are applied sequentially, from left to right. This is makes sense because function application is left-associative, and each application of <code>&lt;*&gt;</code>, which for monads is <code>ap</code> which itself is <code>liftM2 id</code>, has to extract the pure function and value from their respective monad &lsquo;container&rsquo; <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>, thereby performing the monad&rsquo;s effects.</p>

<p>There also exists functions <code>*&gt;</code> and <code>&lt;*</code> that sequence actions while discarding the value of one of the arguments: left and right respectively. These are immensely useful for monadic parser combinators such as those found in the <a href="http://hackage.haskell.org/package/parsec">Parsec</a> library. For example, <code>*&gt;</code> is useful in Parsec to consume the first parser but return the second, similar to <code>&gt;&gt;</code> in a monadic context.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="p">(</span><span class="o">*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="nf">u</span> <span class="o">*&gt;</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">const</span> <span class="n">id</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span>

<span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="nf">u</span> <span class="o">&lt;*</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">pure</span> <span class="n">const</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span>
</code></pre></figure>
<p>Finally, there&rsquo;s a function that replaces all of the locations in the input context with the provided value. This is useful in Parsec when we want to parse some input, and if the input is successfully consumed, return something else, such as parsing a URL-encoded space with <code>&#39; &#39; &lt;$ char &#39;+&#39;</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="p">(</span><span class="o">&lt;$</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&lt;$</span><span class="p">)</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="o">.</span> <span class="n">const</span>

<span class="c1">-- (fmap . const) x y</span>
<span class="c1">-- ((fmap . const) x) y</span>
<span class="c1">-- (fmap (const x)) y     &lt;- (f . g) x = f (g x)</span>
<span class="c1">-- fmap (const x) y</span>

<span class="c1">-- can also be thought of as</span>
<span class="nf">x</span> <span class="o">&lt;$</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">pure</span> <span class="n">x</span> <span class="o">&lt;*</span> <span class="n">y</span>
</code></pre></figure><h1 id="parallelism">
<span class="hash">#</span>
<a href="#parallelism" class="header-link">Parallelism</a>
</h1>
<p>Amdahl&rsquo;s law places an upper bound on potential speedup that may be available by adding more processors. The expected speedup \(S\) can be described as a function of the number of processors \(N\) and the percentage of runtime that can be parallelized \(P\). The implications are that the potential speedup increasingly becomes negligible with the increase in processors, but more importantly that most programs have a theoretical maximum amount of parallelism.</p>

<p>\[S(N) = \frac {1} {(1 - P) + \frac P N}\]</p>

<p><img src="/images/notes/haskell/amdahls-law.png" class="center"></p>
<h2 id="threadscope">
<span class="hash">#</span>
<a href="#threadscope" class="header-link">ThreadScope</a>
</h2>
<p>The <a href="http://hackage.haskell.org/package/threadscope">ThreadScope</a> tool helps visualize parallel execution, particularly for profiling. To use ThreadScope, the program should be compiled with the <code>-eventlog</code> <abbr title="Glasgow Haskell Compiler">GHC</abbr> option and then run with the <code>+RTS -l</code> option to generate the eventlog. ThreadScope is then run on this event log:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-bash"><span class="nv">$ </span>ghc -O2 program.hs -threaded -rtsopts -eventlog
<span class="nv">$ </span>./program +RTS -N2 -l
<span class="nv">$ </span>threadscope program.eventlog
</code></pre></figure><h2 id="eval-monad">
<span class="hash">#</span>
<a href="#eval-monad" class="header-link">Eval Monad</a>
</h2>
<p>The <code>Eval</code> monad from Control.Parallel.Strategies expresses parallelism naturally. The <code>rpar</code> combinator expresses that the argument can be evaluated in parallel, and <code>rseq</code> forces sequential evaluation. Evaluation is to weak head normal form (<abbr title="Weak Head Normal Form">WHNF</abbr>), i.e. the outermost type constructor is evaluated. Notice that the monad is completely pure, with no need for the <code>IO</code> monad.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="kr">data</span> <span class="kt">Eval</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Eval</span>

<span class="nf">runEval</span> <span class="ow">::</span> <span class="kt">Eval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="nf">rpar</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>
<span class="nf">rseq</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>
</code></pre></figure>
<p>For example, the following evaluates two thunks in parallel then waits for both to be evaluated before returning:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="nf">runEval</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="o">$</span> <span class="n">f</span> <span class="n">x</span>
  <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="o">$</span> <span class="n">f</span> <span class="n">y</span>
  <span class="n">rseq</span> <span class="n">a</span>
  <span class="n">rseq</span> <span class="n">b</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</code></pre></figure>
<p>Consider the following parallelized <code>map</code> implementation:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="nf">parMap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">parMap</span> <span class="n">f</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">[]</span>
<span class="nf">parMap</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span><span class="kt">:</span><span class="n">as</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">b</span>  <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">bs</span> <span class="ow">&lt;-</span> <span class="n">parMap</span> <span class="n">f</span> <span class="n">as</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">b</span><span class="kt">:</span><span class="n">bs</span><span class="p">)</span>

<span class="nf">runEval</span> <span class="o">$</span> <span class="n">parMap</span> <span class="n">f</span> <span class="n">xs</span>
</code></pre></figure><h2 id="sparks">
<span class="hash">#</span>
<a href="#sparks" class="header-link">Sparks</a>
</h2>
<p>An argument to <code>rpar</code> is called a <em>spark</em>. The runtime collects sparks in a pool and distributes them to available processors using a technique known as <em>work stealing</em>. These sparks are to be <em>converted</em>, i.e. evaluated in parallel, though this may fail in a variety of ways. The <code>+RTS -s</code> option provides information about the sparks and what became of them during the execution of the program in the following form:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-text">SPARKS: 100 (100 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)
</code></pre></figure>
<table>
<thead>
<tr>
<th style="text-align: left">Term</th>
<th style="text-align: left">Definition</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">converted</td>
<td style="text-align: left">evaluated in parallel</td>
</tr>
<tr>
<td style="text-align: left">overflowed</td>
<td style="text-align: left">didn&rsquo;t fit in the spark pool</td>
</tr>
<tr>
<td style="text-align: left">dud</td>
<td style="text-align: left">already evaluated, ignored</td>
</tr>
<tr>
<td style="text-align: left">GC&rsquo;d</td>
<td style="text-align: left">unused, garbage collected</td>
</tr>
<tr>
<td style="text-align: left">fizzled</td>
<td style="text-align: left">evaluated some place else</td>
</tr>
</tbody>
</table>
<h2 id="deepseq">
<span class="hash">#</span>
<a href="#deepseq" class="header-link">Deepseq</a>
</h2>
<p>The Control.Deepseq module contains various utilities for forcing the evaluation of a thunk. It defines the <code>NFData</code>, i.e. <em>normal-form data</em>, type class. This type class has only one method, <code>rnf</code>, i.e. <em>reduce to normal-form</em>, which defines how the particular type may be evaluated to normal form, returning <code>()</code> afterward:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="kr">class</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">rnf</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
  <span class="n">rnf</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="nb">()</span>
</code></pre></figure>
<p>The module also defines a <code>deepseq</code> function which performs a <em>deep</em> evaluation to normal form, similar to <code>seq</code> which performs <em>shallow</em> evaluation to <abbr title="Weak Head Normal Form">WHNF</abbr>. There&rsquo;s also a more convenient <code>force</code> function which evaluates the argument to normal form and then returns the result.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="nf">deepseq</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">deepseq</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">rnf</span> <span class="n">a</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">b</span>

<span class="nf">force</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">force</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">deepseq</span><span class="p">`</span> <span class="n">x</span>
</code></pre></figure><h2 id="evaluation-strategies">
<span class="hash">#</span>
<a href="#evaluation-strategies" class="header-link">Evaluation Strategies</a>
</h2>
<p>Evaluation strategies decouple algorithms from parallelism, allowing for parallelizing in different ways by substituting a different strategy. A <code>Strategy</code> is a function in <code>Eval</code> that returns its argument.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="kr">type</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>
</code></pre></figure>
<p>A strategy would take a data structure as input which is then traversed and evaluated with parallelism and returns the original value. For example a strategy for evaluating a pair tuple could look like:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="nf">parPair</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">parPair</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">a&#39;</span> <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="n">a</span>
  <span class="n">b&#39;</span> <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="n">b</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">a&#39;</span><span class="p">,</span> <span class="n">b&#39;</span><span class="p">)</span>
</code></pre></figure>
<p>This strategy could then be used either directly or using the <code>using</code> combinator, which reads as <em>use this expression by evaluating it with this strategy</em>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="nf">using</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">x</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">runEval</span> <span class="p">(</span><span class="n">s</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">runEval</span> <span class="o">.</span> <span class="n">parPair</span> <span class="o">$</span> <span class="p">(</span><span class="n">fib</span> <span class="mi">35</span><span class="p">,</span> <span class="n">fib</span> <span class="mi">36</span><span class="p">)</span>
<span class="p">(</span><span class="n">fib</span> <span class="mi">35</span><span class="p">,</span> <span class="n">fib</span> <span class="mi">36</span><span class="p">)</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parPair</span>
</code></pre></figure><h3 id="parameterized-strategies">
<span class="hash">#</span>
<a href="#parameterized-strategies" class="header-link">Parameterized Strategies</a>
</h3>
<p>The <code>parPair</code> always evaluates the pair components in parallel and always to <abbr title="Weak Head Normal Form">WHNF</abbr>. A parameterized strategy could take as arguments strategies to apply to the type&rsquo;s components. The following <code>evalPair</code> function is so called because it no longer assume parallelism, instead delegating that decision to the passed in strategy.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="nf">evalPair</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">evalPair</span> <span class="n">sa</span> <span class="n">sb</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">a&#39;</span> <span class="ow">&lt;-</span> <span class="n">sa</span> <span class="n">a</span>
  <span class="n">b&#39;</span> <span class="ow">&lt;-</span> <span class="n">sb</span> <span class="n">b</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">a&#39;</span><span class="p">,</span> <span class="n">b&#39;</span><span class="p">)</span>
</code></pre></figure>
<p>It&rsquo;s then possible to define a <code>parPair</code> function in terms of <code>evalPair</code> that evaluates the pair&rsquo;s components in parallel. However, the <code>rpar</code> strategy only evaluates to <abbr title="Weak Head Normal Form">WHNF</abbr>, restricting the evaluation strategy. We could instead use <code>rdeepseq</code>&mdash;a strategy to evaluate to normal form&mdash;by wrapping <code>rdeepseq</code> with <code>rpar</code>. The <code>rparWith</code> combinator allows the wrapping of strategies in this manner:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="nf">rdeepseq</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span>
<span class="nf">rdeepseq</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">rseq</span> <span class="p">(</span><span class="n">force</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">rparWith</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span>

<span class="nf">parPair</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">parPair</span> <span class="n">sa</span> <span class="n">sb</span> <span class="ow">=</span> <span class="n">evalPair</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">sa</span><span class="p">)</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">sb</span><span class="p">)</span>
</code></pre></figure>
<p>This then allows us to use <code>parPair</code> to create a strategy that evaluates a pair tuple to normal form, which can then be used with the <code>using</code> combinator:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="p">(</span><span class="n">fib</span> <span class="mi">35</span><span class="p">,</span> <span class="n">fib</span> <span class="mi">36</span><span class="p">)</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parPair</span> <span class="n">rdeepseq</span> <span class="n">rdeepseq</span>
</code></pre></figure>
<p>Sometimes it may be required to not evaluate certain type components, which can be accomplished using the <code>r0</code> strategy. For example, the following evaluates only the first components of a pair of pairs, i.e. <code>a</code> and <code>c</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="nf">r0</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span>
<span class="nf">r0</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">x</span>

<span class="nf">evalPair</span> <span class="p">(</span><span class="n">evalPair</span> <span class="n">rpar</span> <span class="n">r0</span><span class="p">)</span> <span class="p">(</span><span class="n">evalPair</span> <span class="n">rpar</span> <span class="n">r0</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
</code></pre></figure>
<p>The <code>parMap</code> function can be defined in terms of evaluation strategies. The <code>parList</code> function is a strategy that evaluates list elements in parallel. Defining <code>parList</code> can take the same approach as before: define a parameterized strategy on lists called <code>evalList</code> and then define a parameterized function <code>parList</code> that performs <code>evalList</code> in parallel. Both of these functions are already defined in Control.Parallel.Strategies:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="nf">evalList</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">evalList</span> <span class="n">strat</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="n">return</span> <span class="kt">[]</span>
<span class="nf">evalList</span> <span class="n">strat</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">x&#39;</span>  <span class="ow">&lt;-</span> <span class="n">strat</span> <span class="n">x</span>
  <span class="n">xs&#39;</span> <span class="ow">&lt;-</span> <span class="n">evalList</span> <span class="n">strat</span> <span class="n">xs</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">x&#39;</span><span class="kt">:</span><span class="n">xs&#39;</span><span class="p">)</span>

<span class="nf">parList</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">parList</span> <span class="n">strat</span> <span class="ow">=</span> <span class="n">evalList</span> <span class="o">$</span> <span class="n">rparWith</span> <span class="n">strat</span>

<span class="nf">parMap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">parMap</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">rseq</span>
</code></pre></figure><h1 id="documentation">
<span class="hash">#</span>
<a href="#documentation" class="header-link">Documentation</a>
</h1>
<p><a href="http://www.haskell.org/haddock/doc/html/">Haddock</a> is the documentation system that is most prevalent in the Haskell community. Documentation can be generated using the <code>haddock</code> command or more commonly <code>cabal haddock</code>.</p>

<p>Declarations can be annotated by beginning comments with <code>-- |</code>, which applies the documentation to the following declaration in the source file. It&rsquo;s also possible to place annotations after a given declaration, in which case the caret <code>^</code> is used instead of the <code>|</code> to denote an annotation.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="n">b</span>
  <span class="c1">-- | the C1 constructor is used for foo</span>
  <span class="ow">=</span> <span class="kt">C1</span> <span class="n">a</span> <span class="n">b</span>
  <span class="c1">-- | the C2 constructor is used for bar</span>
  <span class="o">|</span> <span class="kt">C2</span> <span class="n">a</span> <span class="n">b</span>

<span class="kr">data</span> <span class="kt">T</span> <span class="n">a</span> <span class="n">b</span>
  <span class="ow">=</span> <span class="kt">C1</span> <span class="n">a</span> <span class="n">b</span> <span class="c1">-- ^ the C1 constructor is used for foo</span>
  <span class="o">|</span> <span class="kt">C2</span> <span class="n">a</span> <span class="n">b</span> <span class="c1">-- ^ the C2 constructor is used for bar</span>
</code></pre></figure>
<p>Annotations can span multiple lines until the first non-comment line is encountered. It&rsquo;s also possible to use multi-line comments by opening them with <code>{-|</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="c1">-- | this is a comment</span>
<span class="c1">-- that spans multiple lines</span>
<span class="nf">f</span> <span class="ow">::</span> <span class="kt">Int</span>   <span class="c1">-- ^ the int</span>
  <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="c1">-- ^ the float</span>
  <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span> <span class="c1">-- ^ the return value</span>
</code></pre></figure>
<p>Chunks of documentation can be given a name with <code>$name</code> and then included elsewhere.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="kr">module</span> <span class="nn">Foo</span> <span class="p">(</span>
  <span class="c1">-- $doc</span>
<span class="p">)</span>

<span class="c1">-- $doc</span>
<span class="c1">-- this is a large chunk of documentation</span>
<span class="c1">-- that spans many lines</span>
</code></pre></figure><h2 id="haddock-markup">
<span class="hash">#</span>
<a href="#haddock-markup" class="header-link">Haddock Markup</a>
</h2>
<p>One or more blank lines separates two paragraphs. Emphasis is denoted by surrounding text with a forward-slash <code>/</code>, whereas bold text is denoted by surrounding the text with two underscores <code>__</code> Monospace text is denoted by surrounding it with <code>@</code>. Other markup is valid inside each of these, for example, <code>@&#39;f&#39;</code> will hyperlink the identifier <code>f</code> within the monospace text.</p>

<p>Links can be inserted using <code>&lt;url label&gt;</code> syntax, although Haddock automatically links free-standing URLs. It&rsquo;s also possible to link to other parts of the same page with <code>#anchor#</code> syntax.</p>

<p>Images can be embedded with <code>&lt;&lt;path.png title&gt;&gt;</code> syntax.</p>

<p>It&rsquo;s possible to link to Haskell identifiers that are types, classes, constructors, or functions by surrounding them with single quotes. If the target is not in the scope, they may be referenced by fully qualifying them.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-text">-- | This module defines the type 'T'
-- It has nothing to do with 'M.T'
</code></pre></figure>
<p>Alternatively, it&rsquo;s possible to link to a module entirely by surrounding the name with double quotes.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-text">-- | This is a reference to the "Foo" module
</code></pre></figure>
<p>Code blocks may be inserted by surrounding the paragraph with <code>@</code> signs, where its content is interpreted as normal markup. Alternatively, it&rsquo;s possible to do so by preceding each line with a <code>&gt;</code>, in which case the text is interpreted literally.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-text">-- | this is some documentation that includes code
--
-- @
--     f x = x + x
-- @
--
-- > g x = x * 42
</code></pre></figure>
<p>It&rsquo;s possible to denote REPL examples with <code>&gt;&gt;&gt;</code>, followed by the result.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-text">-- | demonstrating the REPL example syntax
--
-- >>> fib 10
-- 55
</code></pre></figure>
<p>Unordered lists are possible by simply preceding the paragraph with a <code>*</code> or <code>-</code>. Ordered lists are possible by preceding each item with <code>(n)</code> or <code>n.</code>.</p>
<h2 id="haddock-options">
<span class="hash">#</span>
<a href="#haddock-options" class="header-link">Haddock Options</a>
</h2>
<p>Haddock accepts some comma-separated list of options that affect how it generates documentation for that module, much like <code>LANGUAGE</code> pragmas in Haskell.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# OPTIONS_HADDOCK hide, prune #-}</span>
</code></pre></figure>
<table>
<thead>
<tr>
<th style="text-align: left">Option</th>
<th style="text-align: left">Effect</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">hide</td>
<td style="text-align: left">omits module; doesn&rsquo;t affect re-exported definitions</td>
</tr>
<tr>
<td style="text-align: left">prune</td>
<td style="text-align: left">omits definitions with no annotations</td>
</tr>
<tr>
<td style="text-align: left">ignore-exports</td>
<td style="text-align: left">ignore export list; all top-level declarations are exported</td>
</tr>
<tr>
<td style="text-align: left">not-home</td>
<td style="text-align: left">module shouldn&rsquo;t be considered to be home module</td>
</tr>
<tr>
<td style="text-align: left">show-extensions</td>
<td style="text-align: left">include all language extensions used in the module</td>
</tr>
</tbody>
</table>
<h1 id="abbr-titleglasgow-haskell-compilerghcabbr-extensions">
<span class="hash">#</span>
<a href="#abbr-titleglasgow-haskell-compilerghcabbr-extensions" class="header-link"><abbr title="Glasgow Haskell Compiler">GHC</abbr> Extensions</a>
</h1>
<p>Haskell is a <abbr title="Programming Language Theory">PLT</abbr> playground, and as a result <abbr title="Glasgow Haskell Compiler">GHC</abbr> has available a multitude of language extensions. I found a <a href="https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions">series of articles</a> that cover some of the more popular extensions.</p>
<h2 id="named-field-puns">
<span class="hash">#</span>
<a href="#named-field-puns" class="header-link">Named-Field Puns</a>
</h2>
<p>Record puns allows for the easy creation of bindings of the same name as their field.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE NamedFieldPuns #-}</span>

<span class="nf">greet</span> <span class="kt">IndividualR</span> <span class="p">{</span> <span class="n">person</span> <span class="ow">=</span> <span class="kt">PersonR</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">=</span> <span class="n">fn</span> <span class="p">}</span> <span class="p">}</span> <span class="ow">=</span> <span class="s">&quot;Hi, &quot;</span> <span class="o">++</span> <span class="n">fn</span>
<span class="nf">greet</span> <span class="kt">IndividualR</span> <span class="p">{</span> <span class="n">person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="p">}</span> <span class="p">}</span> <span class="ow">=</span> <span class="s">&quot;Hi, &quot;</span> <span class="o">++</span> <span class="n">firstName</span>
</code></pre></figure><h2 id="record-wildcards">
<span class="hash">#</span>
<a href="#record-wildcards" class="header-link">Record WildCards</a>
</h2>
<p>This extension allows the use of two dots <code>..</code> to automatically create bindings for all fields at that location, named the same as the fields they bind.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE RecordWildCards #-}</span>

<span class="nf">greet</span> <span class="kt">IndividualR</span> <span class="p">{</span> <span class="n">person</span> <span class="ow">=</span> <span class="kt">PersonR</span> <span class="p">{</span> <span class="o">..</span> <span class="p">}</span> <span class="p">}</span> <span class="ow">=</span> <span class="s">&quot;Hi, &quot;</span> <span class="o">++</span> <span class="n">firstName</span>
</code></pre></figure><h2 id="tuple-sections">
<span class="hash">#</span>
<a href="#tuple-sections" class="header-link">Tuple Sections</a>
</h2>
<p>Tuple sections are a straightforward extension that allows tuples to be used in sections.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE TupleSections #-}</span>

<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,,</span> <span class="kt">Just</span> <span class="nb">()</span><span class="p">,)</span> <span class="o">==</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="kt">Just</span> <span class="nb">()</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</code></pre></figure><h2 id="package-imports">
<span class="hash">#</span>
<a href="#package-imports" class="header-link">Package Imports</a>
</h2>
<p>This allows one to explicitly specify the package from which to import a module, which is useful when needed for disambiguation purposes.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE PackageImports #-}</span>

<span class="kr">import</span> <span class="s">&quot;package-one-0.1.01&quot;</span> <span class="nn">Data.Module.X</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="s">&quot;containers&quot;</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span>
</code></pre></figure><h2 id="overloaded-strings">
<span class="hash">#</span>
<a href="#overloaded-strings" class="header-link">Overloaded Strings</a>
</h2>
<p>This allows string literals to be polymorphic over the <code>IsString</code> type class which is implemented by types like <code>Text</code> and <code>ByteString</code>, making it less of a pain to construct values of those types.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Text.IO</span> <span class="k">as</span> <span class="n">T</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">putStrLn</span> <span class="s">&quot;Hello as Text!&quot;</span>
</code></pre></figure><h2 id="lambda-case">
<span class="hash">#</span>
<a href="#lambda-case" class="header-link">Lambda Case</a>
</h2>
<p>This provides a shorthand for a lambda containing a case match.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE LambdaCase #-}</span>

<span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> <span class="o">==</span> <span class="nf">\</span><span class="kr">case</span>
</code></pre></figure><h2 id="multi-way-if">
<span class="hash">#</span>
<a href="#multi-way-if" class="header-link">Multi-Way If</a>
</h2>
<p>This allows guard syntax to be used with <code>if</code> expressions to avoid excessive nesting and repeating of the <code>if</code> expression.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE MultiWayIf #-}</span>

<span class="kr">if</span> <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span>    <span class="ow">-&gt;</span> <span class="s">&quot;a&quot;</span>
   <span class="o">|</span> <span class="n">y</span> <span class="o">&lt;</span>  <span class="mi">2</span>    <span class="ow">-&gt;</span> <span class="s">&quot;b&quot;</span>
   <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">-&gt;</span> <span class="s">&quot;d&quot;</span>
</code></pre></figure><h2 id="bang-patterns">
<span class="hash">#</span>
<a href="#bang-patterns" class="header-link">Bang Patterns</a>
</h2>
<p>This allows to evaluate to a value to weak head normal form before matching it.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE BangPatterns #-}</span>

<span class="nf">strictFunc</span> <span class="o">!</span><span class="n">v</span> <span class="ow">=</span> <span class="nb">()</span>
</code></pre></figure><h2 id="view-patterns">
<span class="hash">#</span>
<a href="#view-patterns" class="header-link">View Patterns</a>
</h2>
<p>A view pattern <code>e -&gt; p</code> applies the view <code>e</code> to the argument that would be matched, yielding a result which is matched against <code>p</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE ViewPatterns #-}</span>

<span class="nf">eitherEndIsZero</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">eitherEndIsZero</span> <span class="p">(</span><span class="n">head</span> <span class="ow">-&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">eitherEndIsZero</span> <span class="p">(</span><span class="n">last</span> <span class="ow">-&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">eitherEndIsZero</span>           <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</code></pre></figure><h2 id="pattern-guards">
<span class="hash">#</span>
<a href="#pattern-guards" class="header-link">Pattern Guards</a>
</h2>
<p>Pattern guards are a generalization of guards which allow <em>pattern guardlets</em> aside from the more common boolean guardlets. Pattern guardlets are of the form <code>p &lt;- e</code> which is fulfilled (i.e. accepted) when <code>e</code> matches against <code>p</code>. Further guardlets can be chained with commas. As usual, guardlets are tested in order from top to bottom before the guard as a whole is accepted.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE PatternGuards #-}</span>

<span class="nf">func</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">func</span> <span class="n">xs</span> <span class="o">|</span> <span class="mi">7</span> <span class="ow">&lt;-</span> <span class="n">sum</span> <span class="n">xs</span>    <span class="c1">-- if the sum is 7</span>
        <span class="p">,</span> <span class="n">n</span> <span class="ow">&lt;-</span> <span class="n">length</span> <span class="n">xs</span> <span class="c1">-- bind the length to n for further checks</span>
        <span class="p">,</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">5</span>         <span class="c1">-- and the length is &gt;= 5</span>
        <span class="p">,</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">20</span>        <span class="c1">-- and &lt;= 20</span>
          <span class="ow">=</span> <span class="kt">EQ</span>           <span class="c1">-- then evaluate to EQ</span>
        <span class="o">|</span> <span class="n">otherwise</span>
          <span class="ow">=</span> <span class="kt">LT</span>
</code></pre></figure><h2 id="explicit-universal-quantification">
<span class="hash">#</span>
<a href="#explicit-universal-quantification" class="header-link">Explicit Universal Quantification</a>
</h2>
<p>This allows to explicitly annotate universal quantification in polymorphic type signatures. On its own this extension isn&rsquo;t very useful. Instead, it&rsquo;s required by many other extensions.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE ExplicitForAll #-}</span>

<span class="nf">map</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
</code></pre></figure><h2 id="scoped-type-variables">
<span class="hash">#</span>
<a href="#scoped-type-variables" class="header-link">Scoped Type Variables</a>
</h2>
<p>This allows type variables to have scope so that nested scopes' type signatures can close over them and refer to them. Without the extension, the <code>a</code> in the type signature of <code>sorted</code> and <code>nubbed</code> would not only be different from <code>func</code>&rsquo;s type signature, but also different from themselves.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="nf">func</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Char</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span>
<span class="nf">func</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">zip3</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span> <span class="o">..</span> <span class="sc">&#39;z&#39;</span><span class="p">]</span> <span class="n">sorted</span> <span class="n">nubbed</span>
  <span class="kr">where</span> <span class="n">sorted</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="n">sorted</span> <span class="ow">=</span> <span class="n">sort</span> <span class="n">xs</span>
        <span class="n">nubbed</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="n">nubbed</span> <span class="ow">=</span> <span class="n">nub</span> <span class="n">xs</span>
</code></pre></figure><h2 id="liberal-type-synonyms">
<span class="hash">#</span>
<a href="#liberal-type-synonyms" class="header-link">Liberal Type Synonyms</a>
</h2>
<p>This relaxes restrictions on type synonyms so that type signatures are checked until after all type synonyms have been expanded, so that something like this is possible:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE LiberalTypeSynonyms #-}</span>

<span class="kr">type</span> <span class="kt">Const</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kt">Id</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kt">NatApp</span> <span class="n">f</span> <span class="n">g</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="n">i</span>

<span class="nf">func</span> <span class="ow">::</span> <span class="kt">NatApp</span> <span class="kt">Id</span> <span class="p">(</span><span class="kt">Const</span> <span class="kt">Int</span><span class="p">)</span> <span class="kt">Char</span>
<span class="c1">--      Id Char -&gt; Const Int Char</span>
<span class="c1">--      Char    -&gt; Int</span>
<span class="nf">func</span> <span class="ow">=</span> <span class="n">ord</span>
</code></pre></figure><h2 id="rank-n-types">
<span class="hash">#</span>
<a href="#rank-n-types" class="header-link">Rank-N Types</a>
</h2>
<p>This allows the nesting of explicit universal quantifications within function types and data definitions. In the following example, the difference between the signatures is that the first signature specifically applies the universal quantification to the passed in function, whereas the second signature applies the universal quantification to the whole signature.</p>

<p>What this means is that the second signature would accept any function from <code>n -&gt; n</code> that applies for <em>some</em> <code>Num n</code>, but the first signature requires a function from <code>n -&gt; n</code> that applies for <em>every</em> <code>Num n</code>.</p>

<p>For example, <code>(+1)</code> would be valid for both signatures, since every <code>Num</code> defines <code>(+)</code>. However, <code>(/5)</code> would only be valid for the second signature because it&rsquo;s a function from <code>n -&gt; n</code> that only applies for <em>some</em> <code>Num n</code>, particularly the subset of <code>Num n</code> that also implements <code>Fractional</code>. Since not <em>every</em> <code>Num n</code> implements <code>Fractional</code>, that function is <em>not</em> valid for the first signature.</p>

<p><strong>Note</strong>: This extension deprecates the less general extensions <code>Rank2Types</code> and <code>Polymorphic​Components</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="cm">{-# LANGUAGE RankNTypes #-}</span>

<span class="nf">rankN</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">n</span><span class="o">.</span> <span class="kt">Num</span> <span class="n">n</span> <span class="ow">=&gt;</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span>
<span class="nf">rankN</span> <span class="n">f</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="c1">-- compare to</span>
<span class="nf">rankN</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">n</span><span class="o">.</span> <span class="kt">Num</span> <span class="n">n</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span>
</code></pre></figure>
<p>When this extension is used in conjunction with <code>LiberalTypeSynonyms</code>, it allows the universal quantification and/or constraints within type synonyms as well as the application or partial application of a type synonym to a type containing universal quantification and/or constraints.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="kr">type</span> <span class="kt">Const</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kt">Id</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kt">Indexed</span> <span class="n">f</span> <span class="n">g</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">i</span><span class="o">.</span> <span class="n">f</span> <span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="n">i</span>
<span class="kr">type</span> <span class="kt">ShowIndexed</span> <span class="n">f</span> <span class="n">g</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">i</span><span class="o">.</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">i</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="n">i</span>
<span class="kr">type</span> <span class="kt">ShowConstrained</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kt">FunctionTo</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="nf">func1</span> <span class="ow">::</span> <span class="kt">Indexed</span> <span class="kt">Id</span> <span class="p">(</span><span class="kt">Const</span> <span class="kt">Int</span><span class="p">)</span>
<span class="c1">--       forall i. Id i -&gt; Const Int i</span>
<span class="c1">--       forall i. i    -&gt; Int</span>
<span class="nf">func1</span> <span class="kr">_</span> <span class="ow">=</span> <span class="mi">2</span>

<span class="nf">func2</span> <span class="ow">::</span> <span class="kt">ShowIndexed</span> <span class="kt">Id</span> <span class="p">(</span><span class="kt">Const</span> <span class="kt">Int</span><span class="p">)</span>
<span class="c1">--       forall i. (Show i) =&gt; Id i -&gt; Const Int i</span>
<span class="c1">--       forall i. (Show i) =&gt; i    -&gt; Int</span>
<span class="nf">func2</span> <span class="ow">=</span> <span class="n">length</span> <span class="o">.</span> <span class="n">show</span>

<span class="nf">func3</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">ShowConstrained</span> <span class="p">(</span><span class="kt">FunctionTo</span> <span class="kt">Char</span><span class="p">)</span> <span class="n">a</span>
<span class="c1">--       forall a. (Show a) =&gt; FunctionTo Char a</span>
<span class="c1">--       forall a. (Show a) =&gt; a -&gt; Char</span>
<span class="nf">func3</span> <span class="ow">=</span> <span class="n">head</span> <span class="o">.</span> <span class="n">show</span>

<span class="kr">type</span> <span class="kt">ShowConstrained2</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="kr">type</span> <span class="kt">EnumFunctionTo</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Enum</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="nf">func</span> <span class="ow">::</span> <span class="kt">ShowConstrained2</span> <span class="p">(</span><span class="kt">EnumFunctionTo</span> <span class="kt">Char</span><span class="p">)</span>
<span class="c1">--      forall a. (Show a) =&gt; EnumFunctionTo Char a</span>
<span class="c1">--      forall a. (Show a, Enum a) =&gt; a -&gt; Char</span>
<span class="nf">func</span> <span class="ow">=</span> <span class="n">head</span> <span class="o">.</span> <span class="n">show</span> <span class="o">.</span> <span class="n">succ</span>
</code></pre></figure><h2 id="empty-data-declarations">
<span class="hash">#</span>
<a href="#empty-data-declarations" class="header-link">Empty Data Declarations</a>
</h2>
<p>This allows the definition of types with no constructors, which is useful for use as a phantom parameter to some other type.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="kr">data</span> <span class="kt">Empty</span>
<span class="kr">data</span> <span class="kt">EmptyWithPhantom</span> <span class="n">x</span>
<span class="kr">type</span> <span class="kt">EmptyWithEmpty</span> <span class="ow">=</span> <span class="kt">EmptyWithPhantom</span> <span class="kt">Empty</span>
</code></pre></figure><h3 id="phantom-types">
<span class="hash">#</span>
<a href="#phantom-types" class="header-link">Phantom Types</a>
</h3>
<p>Phantom types are parameterized types where some of the parameters only appear on the RHS. They are often used to encode information at the type level to make code much more strict, usually paired with empty data types.</p>

<p>Consider an API for <a href="http://blog.jakubarnold.cz/2014/07/08/using-phantom-types-for-extra-safety.html">sending encrypted messages</a>. It&rsquo;s possible to encode&mdash;at the type-system level&mdash;that only <em>encrypted</em> messages may be sent using the <code>send</code> function, thus preventing plain-text messages from being sent. This is further enforced by making the <code>Message</code> constructor private and exposing a single constructor to build a plain-text message, such as <code>newMessage</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="kr">data</span> <span class="kt">Message</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Message</span> <span class="kt">String</span>

<span class="kr">data</span> <span class="kt">Encrypted</span>
<span class="kr">data</span> <span class="kt">PlainText</span>

<span class="nf">send</span>    <span class="ow">::</span> <span class="kt">Message</span> <span class="kt">Encrypted</span> <span class="ow">-&gt;</span> <span class="kt">Recipient</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">encrypt</span> <span class="ow">::</span> <span class="kt">Message</span> <span class="kt">PlainText</span> <span class="ow">-&gt;</span> <span class="kt">Message</span> <span class="kt">Encrypted</span>
<span class="nf">decrypt</span> <span class="ow">::</span> <span class="kt">Message</span> <span class="kt">Encrypted</span> <span class="ow">-&gt;</span> <span class="kt">Message</span> <span class="kt">PlainText</span>

<span class="nf">newMessage</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Message</span> <span class="kt">PlainText</span>
<span class="nf">newMessage</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Message</span> <span class="n">s</span>

<span class="c1">-- this would not type-check</span>
<span class="nf">send</span> <span class="p">(</span><span class="n">newMessage</span> <span class="s">&quot;test&quot;</span><span class="p">)</span> <span class="s">&quot;recipient@server&quot;</span>
</code></pre></figure><h1 id="resources">
<span class="hash">#</span>
<a href="#resources" class="header-link">Resources</a>
</h1>
<ul>
<li><a href="http://staff.science.uva.nl/%7Eposs/categories-from-scratch.html">Categories from Scratch</a></li>
<li><a href="https://www.youtube.com/user/TheCatsters#p/u/68/xqLgGB7Hv7g">Category Theory on Youtube</a></li>
<li><a href="http://dev.stephendiehl.com/hask/">What I Wish I Knew</a></li>
<li><a href="https://gist.github.com/bitemyapp/8739525">Learning Haskell</a></li>
<li><a href="http://www.seas.upenn.edu/%7Ecis194/lectures.html">CS 194</a></li>
<li><a href="http://www.well-typed.com/blog/86/">Performance profiling with ghc-events-analyze</a></li>
<li><a href="http://en.wikibooks.org/wiki/Haskell/Category_theory">Haskell Wikibooks - Category Theory</a></li>
<li><a href="https://docs.google.com/presentation/d/1suMuLRo1xS5NxWn-L9lGHtVNpOH48F9ZnDyv5PyxEpI/">Getting it Done with Haskell</a></li>
</ul>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Or <a href="http://www.haskell.org/haskellwiki/What_a_Monad_is_not#Monads_are_not_values">mobit</a> as some have taken to calling values that monads manage.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>
</div>
  <div class="meta">
    <div class="meta-component"><i class="fa fa-calendar fa-fw"></i> March  5, 2014</div>
    <div class="meta-component"><i class="fa fa-code-fork fa-fw"></i> <a href="https://github.com/blaenk/site/commits/master/input/notes/haskell.markdown">History</a><span class="hash">, <a href="https://github.com/blaenk/site/commit/dc6ff87" title="new table marker syntax; no need for metadata

This means there's no need to separate the toc marker from its
configuration, i.e. alignment. This never should've been necessary.

This has the nice side-effect of naturally invalidating the cache when
the toc marker is moved around or its alignment is changed.
">dc6ff87</a></span></div>
    <div class="meta-component"><i class="fa fa-tags fa-fw"></i> null</div>
  </div>
</article>
<section id="comment">
  <div id="disqus_thread" aria-live="polite">
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>



    
    <footer id="footer">
  <div id="social">
    <a href="https://github.com/blaenk" title="github"><i class="fa fa-github-alt"></i></a>
    &middot;
    <a href="http://stackoverflow.com/users/101090/jorge-israel-pena" title="stackoverflow"><i class="fa fa-stack-overflow"></i></a>
    &middot;
    <a href="https://twitter.com/blaenk" title="twitter"><i class="fa fa-twitter"></i></a>
    &middot;
    <a href="mailto:jorge.israel.p@gmail.com" title="email"><i class="fa fa-envelope"></i></a>
    &middot;
    <a href="/rss.xml" title="feed"><i class="fa fa-rss-square"></i></a>
  </div>
  <!-- <div id="credit">
    Designed by <a href="http://www.blaenkdenum.com">Jorge Israel Peña</a>
  </div> -->
</footer>


<!-- this should instead be something like connectWS("{{{path}}}") -->


<script type="text/javascript">
  jQuery(function (){
    var ws = new WebSocket('ws://' + window.location.hostname + ':9160/notes/haskell.markdown');

    ws.onmessage = function (e) {
      var content = jQuery('article .entry-content');
      content.html(e.data);

      window.refresh();

      MathJax.Hub.Queue(["Typeset", MathJax.Hub, content[0]]);
    };
  });
</script>


<!-- disqus -->
<script async="true" type="text/javascript">
  var disqus_shortname = 'blaenkdenum';
  var disqus_identifier = 'http://blaenkdenum.com/notes/haskell';
  var disqus_url = 'http://blaenkdenum.com/notes/haskell';
  var disqus_script = 'embed.js';

  (function () {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());

  jQuery(function (){
    jQuery(window).bind('orientationchange', function() {
      DISQUS.reset({
        reload: true,
        config: function() {
          this.page.identifier = 'http://blaenkdenum.com/notes/haskell'
          this.page.url = 'http://blaenkdenum.com/notes/haskell'
        }
      });
    });
  });
</script>


<!-- google analytics -->
<script async="true" type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37339861-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

<!--MathJax CDN-->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    messageStyle: "none"
  });

  MathJax.Hub.Register.MessageHook('End Process', function() {
    jQuery('#MathJax_Font_Test').empty();
    jQuery('.MathJax_Display').parent('.math').addClass('mobile-math');
  });
</script>
<script async="true" type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>

  </div>
</body>
</html>
