<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Objective-C - Blaenk Denum</title>
  <meta name="author" content="Jorge Israel Peña">
  <meta name="description" content="AKA Blaenk Denum">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="/favicon.png" rel="shortcut icon">
  <link href='http://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Merriweather:900italic,900,700italic,400italic,700,400,300italic,300' rel='stylesheet' type='text/css'>
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='/css/screen.css' rel='stylesheet' type='text/css' />
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured"></script>
  <script src="https://rawgit.com/ekalinin/typogr.js/master/typogr.min.js"></script>
  <script src='/js/blaenk.js' type='text/javascript'></script>
</head>
<body>
  <div class="page-wrapper">
    <header id="header">
  <div id="stamp">
    <h1 id="name">
      <a href="/">
        <span class="emboldened">Jorge</span>.Israel.<span class="emboldened">Peña</span>
      </a>
    </h1>
    <h4 id="pseudonym">
      AKA <span class="emboldened">Blaenk</span>.Denum
    </h4>
  </div>
  <nav id="main-nav">
    <ul class="main">
      <li><a href="/about/">About</a></li>
      <li><a href="/notes/">Notes</a></li>
      <li><a href="/work/">Work</a></li>
      <li><a href="/lately/">Lately</a></li>
      <li><a id="search_btn">Search</a></li>
    </ul>
  </nav>
  <nav id="mobile-nav">
    <div class="menu">
      <a class="button">Menu</a>
      <div class="container">
        <ul class="main">
          <li><a href="/about/">About</a></li>
          <li><a href="/notes/">Notes</a></li>
          <li><a href="/work/">Work</a></li>
          <li><a href="/lately/">Lately</a></li>
        </ul>
      </div>
    </div>
    <div class="search">
      <a class="button"></a>
      <div class="container">
        <form action="http://google.com/search" method="get">
          <input type="text" name="q" results="0">
          <input type="hidden" name="q" value="site:blaenkdenum.com">
        </form>
      </div>
    </div>
  </nav>
</header>
<form class="desk_search" action="http://google.com/search" method="get">
  <input id="search" type="text" name="q" results="0" placeholder="Search" autocomplete="off" spellcheck="false">
  <input type="hidden" name="q" value="site:blaenkdenum.com">
</form>

    
        <article class="post">
  <h2 class="title"><a href="/notes/objective-c"><span>Objective-C</span></a></h2>
  <div class="entry-content"><p>Although <a href="/notes/swift">Swift</a> has been released, there is still a considerable iOS/Cocoa ecosystem which is built on Objective-C.</p>

<nav id="toc">
<h3>Contents</h3><ol>
<li>
<a href="#types">Types</a>
</li>
<li>
<a href="#objects">Objects</a>
</li>
<li>
<a href="#automatic-reference-counting">Automatic Reference Counting</a>
</li>
<li>
<a href="#nsstring">NSString</a>
</li>
<li>
<a href="#nsarray">NSArray</a>
</li>
<li>
<a href="#nsmutablearray">NSMutableArray</a>
</li>
<li>
<a href="#classes">Classes</a>
</li>
<li>
<a href="#inheritance">Inheritance</a>
</li>
<li>
<a href="#ownership">Ownership</a>
</li>
<li>
<a href="#class-extensions">Class Extensions</a>
</li>
<li>
<a href="#reference-counting">Reference Counting</a>
</li>
<li>
<a href="#collections">Collections</a>
</li>
<li>
<a href="#enumerations">Enumerations</a>
</li>
<li>
<a href="#nserror">NSError</a>
</li>
<li>
<a href="#nsdata">NSData</a>
</li>
<li>
<a href="#callbacks">Callbacks</a>
<ol>
<li>
<a href="#selectors">Selectors</a>
</li>
<li>
<a href="#target-action">Target-action</a>
</li>
<li>
<a href="#helper-objects">Helper Objects</a>
</li>
<li>
<a href="#notifications">Notifications</a>
</li>
</ol>
</li>
<li>
<a href="#blocks">Blocks</a>
</li>
</ol>
</nav>
<h1 id="types">
<span class="hash">#</span>
<a href="#types" class="header-link">Types</a>
</h1>
<p>The <code>BOOL</code> type is an alias for an integer with variants <code>YES</code> and <code>NO</code> set to <code>1</code> and <code>0</code> respectively. Since these are integers, it&#39;s not advised to explicitly compare to <code>YES</code> because an affirmative value can be any non-zero value.</p>

<p>Explicit integer types can be used such as <code>UInt32</code> for an unsigned 32-bit integer or <code>SInt16</code> for a signed 16-bit integer.</p>

<p>The <code>NSInteger</code> and <code>NSUInteger</code> types are aliases for the integer width of the system, e.g. 32-bit on 32-bit systems.</p>
<h1 id="objects">
<span class="hash">#</span>
<a href="#objects" class="header-link">Objects</a>
</h1>
<p>Instead of invoking a method on an object, a message is sent to it:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSDate</span> <span class="o">*</span><span class="n">now</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">seconds</span> <span class="o">=</span> <span class="p">[</span><span class="n">now</span> <span class="n">timeIntervalSince1970</span><span class="p">];</span>
</code></pre></figure>
<p>Naturally, sent messages are expressions which can be embedded where expressions of that type are expected:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="kt">double</span> <span class="n">seconds</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]</span> <span class="n">timeIntervalSince1970</span><span class="p">];</span>
</code></pre></figure>
<p><em>Class methods</em> are when a message is sent to a class such as to <code>NSDate</code>, whereas <em>instance methods</em> are sent to a particular instance, such as to <code>now</code>.</p>

<p>Method arguments are named when passed to a method.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="p">[</span><span class="n">now</span> <span class="nl">dateByAddingTimeInterval</span><span class="p">:</span><span class="mi">100000</span><span class="p">]</span>
</code></pre></figure>
<p>A method&#39;s name is often described by the concatenated names of its parameters:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="c1">// ordinalityOfUnit:inUnit:forDate:</span>
<span class="p">[</span><span class="n">cal</span> <span class="nl">ordinalityOfUnit</span><span class="p">:</span><span class="n">NSDayCalendarUnit</span>
               <span class="nl">inUnit</span><span class="p">:</span><span class="n">NSMonthCalendarUnit</span>
              <span class="nl">forDate</span><span class="p">:</span><span class="n">now</span><span class="p">]</span>
</code></pre></figure>
<p>A method&#39;s declaration starts with a <code>-</code> for instance methods and <code>+</code> for class methods, followed by the parameters and their types, e.g.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqualToString:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">other</span>
</code></pre></figure>
<p>The <code>alloc</code> class method handles the allocation of the memory for an object of the class type. It returns a pointer to the allocated memory, but it is <em>not initialized</em>. The memory must be initialized with the <code>init</code> instance method.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSDate</span> <span class="o">*</span><span class="n">now</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSDate</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</code></pre></figure>
<p>Convenience methods are those which perform an allocation-initialization sequence in a conveniently expected manner. For example, since <code>NSDate</code>&#39;s <code>init</code> method initializes the <code>NSDate</code> to the current date and time, the <code>date</code> class method is considered a convenience method since it&#39;s more convenient than an explicit <code>alloc</code>-<code>init</code> chain.</p>

<p>Objective-C has <code>nil</code> to represent a pointer to no object. Sending a message to <code>nil</code> has no effect and it is completely legal.</p>

<p>The <code>id</code> type is a pointer to an Objective-C object:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="kt">id</span> <span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">some</span> <span class="n">delegate</span><span class="p">];</span>
</code></pre></figure><h1 id="automatic-reference-counting">
<span class="hash">#</span>
<a href="#automatic-reference-counting" class="header-link">Automatic Reference Counting</a>
</h1>
<p>Previously it was necessary to perform manual reference counting by invoking reference-manipulating methods such as <code>release</code> or <code>retain</code>. <em>Automatic Reference Counting</em> (ARC) injects similar constructs automatically into the code.</p>
<h1 id="nsstring">
<span class="hash">#</span>
<a href="#nsstring" class="header-link">NSString</a>
</h1>
<p><code>NSString</code> is a high-level immutable string type. <code>NSString</code> literals are string literals prefixed with the at sign <code>@</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;John&quot;</span><span class="p">;</span>
</code></pre></figure>
<p><code>NSString</code>s can contain Unicode characters by escaping them with <code>\u</code>.</p>

<p>It&#39;s possible to create an <code>NSString</code> from a given format:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSString</span> <span class="o">*</span><span class="n">dateString</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;Today is %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]];</span>
</code></pre></figure>
<p>The <code>length</code> method is used to retrieve the string length. Strings can be compared with <code>isEqualToString:</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">if</span> <span class="p">([</span><span class="n">name</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="s">@&quot;John&quot;</span><span class="p">])</span> <span class="p">{</span>
  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;They&#39;re equal&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure><h1 id="nsarray">
<span class="hash">#</span>
<a href="#nsarray" class="header-link">NSArray</a>
</h1>
<p>An <code>NSArray</code> is an immutable array that holds pointers to other objects. <code>NSArray</code> literals can be created with the syntax <code>@[…]</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">names</span> <span class="o">=</span> <span class="l">@[</span><span class="s">@&quot;John&quot;</span><span class="p">,</span> <span class="s">@&quot;Jane&quot;</span><span class="l">]</span><span class="p">;</span>
</code></pre></figure>
<p>Before <code>NSArray</code> literal syntax was introduced, the class method <code>arrayWithObjects:</code> was used to specify the list of objects with which to initialize the array, <em>terminated</em> by <code>nil</code>.</p>

<p>Elements of the array are accessed as with any other array, using subscript notation:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSString</span> <span class="o">*</span><span class="n">john</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</code></pre></figure>
<p>Before subscripting was introduced, the method <code>objectAtIndex:</code> was used to access a particular element.</p>

<p>The size of the array can be obtained with the <code>count</code> method.</p>

<p><code>NSArray</code>s can be iterated over using the <code>for-in</code> syntax known as <em>fast enumeration</em>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">for</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span> <span class="k">in</span> <span class="n">names</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@ is in the array&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure><h1 id="nsmutablearray">
<span class="hash">#</span>
<a href="#nsmutablearray" class="header-link">NSMutableArray</a>
</h1>
<p><code>NSMutableArray</code> is a subclass of <code>NSArray</code> that is mutable. The <code>addObject:</code> method can be used to push an object onto the array, whereas <code>insertObject:atIndex:</code> can insert an object at a particular location in the array.</p>

<p>The convenience class method <code>array</code> creates an empty array, just like an <code>alloc</code>-<code>init</code> chain would.</p>

<p>It&#39;s not possible to add or remove elements within a fast enumeration loop because the iterators would become invalidated. Instead use a regular for loop.</p>
<h1 id="classes">
<span class="hash">#</span>
<a href="#classes" class="header-link">Classes</a>
</h1>
<p>By convention classes are defined in pairs of header (.h) and implementation (.m) files. The header contains the interface that begins with the <code>@interface</code> keyword which states the class name and its base classes, as well as its member variables. Method declarations are placed after and outside of the braces. The end of the interface is marked with <code>@end</code>.</p>

<p>Due to the lack of namespaces, by convention classes and types are prefixed by some namespace initials preferably 3 or more letters in length, for example the <code>NS</code> in <code>NSString</code> stands for <a href="https://en.wikipedia.org/wiki/NeXTSTEP">NeXTSTEP</a>.</p>

<p>By convention member variables are prefixed with an underscore <code>_</code>, and getters take on the name of the variable without the underscore prefix and setters are prefixed with <code>set</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">@interface</span> <span class="nc">MYPerson</span> : <span class="bp">NSObject</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">_age</span><span class="p">;</span>
  <span class="bp">NSString</span> <span class="o">*</span><span class="n">_name</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">age</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAge:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">a</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></figure>
<p>By convention, accessor methods are used within instance methods rather than accessing the instance variables directly.</p>

<p>The implementation file (.m) includes the header file by using the <code>#import</code> directive which among other things prevents double inclusions. The beginning of the method implementations is marked with <code>@implementation</code> and the end of the implementation is marked with <code>@end</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="cp">#import &quot;MYPerson.h&quot;</span>

<span class="k">@implementation</span> <span class="nc">MYPerson</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">age</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">_age</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAge:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">a</span>
<span class="p">{</span>
  <span class="n">_age</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></figure>
<p>Like <code>this</code> in C++, the <code>self</code> keyword is an implicit local variable in instance methods which points to the object running the method.</p>

<p>Rather than manually defining accessor methods, it&#39;s possible to define properties for which the compiler automatically defines accessor methods. A property is marked with <code>@property</code> and it takes an argument list specifying the property&#39;s attributes (e.g. atomic or nonatomic), followed by the type and name of the property. Properties are declared within the class&#39; <code>@interface</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">@interface</span> <span class="nc">MYPerson</span> : <span class="bp">NSObject</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">)</span> <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

<span class="p">{</span>
  <span class="err">…</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></figure>
<p>Property attributes can specify whether the property is <code>atomic</code> or <code>nonatomic</code>, or whether to <em>only</em> generate a getter but not a setter via <code>readonly</code>. For example, marking it <code>readonly</code> will cause the compiler to generate a getter method but no setter method. The <code>readwrite</code> permission is the default. The <code>copy</code> attribute specifies whether the property should be copied when set or retrieved via a getter. This should be used whenever declaring a property of a pointer to an object.</p>

<p>Previously it was then necessary to place a corresponding <code>@synthesize</code> directive in the <code>@implementation</code> to actually direct the compiler to generate the accessor methods. The <code>@synthesize</code> directive specified the name that would be publicly available in the accessor methods and the name to use internally.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">@implementation</span> <span class="nc">MYPerson</span>

<span class="k">@synthesize</span> <span class="n">age</span> <span class="o">=</span> <span class="n">_age</span><span class="p">;</span>
<span class="k">@synthesize</span> <span class="n">name</span> <span class="o">=</span> <span class="n">_name</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></figure>
<p>However, as of XCode 4.4 this is no longer necessary as the compiler does this for you. It&#39;s still necessary to do if the compiler ends up not generating any of the methods, for example if a property is marked <code>readonly</code> but the getter is manually overridden, then the <code>_variable</code> won&#39;t be defined, in which case it&#39;s necessary to explicitly <code>@synthesize</code> to define it or declare it manually in the <code>@interface</code>.</p>

<p>Properties are also usable using dot notation as in C++ and Java. However, rather than simply accessing a field in a struct as in C++, dot notation translates to a message sent to the corresponding accessor method.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSString</span> <span class="o">*</span><span class="n">theName</span> <span class="o">=</span> <span class="n">person</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</code></pre></figure>
<p>It&#39;s possible to define a property with a different type than a manually defined member variable of the same name. For example, the class below defines and uses a mutable array internally, but publicly exposes an immutable array.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">@interface</span> <span class="nc">MYPerson</span> : <span class="bp">NSObject</span>
<span class="p">{</span>
  <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">_names</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSArray</span> <span class="o">*</span><span class="n">names</span><span class="p">;</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addName:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">n</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></figure>
<p>Notice that the accessor methods are overridden to handle the translation between mutable and immutable arrays. Specifically, the setter sets the internal variable to a mutable copy of the passed immutable array, while the getter returns an immutable copy of the internal immutable array.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">@implementation</span> <span class="nc">MYPerson</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setNames:</span><span class="p">(</span><span class="bp">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">n</span>
<span class="p">{</span>
  <span class="n">_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="n">mutableCopy</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="bp">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">names</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">_names</span> <span class="k">copy</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addName:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">n</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_names</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_names</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="p">[</span><span class="n">_names</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></figure><h1 id="inheritance">
<span class="hash">#</span>
<a href="#inheritance" class="header-link">Inheritance</a>
</h1>
<p>The superclass that a class inherits from is specified in the <code>@interface</code> line and it doesn&#39;t need to be repeated in the <code>@implementation</code> line.</p>

<p>A method is overridden by simply redefining its implementation; it&#39;s <em>not</em> possible to redefine its name, return type, or argument types.</p>

<p>The <code>super</code> keyword is an implicit local variable within instance methods that refers to the object of the superclass from which the class inherits.</p>

<p><code>NSObject</code> contains an instance variable named <code>isa</code> which points at the class that created it. For example, <code>MYPerson</code>&#39;s <code>isa</code> variable would point to <code>MYPerson</code>. When a message is sent to an object, it checks the <code>isa</code> pointer to see if the class it points to defines such a method, if not, the search continues up the inheritance hierarchy. If the search reaches the top (<code>NSObject</code>) and the method is still not found, an error is emitted specifying that an &quot;unrecognized selector sent to instance.&quot; This method lookup is what facilitates method overriding.</p>

<p>The <code>%@</code> token in format strings passed to <code>NSLog</code> for example cause a <code>description</code> message to be sent to the target object. <code>NSObject</code> defines this method which simply returns the object&#39;s address formatted as a string. It can be overridden in a subclass to provide more useful information.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">@implementation</span> <span class="nc">MYPerson</span>

<span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;&lt;Person %@&gt;&quot;</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">name</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></figure>
<p>Forward declarations are possible with the <code>@class</code> keyword.</p>

<p>When a <code>@property</code> is defined on a class without a corresponding manually-defined instance variable, subclasses aren&#39;t able to access the synthesized instance variable directly; they must do so via the accessors. For example, given:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">@interface</span> <span class="nc">MYPerson</span> : <span class="bp">NSObject</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">friends</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@interface</span> <span class="nc">MYEmployee</span> : <span class="nc">MYPerson</span>
<span class="p">{</span>
  <span class="err">…</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre></figure>
<p>Then a subclass <code>MYEmployee</code> cannot access <code>_friends</code> directly; it must do so via an explicit accessor or dot notation.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">@implementation</span> <span class="nc">MYEmployee</span>

<span class="err">…</span>

<span class="p">[</span><span class="n">_friends</span> <span class="nl">addObject</span><span class="p">:</span><span class="s">@&quot;Bob&quot;</span><span class="p">];</span>     <span class="c1">// Error</span>

<span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">friends</span> <span class="nl">addObject</span><span class="p">:</span><span class="s">@&quot;Bob&quot;</span><span class="p">];</span> <span class="c1">// Ok</span>
</code></pre></figure><h1 id="ownership">
<span class="hash">#</span>
<a href="#ownership" class="header-link">Ownership</a>
</h1>
<p>An object that contains a pointer to another object is said to own that object. Due to reference counting, the owned object knows how many owners it has through its reference count.</p>

<p>The <code>dealloc</code> method is run when an instance of a class is deallocated because it has no owners.</p>
<h1 id="class-extensions">
<span class="hash">#</span>
<a href="#class-extensions" class="header-link">Class Extensions</a>
</h1>
<p>Private internal methods, instance variables, and properties should be defined in a <em>class extension</em>, which is a set of private declarations that only the class or instances of it can use. A class interface is denoted by a typical <code>@interface</code> block with an empty parentheses pair at the end. By convention class extensions are declared in the implementation file, before the <code>@implementation</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="cp">#import &quot;MYPerson.h&quot;</span>

<span class="k">@interface</span> <span class="nc">MYPerson</span> <span class="p">()</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">)</span> <span class="kt">int</span> <span class="n">somePrivateVariable</span><span class="p">;</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">MYPerson</span>

<span class="err">…</span>

<span class="k">@end</span>
</code></pre></figure>
<p>An <a href="#classes">earlier example</a> demonstrated that it&#39;s possible to have a manually-defined instance variable differ in the type of a separate property of the same name. However, doing that can be confusing, and instead it&#39;s recommended to use a private class extension to define the manually-defined instance variable.</p>

<p>Since the class extension is defined in the implementation file, and subclasses <code>#import</code> the header file, subclasses won&#39;t have access to the superclass&#39; class extensions.</p>
<h1 id="reference-counting">
<span class="hash">#</span>
<a href="#reference-counting" class="header-link">Reference Counting</a>
</h1>
<p>A Strong reference cycle represents a potential for a memory leak, because the garbage collector cannot deallocate either side of the cycle. A strong reference cycle can be weakened with a <em>weak reference</em> which is a pointer that does not imply ownership. This is useful in a parent-child relationship, in which case the child should hold a weak reference to the parent, since the parent is what owns the child.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">@interface</span> <span class="nc">TreeNode</span> : <span class="bp">NSObject</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">weak</span><span class="p">)</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></figure>
<p>When the targets of weak pointers are deallocated, the weak pointer is set to <code>nil</code>.</p>

<p>Weak points can be explicitly created with the <code>__weak</code> keyword:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">__weak</span> <span class="n">MYPerson</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
</code></pre></figure>
<p>Before ARC, manual reference counting was necessary using the <code>retain</code> and <code>release</code> methods. For example, in a setter, the passed object was <code>retain</code>ed to increment its reference count and the previously-held object was <code>release</code>d to decrease its reference count, then the pointer was set to the new object:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setPerson:</span><span class="p">(</span><span class="n">MYPerson</span> <span class="o">*</span><span class="p">)</span><span class="nv">newPerson</span>
<span class="p">{</span>
  <span class="p">[</span><span class="n">newPerson</span> <span class="k">retain</span><span class="p">];</span>
  <span class="p">[</span><span class="n">_person</span> <span class="k">release</span><span class="p">];</span>
  <span class="n">_person</span> <span class="o">=</span> <span class="n">newPerson</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>Furthermore, the <code>dealloc</code> call had the responsibility of <code>release</code>ing all held objects and <code>dealloc</code>ating the immediate superclass.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
<span class="p">{</span>
  <span class="p">[</span><span class="n">_holder</span> <span class="k">release</span><span class="p">];</span>
  <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></figure>
<p>Newly created and returned objects would be marked as <code>autorelease</code>, i.e. <code>release</code> sometime in the future. For example, the <code>description</code> method creates and returns a new <code>NSString</code>, so it was marked for <code>autorelease</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span>
<span class="p">{</span>
  <span class="bp">NSString</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat</span><span class="p">:</span><span class="s">@&quot;Person: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="n">name</span><span class="p">]];</span>

  <span class="p">[</span><span class="n">result</span> <span class="n">autorelease</span><span class="p">];</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>Specifically the object was sent the <code>release</code> message when the current autorelease pool was drained:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSAutoreleasePool</span> <span class="o">*</span><span class="n">arp</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSAutoreleasePool</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

<span class="bp">NSString</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">MyPerson</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="n">description</span><span class="p">];</span>

<span class="p">[</span><span class="n">arp</span> <span class="n">drain</span><span class="p">];</span> <span class="c1">// `desc` sent `release` message</span>
</code></pre></figure>
<p>The syntax sugar <code>@autoreleasepool</code> can be used to automatically create an autorelease pool and drain it at the end of the provided block.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">@autoreleasepool</span> <span class="p">{</span>
  <span class="bp">NSString</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">MyPerson</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="n">description</span><span class="p">];</span>
<span class="p">}</span> <span class="c1">// drained here</span>
</code></pre></figure>
<p>There are a couple of rules of thumb for manual reference counting:</p>

<ul>
<li><p>Creating an object using a method starting with <code>alloc</code>, <code>new</code>, or containing <code>copy</code> gives you ownership of it. Assume refcount = 1, not in autorelease pool.</p></li>
<li><p>Objects created by any other means are not owned by you. Assume refcount = 1, in autorelease pool.</p></li>
<li><p>Take ownership by <code>retain</code>ing it.</p></li>
<li><p>Relinquish ownership by using <code>release</code> or <code>autorelease</code>.</p></li>
<li><p>Objects exist as long as they have an owner.</p></li>
</ul>

<p>This explains why the <code>NSString</code> returned by <code>description</code> is <code>autorelease</code>d: because although it created the object via <code>alloc</code>-<code>init</code> and thus gained ownership of it, it is giving it away by returning it. Sending it a <code>release</code> message would immediately decrement its refcount, thereby deallocating it, so instead it is <code>autorelease</code>d.</p>
<h1 id="collections">
<span class="hash">#</span>
<a href="#collections" class="header-link">Collections</a>
</h1>
<p>Sets are represented by <code>NSSet</code> and <code>NSMutableSet</code>.</p>

<p>Collection methods which test for equality contain variants containing the word <code>Identical</code> which test if the objects are the same object by testing the pointers for equality, e.g. <code>indexOfObject:</code> vs <code>indexOfObjectIdenticalTo:</code>.</p>

<p>Dictionaries are represented by <code>NSDictionary</code> and <code>NSMutableDictionary</code>. Dictionaries can be created from literal syntax <code>@{…}</code>. A dictionary can be keyed using subscript notation, for example:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSDictionary</span> <span class="o">*</span><span class="n">ages</span> <span class="o">=</span> <span class="l">@{</span>
  <span class="s">@&quot;John&quot;</span><span class="o">:</span> <span class="mi">@20</span><span class="p">,</span>
  <span class="s">@&quot;Jane&quot;</span><span class="o">:</span> <span class="mi">@21</span><span class="p">,</span>
<span class="l">}</span><span class="p">;</span>

<span class="bp">NSNumber</span> <span class="n">johnAge</span> <span class="o">=</span> <span class="n">ages</span><span class="p">[</span><span class="s">@&quot;John&quot;</span><span class="p">];</span>
</code></pre></figure>
<p>Mutable arrays can be sorted using:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sortUsingDescriptors:</span><span class="p">(</span><span class="bp">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">sortDescriptors</span><span class="p">;</span>
</code></pre></figure>
<p>A sort descriptor is an object of type <code>NSSortDescriptor</code> which specifies a property of the sorted element---any instance variable or the result of any method of the object---and whether to sort it in ascending or descending order. <code>sortUsingDescriptors:</code> takes an array of sort descriptors so that in the event of equality, the next descriptor is used. For example, to sort by the property <code>lastName</code> in ascending order, the following descriptor may be used:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSSortDescriptor</span> <span class="o">*</span><span class="n">lastAscending</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSSortDescriptor</span> <span class="nl">sortDescriptorWithKey</span><span class="p">:</span><span class="s">@&quot;lastName&quot;</span>
                                                                <span class="nl">ascending</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</code></pre></figure>
<p>Collections can be filtered given a predicate of type <code>NSPredicate</code>. The filtering is done in-place on an <code>NSMutableArray</code> via <code>filterUsingPredicate:</code> whereas a copy is created for <code>NSArray</code> via <code>filteredArrayUsingPredicate:</code>. The predicate can be constructed <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Predicates/AdditionalChapters/Introduction.html">from a string</a> representing the condition:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSPredicate</span> <span class="o">*</span><span class="n">pred</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSPredicate</span> <span class="nl">predicateWithFormat</span><span class="p">:</span><span class="s">@&quot;person.age &gt; 18&quot;</span><span class="p">];</span>
<span class="bp">NSArray</span> <span class="o">*</span><span class="n">adults</span> <span class="o">=</span> <span class="p">[</span><span class="n">people</span> <span class="nl">filteredArrayUsingPredicate</span><span class="p">:</span><span class="n">pred</span><span class="p">];</span>
</code></pre></figure>
<p>An <code>NSNumber</code> is essentially a boxed number type which is used to wrap numbers so that they can be stored in collections such as <code>NSDictionary</code>. They can be constructed using <code>NSNumber</code> literals such as <code>@2</code>.</p>

<p>The <code>NSValue</code> type can be used to box/wrap arbitrary types such as structs.</p>

<p>It&#39;s not possible to insert <code>nil</code> into a collection. In order to represent a &quot;hole&quot; in a collection, the <code>NSNull</code> class can be used.</p>
<h1 id="enumerations">
<span class="hash">#</span>
<a href="#enumerations" class="header-link">Enumerations</a>
</h1>
<p>The <code>NS_ENUM()</code> preprocessor macro can be used to specify the enumeration&#39;s backing data type and name.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ColorRed</span><span class="p">,</span>
  <span class="n">ColorBlue</span><span class="p">,</span>
  <span class="n">ColorGreen</span>
<span class="p">};</span>
</code></pre></figure><h1 id="nserror">
<span class="hash">#</span>
<a href="#nserror" class="header-link">NSError</a>
</h1>
<p>Some methods may fail for any reason. By convention, the error is returned through a parameter which is a pointer to a pointer to an <code>NSError</code>. That is, the parameter type is <code>NSError **</code>, but the caller can simply create a <code>NSError *</code> and return a pointer to it via <code>&amp;error</code>. Methods that can take an <code>NSError</code> pointer parameter always return a value indicating whether or not there was an error.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>

<span class="kt">BOOL</span> <span class="n">success</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="nl">someArgument</span><span class="p">:</span><span class="s">@&quot;test&quot;</span> <span class="nl">error</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;failed: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">error</span> <span class="n">localizedDescription</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></figure><h1 id="nsdata">
<span class="hash">#</span>
<a href="#nsdata" class="header-link">NSData</a>
</h1>
<p>The <code>NSData</code> class represents a buffer of bytes. The data can be written to a file using <code>writeToFile:options:error</code>. The option <code>NSDataWritingAtomic</code> ensures an atomic write operation.</p>

<p>It&#39;s possible to obtain the standard path for a given task by using the <code>NSSearchPathForDirectoriesInDomains</code> method. For example, to get the desktop directory:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSArray</span> <span class="o">*</span><span class="n">desktops</span> <span class="o">=</span>
  <span class="n">NSSearchPathForDirectoriesInDomains</span><span class="p">(</span><span class="n">NSDesktopDirectory</span><span class="p">,</span> <span class="n">NSUserDomainMask</span><span class="p">,</span> <span class="nb">YES</span><span class="p">);</span>

<span class="bp">NSString</span> <span class="o">*</span><span class="n">desktopPath</span> <span class="o">=</span> <span class="n">desktops</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</code></pre></figure><h1 id="callbacks">
<span class="hash">#</span>
<a href="#callbacks" class="header-link">Callbacks</a>
</h1>
<p>Callbacks in Objective-C can take on four forms:</p>

<ol>
<li><em>Target-action</em>: Specify an object (target) and a message to send it (action).</li>
<li><em>Helper objects</em>: Specify objects which do the required work. These objects are also known as <em>delegates</em> or <em>data sources</em>.</li>
<li><em>Notifications</em>: An object subscribes to the notification center for a particular kind of notification.</li>
<li><em>Blocks</em>: Essentially a lambda meant to run when the event is triggered.</li>
</ol>

<p>Events happen within the context of a run loop of type <code>NSRunLoop</code>.</p>

<p>The potential for strong reference cycles is high in most callback schemes. For example, an object may have a pointer to the object that will call it back, and that object contains a pointer to the object so that it <em>can</em> call it back. To mitigate this:</p>

<ul>
<li><p>Notifications don&#39;t own their observers. Observers remove themselves from the notification center in their <code>dealloc</code> method via <code>removeObserver:</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
  <span class="p">[[</span><span class="bp">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">removeObserver</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></figure></li>
<li><p>Objects don&#39;t own their delegates/data sources. Delegates/data sources remove themselves in their <code>dealloc</code> method.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">delegator</span> <span class="nl">setDelegate</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></figure></li>
<li><p>Objects don&#39;t own their targets. Target objects should remove themselves in their <code>dealloc</code> method.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">button</span> <span class="nl">setTarget</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></figure></li>
</ul>
<h2 id="selectors">
<span class="hash">#</span>
<a href="#selectors" class="header-link">Selectors</a>
</h2>
<p>Each method name that the compiler encounters is given a unique number known as a <em>selector</em> which is used to perform method lookup. The <code>@selector(…)</code> directive is replaced by the compiler with the selector for the given method.</p>
<h2 id="target-action">
<span class="hash">#</span>
<a href="#target-action" class="header-link">Target-action</a>
</h2>
<p>Action methods are the methods invoked by a target-action combination, and they always take a single argument consisting of the object that sent the message.</p>

<p>Timers of type <code>NSTimer</code> use the target-action pattern to specify what message to send to what object every time the timer triggers. For example, the timer below will send the message <code>actionMethod</code> to <code>someObject</code> every 2 seconds.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSTimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span>
  <span class="p">[</span><span class="bp">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="mf">2.0</span>
                                   <span class="nl">target</span><span class="p">:</span><span class="n">someObject</span>
                                 <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">actionMethod</span><span class="p">:)</span>
                                 <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span>
                                  <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</code></pre></figure>
<p>Unused variable warnings can be explicitly silenced by using the <code>__unused</code> keyword as a prefix to the type:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="n">__unused</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;John&quot;</span><span class="p">;</span>
</code></pre></figure>
<p>When sending one callback to one object, Apple uses target-action.</p>
<h2 id="helper-objects">
<span class="hash">#</span>
<a href="#helper-objects" class="header-link">Helper Objects</a>
</h2>
<p>Helper objects implement methods used to do different kinds of work. For example, asynchronous usage of <code>NSURLConnection</code> requires a helper object which defines methods to do work in response to new data, authentication, handle failure, etc.</p>

<p>For example, in the code below, the connection is configured to use object <code>logger</code> as its delegate, which defines methods which are invoked in response to specific events, such as <code>connectionDidFinishLoading:</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="bp">NSURLConnection</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span>
  <span class="p">[[</span><span class="bp">NSURLConnection</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithRequest</span><span class="p">:</span><span class="n">request</span>
                                  <span class="nl">delegate</span><span class="p">:</span><span class="n">logger</span>
                          <span class="nl">startImmediately</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</code></pre></figure>
<p>The methods expected by an <code>NSURLConnection</code> are defined in a protocol---a list of method declarations. A protocol is implemented by specifying its name in angle brackets following the superclass in the <code>@interface</code> line:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">@interface</span> <span class="nc">MYLogger</span> : <span class="bp">NSObject</span> <span class="o">&lt;</span><span class="bp">NSURLConnectionDelegate</span><span class="p">,</span> <span class="bp">NSURLConnectionDataDelegate</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="err">…</span>
<span class="p">}</span>
</code></pre></figure>
<p>When sending various callbacks to one object, Apple uses a helper object with a protocol.</p>
<h2 id="notifications">
<span class="hash">#</span>
<a href="#notifications" class="header-link">Notifications</a>
</h2>
<p>Various objects can subscribe to certain notifications using the notification center <code>NSNotificationCenter</code>. For example, the code below subscribes the <code>logger</code> object to a notification for when the time zone is changed, and it&#39;s configured to invoke the <code>zoneChange:</code> method. It&#39;s also possible to specify that only notifications sent from a particular object are to be considered.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="p">[[</span><span class="bp">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span>
  <span class="nl">addObserver</span><span class="p">:</span><span class="n">logger</span>
     <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">zoneChange</span><span class="p">:)</span>
         <span class="nl">name</span><span class="p">:</span><span class="n">NSSystemTimeZoneDidChangeNotification</span>
       <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</code></pre></figure><h1 id="blocks">
<span class="hash">#</span>
<a href="#blocks" class="header-link">Blocks</a>
</h1>
<p>Blocks are essentially lambdas. They are prefixed by a caret <code>^</code> followed by optional parameter list and, followed by braces surrounding the body.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="o">^</span><span class="p">{</span>
  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;No parameters.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
 <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>Blocks can be stored in a variable, in which case their type must be explicitly typed. Block types look like function pointer types except that they use <code>^</code> to denote a block rather than <code>*</code> to denote a pointer.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">devowelizer</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="n">NSUInteger</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="p">);</span>
</code></pre></figure>
<p>Anonymous blocks are ones that are passed directly to a method without first giving them a name by storing them in a variable.</p>

<p><em>External variables</em> are those that are captured by the block from the outer scopes. Primitive variables are copied as local variables within the block. Pointers are kept as strong references to ensure that they live at least as long as the block itself.</p>

<p>Since pointers are captured as strong references, it&#39;s easy to inadvertently create a strong reference cycle. This can happen implicitly when an instance variable is used directly within a block, because directly accessing an instance variable <code>_var</code> gets translated to <code>self-&gt;_var</code> by the compiler.</p>

<p>The cycle can be broken by first creating a <code>__weak</code> pointer to <code>self</code>, then using that within the block. However, this would mean that <code>self</code> could be deallocated while the block is executing. To prevent that, a strong reference to the <code>__weak</code> pointer can be created:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">__weak</span> <span class="n">MYPerson</span> <span class="o">*</span><span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>

<span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
  <span class="n">MYPerson</span> <span class="o">*</span><span class="n">innerSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Person: %@&quot;</span><span class="p">,</span> <span class="n">innerSelf</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></figure>
<p>Instance variables should be accessed through the <code>innerSelf</code> to avoid implicitly and inadvertently capturing <code>self</code>.</p>

<p>Variables captured by a block are constant within the block. In order to modify an external variable within a block, it must be declared as an external variable by using the <code>__block</code> keyword prefix:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-objective-c"><span class="k">__block</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">incrementBlock</span><span class="p">)()</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">count</span><span class="o">++</span> <span class="p">};</span>
</code></pre></figure></div>
  <div class="meta">
    <div class="meta-component"><i class="fa fa-calendar fa-fw"></i> June 21, 2016</div>
    <div class="meta-component"><i class="fa fa-code-fork fa-fw"></i> <a href="https://github.com/blaenk/site/commits/master/input/notes/objective-c.markdown">History</a><span class="hash">, <a href="https://github.com/blaenk/site/commit/a3b3ded" title="blocks">a3b3ded</a></span></div>
    <div class="meta-component"><i class="fa fa-pencil fa-fw"></i> <a href="..">Notes</a></div>
  </div>
</article>



    
    <footer id="footer">
  <div id="social">
    <a href="https://github.com/blaenk" title="github"><i class="fa fa-github-alt"></i></a>
    &middot;
    <a href="http://stackoverflow.com/users/101090/jorge-israel-pena" title="stackoverflow"><i class="fa fa-stack-overflow"></i></a>
    &middot;
    <a href="https://twitter.com/blaenk" title="twitter"><i class="fa fa-twitter"></i></a>
    &middot;
    <a href="mailto:jorge.israel.p@gmail.com" title="email"><i class="fa fa-envelope"></i></a>
    &middot;
    <a href="/rss.xml" title="feed"><i class="fa fa-rss-square"></i></a>
  </div>
  <!-- <div id="credit">
    Designed by <a href="http://www.blaenkdenum.com">Jorge Israel Peña</a>
  </div> -->
</footer>


<!-- this should instead be something like connectWS("{{{path}}}") -->


<script type="text/javascript">
  jQuery(function (){
    var ws = new WebSocket('ws://' + window.location.hostname + ':9160/notes/objective-c.markdown');

    ws.onmessage = function (e) {
      var content = jQuery('article .entry-content');
      content.html(e.data);

      window.refresh();

      MathJax.Hub.Queue(["Typeset", MathJax.Hub, jQuery('article .entry-content')[0]]);

      if (window.jumpDown)
        window.scrollDown();
    };
  });
</script>




<!-- google analytics -->
<script async="true" type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37339861-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

<!--MathJax CDN-->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    messageStyle: "none"
  });

  MathJax.Hub.Register.MessageHook('End Process', function() {
    jQuery('#MathJax_Font_Test').empty();
    jQuery('.MathJax_Display').parent().addClass('mathjax');
  });
</script>

  </div>
</body>
</html>
