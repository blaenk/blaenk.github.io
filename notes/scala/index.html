<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Scala - Blaenk Denum</title>
  <meta name="author" content="Jorge Israel Peña">
  <meta name="description" content="AKA Blaenk Denum">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="/favicon.png" rel="shortcut icon">
  <link href='http://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Merriweather:900italic,900,700italic,400italic,700,400,300italic,300' rel='stylesheet' type='text/css'>
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='/css/screen.css' rel='stylesheet' type='text/css' media='screen' />
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src='/js/blaenk.js' type='text/javascript'></script>
</head>
<body>
  <div class="page-wrapper">
    <header id="header">
  <div id="stamp">
    <h1 id="name">
      <a href="/">
        <span class="emboldened">Jorge</span>.Israel.<span class="emboldened">Peña</span>
      </a>
    </h1>
    <h4 id="pseudonym">
      AKA <span class="emboldened">Blaenk</span>.Denum
    </h4>
  </div>
  <nav id="main-nav">
    <ul class="main">
      <li><a href="/about/">About</a></li>
      <li><a href="/work/">Work</a></li>
      <li><a href="/lately/">Lately</a></li>
      <li><a href="/notes/">Notes</a></li>
      <li><a id="search_btn">Search</a></li>
    </ul>
  </nav>
  <nav id="mobile-nav">
    <div class="menu">
      <a class="button">Menu</a>
      <div class="container">
        <ul class="main">
          <li><a href="/about/">About</a></li>
          <li><a href="/work/">Work</a></li>
          <li><a href="/lately/">Lately</a></li>
          <li><a href="/notes/">Notes</a></li>
        </ul>
      </div>
    </div>
    <div class="search">
      <a class="button"></a>
      <div class="container">
        <form action="http://google.com/search" method="get">
          <input type="text" name="q" results="0">
          <input type="hidden" name="q" value="site:blaenkdenum.com">
        </form>
      </div>
    </div>
  </nav>
</header>
<form class="desk_search" action="http://google.com/search" method="get">
  <input id="search" type="text" name="q" results="0" placeholder="Search" autocomplete="off" spellcheck="false">
  <input type="hidden" name="q" value="site:blaenkdenum.com">
</form>

    <article class="post">
  <h2 class="title"><a href="/notes/scala/"><span>Scala</span></a></h2>
  <div class="entry-content"><p>I’ve been meaning to learn Scala for some time. Haskell has really left me wanting to program in a very functional style, and it seems like Scala is used more in the industry than Haskell. Scala seems to provide a decent compromise in a language that mixes object-oriented programming with functional programming characteristics. Furthermore, the <abbr title="Java Virtual Machine">JVM</abbr> is battle-tested and probably the most robust virtual machine of any language out there at the moment.</p>
<nav id="toc"><h3>Contents</h3><ol><li><a href="#basics">Basics</a></li><li><a href="#classes-and-objects">Classes and Objects</a></li><li><a href="#functions">Functions</a><ol><li><a href="#partial-application">Partial Application</a></li></ol></li><li><a href="#composition-and-inheritance">Composition and Inheritance</a></li><li><a href="#hierarchy">Hierarchy</a></li><li><a href="#traits">Traits</a></li><li><a href="#packages">Packages</a></li><li><a href="#testing">Testing</a><ol><li><a href="#behavior-driven-development">Behavior-Driven Development</a></li><li><a href="#property-testing">Property Testing</a></li></ol></li><li><a href="#pattern-matching">Pattern Matching</a></li><li><a href="#tuples">Tuples</a></li><li><a href="#stateful-objects">Stateful Objects</a></li><li><a href="#type-parameterization">Type Parameterization</a><ol><li><a href="#variance">Variance</a></li></ol></li><li><a href="#abstract-members">Abstract Members</a><ol><li><a href="#structural-subtyping">Structural Subtyping</a></li><li><a href="#enumerations">Enumerations</a></li></ol></li><li><a href="#implicit-conversions-and-parameters">Implicit Conversions and Parameters</a><ol><li><a href="#implicit-parameters">Implicit Parameters</a></li></ol></li><li><a href="#lists">Lists</a><ol><li><a href="#list-implementation">Implementation</a></li></ol></li><li><a href="#for-expressions">For Expressions</a><ol><li><a href="#for-expression-translation">Translation</a></li><li><a href="#generalized-for-expressions">Generalized For Expressions</a></li></ol></li><li><a href="#collections-api">Collections API</a><ol><li><a href="#sequences">Sequences</a></li><li><a href="#sets">Sets</a></li><li><a href="#maps">Maps</a></li><li><a href="#streams">Streams</a></li><li><a href="#vectors">Vectors</a></li><li><a href="#ranges">Ranges</a></li><li><a href="#arrays">Arrays</a></li><li><a href="#views">Views</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#java-interop-collections">Java Interop</a></li><li><a href="#collections-architecture">Architecture</a><ol><li><a href="#builders">Builders</a></li><li><a href="#implementation-traits">Implementation Traits</a></li><li><a href="#creating-collections">Creating Collections</a></li></ol></li></ol></li><li><a href="#extractors">Extractors</a><ol><li><a href="#compared-to-case-classes">Compared to Case Classes</a></li><li><a href="#regular-expressions">Regular Expressions</a></li></ol></li><li><a href="#annotations">Annotations</a></li><li><a href="#xml">XML</a></li><li><a href="#modular-programming">Modular Programming</a></li><li><a href="#object-equality">Object Equality</a><ol><li><a href="#wrong-signature">Wrong Signature</a></li><li><a href="#hash-code">Hash Code</a></li><li><a href="#mutable-fields">Mutable Fields</a></li><li><a href="#equivalence-relation">Equivalence Relation</a></li><li><a href="#subtype-equality">Subtypes</a></li></ol></li><li><a href="#java-interop">Java Interop</a><ol><li><a href="#existential-types">Existential Types</a></li><li><a href="#compiling-heterogenous-projects">Compiling Heterogenous Projects</a></li></ol></li><li><a href="#actors-and-concurrency">Actors and Concurrency</a></li></ol></nav>
<h1 id="basics">Basics</h1>
<p>The syntax for a function definition is:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span>
</code></pre></figure>
<p>If a function only takes one parameter, it can be called without parentheses. Functions can use special characters such as <code>+</code> and <code>-</code>, and can transform:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
<span class="o">(</span><span class="mi">1</span><span class="o">).+(</span><span class="mi">2</span><span class="o">)</span>
</code></pre></figure>
<p>In fact, any function that takes at least two parameters can be called in infix operator notation. If it takes more than two parameters, the right hand side should apply those within parentheses.</p>
<p>A unary operator can be defined by defining a method with <code>unary_</code> prepending the name.</p>
<p>If the function ends with <code>:</code>, then the code is transformed in reverse:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">a</span> <span class="o">::</span> <span class="n">b</span>
<span class="n">b</span><span class="o">.::(</span><span class="n">a</span><span class="o">)</span>
</code></pre></figure>
<p>A class can be defined as:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">MyClass</span><span class="o">(</span><span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</code></pre></figure>
<p>This also defines a constructor that takes integer and string parameters.</p>
<p>Values can be defined in two ways: <code>val</code> are immutable values and <code>var</code> are mutable variables.</p>
<p>Arrays are indexed using parentheses, not brackets as in other languages. They’re defined as:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">strings</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
<span class="n">strings</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="n">strings</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;World&quot;</span>

<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">print</span><span class="o">(</span><span class="n">strings</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</code></pre></figure>
<p>Lambdas are of the form:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">args</span><span class="o">.</span><span class="n">foreach</span><span class="o">((</span><span class="n">arg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
</code></pre></figure>
<p>Though Scala allows partial function application, so the above can be shortened to:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">args</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></figure>
<p>When parentheses are applied to a variable with one or more parameters, Scala transforms the code into an invocation of the <code>apply</code> method on that variable:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">strings</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="n">strings</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
</code></pre></figure>
<p>On the other hand, when a variable with applied parentheses and arguments is assigned to, the code is transformed to a call to the <code>update</code> method:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">strings</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;assignment&quot;</span>
<span class="n">strings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="s">&quot;assignment&quot;</span><span class="o">)</span>
</code></pre></figure>
<p>In Scala, Arrays are mutable while Lists are immutable. With Lists, <code>::</code> is cons and <code>::​:</code> is concatenation.</p>
<p>Tuples are declared in the usual form, as in Haskell. However, elements are accessed using <code>_n</code> where n is the 1-based number of the element.</p>
<p>The <code>-&gt;</code> method returns a two-element tuple of the left and right parameters, and is used for example to insert items into a <code>Map</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">treasureMap</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;Go to island&quot;</span><span class="o">)</span>
</code></pre></figure>
<p>The <code>Unit</code> type is equivalent to Haskell’s <code>()</code> or <code>void</code> in C++.</p>
<p>Scala has symbols similar to Ruby’s <code>:symbols</code> which are defined as:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">someKey</span> <span class="k">=</span> <span class="-Symbol">&#39;symbol</span>
</code></pre></figure>
<p>The <code>yield</code> keyword can be used in conjunction with <code>for</code> loops to generate new collections:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">shouts</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span> <span class="k">yield</span> <span class="n">arg</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
</code></pre></figure>
<p>Raw strings are possible by using three successive double quote delimiters:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">rawstr</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;\d+&quot;&quot;&quot;</span>
</code></pre></figure>
<h1 id="classes-and-objects">Classes and Objects</h1>
<p>Objects have members consisting of fields (data) and methods (code). Fields can be declared private.</p>
<p>If you assign an object to a <code>val</code>, you can mutate the object but not reassign the <code>val</code> to another object. Unit methods can leave off the result type and the equals sign:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span>
<span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span> <span class="o">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span> <span class="o">}</span>
</code></pre></figure>
<p>The semicolon insertion rules state that a semicolon is inserted at the end of a line if:</p>
<ol type="1">
<li>the line ends in a word that would not be legal as the end of a statement (e.g. period or infix operator)</li>
<li>next line begins with a word that cannot start a statement</li>
<li>line ends while inside parentheses or brackets, because these cannot contain multiple statements anyway</li>
</ol>
<p>Singleton objects are defined using the <code>object</code> keyword and their members are as if <code>static</code> members of C++ classes. These cannot be instantiated.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">object</span> <span class="nc">Singleton</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">num</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
</code></pre></figure>
<p>When a singleton object is named after an existing class, it is referred to as the class’ <em>companion object</em> <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. They must both be defined in the same source file. They can access each other’s private members.</p>
<p>A class is defined using the class keyword, and it can take parameters:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">den</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></figure>
<p>Any code inside the class body will be put inside the <em>primary constructor</em>.</p>
<p><em>Fields</em>, accessible publicly, are created by defining class-level values:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">den</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numer</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">num</span>
  <span class="k">val</span> <span class="n">denom</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">den</span>
<span class="o">}</span>
</code></pre></figure>
<p><em>Auxiliary constructors</em> are additional constructors that simply directly or indirectly delegate object construction to the primary constructor. They are named after <code>this</code>, and their first action must be invoking another constructor:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">den</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></figure>
<p>Fields and methods can be defined private using the <code>private</code> keyword.</p>
<p><em>Literal identifiers</em> are ones that are enclosed in backticks, so that any string that would be accepted by the runtime will result in an identifier.</p>
<p>Implicit conversions can be defined so that values of a certain time are implicitly converted to another type in order for an operation to go through. For example, if there’s an addition function for <code>Rational</code> that takes a <code>Rational</code> and an Integer, we can do <code>r + 1</code> but not <code>1 + r</code> since that would attempt to invoke the function on the Integer itself. To solve this, we can define an implicit conversion to <code>Rational</code> on Integer:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">implicit</span> <span class="k">def</span> <span class="n">intToRational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</code></pre></figure>
<h1 id="functions">Functions</h1>
<h2 id="partial-application">Partial Application</h2>
<p>It’s not possible to assign methods or nested functions to values, or pass them as arguments to other functions. If this is intended, one can use the explicit partial application syntax:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">partial</span> <span class="k">=</span> <span class="n">some</span><span class="o">.</span><span class="n">method</span> <span class="k">_</span>
</code></pre></figure>
<p>This syntax creates an ephemeral class <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> that defines an <code>apply</code> method that takes the appropriate amount of arguments. When the partially applied value is called, the arguments are forwarded to the underlying function and its result is returned.</p>
<p>This can also be done for specific arguments, but the type must be stated explicitly, presumably to disambiguate overloads:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">partial</span> <span class="k">=</span> <span class="n">func</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="k">_</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></figure>
<p>If passing a partially applied function, where all parameters are unapplied, as an argument to another function, partial application can be written implicitly:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span> <span class="k">_</span><span class="o">)</span>
<span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></figure>
<p>Closures capture values by reference.</p>
<p>Variable arguments can be specified with an asterisk <code>*</code>, and are treated as an <code>Array</code> inside the function:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">echo</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
<span class="n">echo</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">,</span> <span class="s">&quot;three&quot;</span><span class="o">)</span>
</code></pre></figure>
<p>Conversely, an <code>Array</code> can be expanded into multiple arguments using the <code>_*</code> symbol:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">,</span> <span class="s">&quot;three&quot;</span><span class="o">)</span>
<span class="n">echo</span><span class="o">(</span><span class="n">arr</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>
</code></pre></figure>
<p>It’s possible to pass named parameters to functions:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">speed</span><span class="o">(</span><span class="n">distance</span><span class="k">:</span> <span class="kt">Float</span><span class="o">,</span> <span class="n">time</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">time</span>
<span class="n">speed</span><span class="o">(</span><span class="n">time</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">distance</span> <span class="k">=</span> <span class="mi">100</span><span class="o">)</span>
</code></pre></figure>
<p>It’s possible to define default parameter values:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">printTime</span><span class="o">(</span><span class="n">out</span><span class="k">:</span> <span class="kt">java.io.PrintStream</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;time = &quot;</span> <span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">())</span>
</code></pre></figure>
<p>When used in combination with named parameters, it’s possible to leave out all parameters except one.</p>
<p>Scala supports tail recursion.</p>
<p>Currying can be made explicit in a function definition by adding multiple parameter lists. This makes it possible to curry functions without having to specify the type of the holes as in partial application above.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">curriedSum</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="k">val</span> <span class="n">three</span>  <span class="k">=</span> <span class="n">curriedSum</span><span class="o">(</span><span class="mi">1</span><span class="o">)(</span><span class="mi">2</span><span class="o">)</span>

<span class="k">def</span> <span class="n">equivalentSum</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="k">=</span> <span class="n">y</span>
<span class="k">val</span> <span class="n">three_</span> <span class="k">=</span> <span class="n">equivalentSum</span><span class="o">(</span><span class="mi">1</span><span class="o">)(</span><span class="mi">2</span><span class="o">)</span>
</code></pre></figure>
<p>Explicitly defining multiple parameter lists allows using braces for the last parameter:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">braces</span> <span class="k">=</span> <span class="n">curriedSum</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="mi">2</span> <span class="o">}</span>
</code></pre></figure>
<p>Parameters can be passed “by-name” so that parameters can be passed to a function and not evaluated until explicitly done so within the function. The syntax is simply to prepend the parameter with <code>=&gt;</code>, I take this to mean that it’s wrapping the parameter in a parameter-less lambda like <code>()</code> so that the expression passed as the parameter isn’t evaluated until explicitly done so within the function:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">byNameAssert</span><span class="o">(</span><span class="n">predicate</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">assertionsEnabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">predicate</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">AssertionError</span>

<span class="n">byNameAssert</span><span class="o">(</span><span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></figure>
<h1 id="composition-and-inheritance">Composition and Inheritance</h1>
<p>Abstract classes are defined using the abstract keyword:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>
  <span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>
<span class="o">}</span>
</code></pre></figure>
<p>Methods themselves are abstract if they have no defined implementation.</p>
<p>Parameterless methods are those that take no parameters and their parentheses are omitted. The convention is to omit the parentheses when there are no parameters and the method accesses mutable state only by reading its class’ fields. Further, empty parentheses in function calls can be omitted. The convention is to only omit them if they have no side-effects. I/O calls for example should always explicitly contain the parentheses.</p>
<p>Classes can be extended other classes. This allows the sub-class to inherit all non-private members of the parent class, and makes the sub-class a sub-type of the parent type. All classes implicitly extend from <code>scala​.AnyRef</code> which is equivalent to Java’s <code>java​.lang​.Object</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">conts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">conts</span>
<span class="o">}</span>
</code></pre></figure>
<p>Class fields and methods belong to the same namespace, which makes it possible for a subclass to override one with the other:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">conts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">conts</span>
<span class="o">}</span>
</code></pre></figure>
<p>Parametric fields are fields that are initialized through the primary constructor:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span>
  <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span>
</code></pre></figure>
<p>It’s possible to invoke superclass constructors by simply supplying the parameter in the extends section:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">width</span>  <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">height</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">}</span>
</code></pre></figure>
<p>Overriding must be explicitly denoted.</p>
<p>The <code>final</code> keyword can be used to prevent subclass overriding on a particular method:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">A</span> <span class="k">extends</span> <span class="n">B</span> <span class="o">{</span>
  <span class="k">final</span> <span class="k">override</span> <span class="k">def</span> <span class="n">method</span><span class="o">()</span> <span class="o">{</span> <span class="n">println</span> <span class="s">&quot;and that&#39;s final&quot;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>The <code>final</code> keyword can also be used to prevent subclassing of a particular class entirely:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">final</span> <span class="k">class</span> <span class="nc">A</span> <span class="k">extends</span> <span class="n">B</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">method</span><span class="o">()</span> <span class="o">{</span> <span class="n">println</span> <span class="s">&quot;final class&quot;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<h1 id="hierarchy">Hierarchy</h1>
<p>Every class is a direct or indirect subclass of <code>Any</code>, which defines a variety of “universal methods” available to all subclasses. The <code>==</code> method is final and simply calls <code>equals</code>, which is the method that subclasses should override.</p>
<p><code>Any</code> has two direct subclasses. <code>AnyVal</code> is the parent class of every built-in value class in Scala: <code>Byte</code>, <code>Short</code>, <code>Char</code>, <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Boolean</code>, and <code>Unit</code>. These can’t be instantiated with <code>new</code> because they are defined as final and abstract. <code>AnyRef</code> is the base class of all reference classes, it’s just an alias for <code>java​.lang​.Object</code>.</p>
<p>There are two “bottom” types, which are subclasses of every kind of type. <code>Null</code> is the type of the <code>null</code> reference and it inherits from any class that inherits from <code>AnyRef</code>. <code>Nothing</code> is a type that simply signifies abnormal termination. For example, the <code>error</code> function is of type <code>Nothing</code>. Since it’s a subclass of any class, the <code>error</code> function can be called from within any other function regardless of its type.</p>
<h1 id="traits">Traits</h1>
<p>Traits encapsulate methods and fields which can be mixed into other classes <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. Traits are defined as:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">trait</span> <span class="nc">SomeTrait</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">someMethod</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;printing&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>A trait can subclass a certain class, which essentially specifies a constraint on the trait such that it can only be mixed into classes that are or subclass the extended class.</p>
<p>Traits can be mixed in using either the <code>extends</code> or <code>with</code> keywords, multiple mixins are simply chained using <code>with</code>. They also defined types, so a value of a certain trait type can be set to any object whose class mixes-in the particular trait.</p>
<p>Traits can override methods implemented in the classes they’re mixed into. This is accomplished with the <code>abstract override</code> directive. This combination of specifiers conveys the fact that it overrides a method that it’s mixed into (hence <code>override</code>), and therefore that method must be defined in the class it’s mixed into (hence <code>abstract</code>). Methods with these qualifiers can use <code>super</code> to access the class they’re mixed into, specifically the same method they’re overriding:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">BasicIntQueue</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">()</span> <span class="k">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="n">buf</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Doubling</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">override</span> <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>Multiple mixins can be “stacked,” in which case the same function is called in reverse order of the mixin list. That is, the right-most trait is treated as if a “superclass” of the one to its left, and <code>super</code> has that effect.</p>
<h1 id="packages">Packages</h1>
<p>The <code>package</code> statement is used as in Java to specify that what follows is to be part of the specified package. However, it can also be used with braces to only insert the contained code within the package.</p>
<p>The <code>import</code> statement can be used to import packages and symbols in different ways:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">showFruit</span><span class="o">(</span><span class="n">fruit</span><span class="k">:</span> <span class="kt">Fruit</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">fruit._</span>
  <span class="n">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;s are &quot;</span> <span class="o">+</span> <span class="n">color</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// only Apple and Orange</span>
<span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">}</span>

<span class="c1">// everything, but rename Apple to McIntosh</span>
<span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Apple</span> <span class="k">=&gt;</span> <span class="nc">McIntosh</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>

<span class="c1">// everything except Pear</span>
<span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Pear</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>
</code></pre></figure>
<p>Every Scala file implicitly imports the following packages:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">import</span> <span class="nn">java.lang._</span>
<span class="k">import</span> <span class="nn">scala._</span>
<span class="k">import</span> <span class="nn">Predef._</span>
</code></pre></figure>
<h1 id="testing">Testing</h1>
<p>Assertions can be made with <code>assert</code> and enabled in the <abbr title="Java Virtual Machine">JVM</abbr> using the command options <code>-ea</code> (enable assertions) and <code>-da</code>. An alternative function is <code>ensuring</code>, which also takes a predicate. The predicate is a function that takes a so-called “result type” and returns a Boolean. If the predicate returns true, then <code>ensuring</code> returns the “result type,” but if the predicate returns false, then <code>ensuring</code> throws an <code>AssertionError</code>.</p>
<p>Unit testing is possible with tools such as <a href="http://www.scalatest.org">ScalaTest</a> and ScalaCheck. ScalaTest tests are functions with names prefixed by <code>test</code> inside classes that extend <code>Suite</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">import</span> <span class="nn">org.scalatest.Suite</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">class</span> <span class="nc">ElementSuite</span> <span class="k">extends</span> <span class="nc">Suite</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">testUniformElement</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="err">&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">ele</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>ScalaTest has another style of testing with the FunSuite package:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">import</span> <span class="nn">org.scalatest.FunSuite</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">class</span> <span class="nc">ElementSuite</span> <span class="k">extends</span> <span class="nc">FunSuite</span> <span class="o">{</span>
  <span class="n">test</span><span class="o">(</span><span class="s">&quot;elem result should have passed width&quot;</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="err">&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">ele</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>The assertions used in the previous two ScalaTest suites would only show an error that the assertion failed, without showing what the two values were. ScalaTest also provides a <code>===</code> operator that is more descriptive:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">assert</span><span class="o">(</span><span class="n">ele</span><span class="o">.</span><span class="n">width</span> <span class="o">===</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// &quot;3 did not equal 2&quot;</span>
</code></pre></figure>
<p>There is also an <code>expect</code> method that differentiates between the two values:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">expect</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">ele</span><span class="o">.</span><span class="n">width</span>
<span class="o">}</span> <span class="c1">// &quot;Expected 2, but got 3&quot;</span>
</code></pre></figure>
<p>Method <code>intercept</code> can verify that an exception is thrown:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">intercept</span><span class="o">[</span><span class="kt">IllegalArgumentException</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">elem</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="err">&#39;</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></figure>
<h2 id="behavior-driven-development">Behavior-Driven Development</h2>
<p>The <code>FlatSpec</code> is one of many traits, such as <a href="http://www.scalatest.org/getting_started_with_fun_spec"><code>FunSpec</code></a>, that allow for behavior-driven development (<abbr title="Behavior-Driven Development">BDD</abbr>). These traits can be mixed with other traits such as <code>ShouldMatchers</code> which allow the use of the <code>should</code> function to write tests very naturally as in RSpec:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">import</span> <span class="nn">org.scalatest.FlatSpec</span>
<span class="k">import</span> <span class="nn">org.scalatest.matchers.ShouldMatchers</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">class</span> <span class="nc">ElementSpec</span> <span class="k">extends</span> <span class="nc">FlatSpec</span> <span class="k">with</span> <span class="nc">ShouldMatchers</span> <span class="o">{</span>
  <span class="s">&quot;A UniformElement&quot;</span> <span class="n">should</span> <span class="s">&quot;have a width equal to the passed value&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="err">&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
      <span class="n">ele</span><span class="o">.</span><span class="n">width</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="mi">2</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="n">it</span> <span class="n">should</span> <span class="s">&quot;have a height equal to the passed value&quot;</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="err">&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">ele</span><span class="o">.</span><span class="n">height</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">it</span> <span class="n">should</span> <span class="s">&quot;throw an IAE if passed a negative width&quot;</span> <span class="n">in</span> <span class="o">{</span>
    <span class="n">evaluating</span> <span class="o">{</span>
      <span class="n">elem</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="err">&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">}</span> <span class="n">should</span> <span class="n">produce</span> <span class="o">[</span><span class="kt">IllegalArgumentException</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<h2 id="property-testing">Property Testing</h2>
<p><a href="http://www.scalacheck.org/">ScalaCheck</a> is another testing tool that is similar to Haskell’s <a href="http://hackage.haskell.org/package/QuickCheck">QuickCheck</a>, which essentially randomly generates test input data to test with. There is an implication operator <code>==&gt;</code> that takes a function that places a constraint on the test data and a condition that must hold true for all data that fits that constraint:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">import</span> <span class="nn">org.scalatest.WordSpec</span>
<span class="k">import</span> <span class="nn">org.scalatest.prop.Checkers</span>
<span class="k">import</span> <span class="nn">org.scalacheck.Prop._</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">class</span> <span class="nc">ElementSpec</span> <span class="k">extends</span> <span class="nc">WordSpec</span> <span class="k">with</span> <span class="nc">Checkers</span> <span class="o">{</span>
  <span class="s">&quot;elem result&quot;</span> <span class="n">must</span> <span class="o">{</span>
    <span class="s">&quot;have passed width&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="n">check</span><span class="o">((</span><span class="n">w</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">==&gt;</span> <span class="o">(</span><span class="n">elem</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">width</span> <span class="o">==</span> <span class="n">w</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<h1 id="pattern-matching">Pattern Matching</h1>
<p><em>Case Classes</em> are like stub classes which contain and are mainly about publicly accessible data. They’re very similar to Haskell’s algebraic data types (<abbr title="Algebraic Data Type">ADT</abbr>). Consider the following domain specific language (<abbr title="Domain Specific Language">DSL</abbr>):</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
</code></pre></figure>
<p>These case classes define factory methods to avoid having to explicitly write <code>new</code>, fields for the data, simple <code>toString</code> implementations, and a <code>copy</code> method that is very similar to Haskell’s record syntax. For example, the following creates a copy of the <code>op</code> <code>BinOp</code> with the <code>operator</code> field changed to <code>&quot;-&quot;</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">op</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">operator</span> <span class="k">=</span> <span class="s">&quot;-&quot;</span><span class="o">)</span>
</code></pre></figure>
<p>This is equivalent to Haskell’s record syntax:</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="nf">op</span> <span class="p">{</span> <span class="n">operator</span> <span class="ow">=</span> <span class="s">&quot;-&quot;</span> <span class="p">}</span>
</code></pre></figure>
<p>The main use of case classes is pattern matching. For example, a mathematical expression expressed using the <code>Expr</code> <abbr title="Domain Specific Language">DSL</abbr> constructed above can be simplified as follows:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">simplifyTop</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span>
  <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span>  <span class="k">=&gt;</span> <span class="n">e</span>
    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">expr</span>
  <span class="o">}</span>
</code></pre></figure>
<p>This is very similar to other pattern matching features available in Haskell for example. In cases, we can use <em>constructor patterns</em>, <em>constant patterns</em>, and <em>variable patterns</em>. Variable patterns are simply those that begin with lower case characters, but we can force a lowercase identifier to be treated as a constant by surrounding it with backticks.</p>
<p>It’s also to use <em>sequence patterns</em>. In this case, the <code>_*</code> operator can be used to specify “the rest of the sequence,” like so:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;found it&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</code></pre></figure>
<p>It’s also possible to use <em>type patterns</em> to match the type of the expression:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">generalSize</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
  <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
<span class="o">}</span>
</code></pre></figure>
<p><em>Type Erasure</em> means that information about type arguments is not maintained at runtime. This is an artifact of the erasure model of generics that Java uses. As a result, it’s not possible to pattern match on the type of <code>Map</code>, and the following code will return <code>true</code> for any <code>Map</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">isIntToIntMap</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</code></pre></figure>
<p>It’s possible to use <code>@</code> for <em>variable binding</em> in pattern matching, just as in Haskell:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;abs&quot;</span><span class="o">,</span> <span class="n">e</span> <span class="k">@</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;abs&quot;</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</code></pre></figure>
<p><em>Pattern guards</em> are additional conditions placed on pattern matches. For example, to simplify an addition expression with identical operands to a multiplication by two, we can use:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">simplifyAdd</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">=&gt;</span>
    <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span>
<span class="o">}</span>
</code></pre></figure>
<p>A <em>sealed class</em> is one that restricts subclassing of that class to the file it’s defined in. This way the compiler can guarantee and enforce exhaustive pattern matching, which it couldn’t do otherwise because the class could be extended in another file:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span>
</code></pre></figure>
<p>If there’s a function that is known to only handle a specific subset of subtypes, a catchall case can be added, or the <code>@unchecked</code> annotation can be used:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">@unchecked</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a number&quot;</span>
  <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>    <span class="s">&quot;a variable&quot;</span>
<span class="o">}</span>
</code></pre></figure>
<p>The <code>Option</code> type is equivalent to Haskell’s <code>Maybe</code> type. It can take on either a parameterized <code>Some</code> value or <code>None</code>.</p>
<p><a name="case-sequence"></a> A <em>case sequence</em> is a function literal specific defined as a pattern match where each case is an entry point to the function:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">withDefault</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="mi">0</span>
<span class="o">}</span>
</code></pre></figure>
<p>This is why it’s possible to pass a pattern match directly to the <code>react</code> function in the actors library:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">react</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">actor</span><span class="k">:</span> <span class="kt">Actor</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="n">actor</span> <span class="o">!</span> <span class="n">getip</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
    <span class="n">act</span><span class="o">()</span>
  <span class="o">}</span>
  <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Unhandled message: &quot;</span> <span class="o">+</span> <span class="n">msg</span><span class="o">)</span>
    <span class="n">act</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>If a case sequence doesn’t provide exhaustive patterns, it is considered a <em>partial function</em> since it doesn’t provide an output for every input. If it’s applied to a value that it can’t match, it throws a run-time exception.</p>
<p>The parameterized type <code>PartialFunction</code> can represent partial functions:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">second</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">y</span>
<span class="o">}</span>
</code></pre></figure>
<p>The function <code>isDefinedAt</code> can then be used to determine if the function is defined for a particular value:</p>
<figure class="codeblock"><pre><code class="highlight language-text">scala&gt; second.isDefinedAt(List(5, 6, 7))
res0: Boolean = true
scala&gt; second.isDefinedAt(List())
res0: Boolean = false</code></pre></figure>
<p>The partial function above gets translated to:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">new</span> <span class="nc">PartialFunction</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">y</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">isDefinedAt</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">true</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>The actors library’s <code>react</code> function for example uses partial a partial argument function, since it’s defined only for the messages teh caller wants to handle.</p>
<h1 id="tuples">Tuples</h1>
<p>Tuples are the same as in Haskell, C++11, Python etc. They are indexed using <code>._n</code> where <code>n</code> it the nth tuple element. A difference from something like Python is that the following:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">word</span><span class="o">,</span> <span class="n">index</span> <span class="k">=</span> <span class="n">longest</span>
</code></pre></figure>
<p>Where <code>longest</code> is a tuple, ends up assigning the tuple to both <code>word</code> and <code>index</code>, contrary to what happens in Python. To assign the correct elements as in C++11’s <code>std​::tie</code>, use parentheses to pattern match as in Haskell.</p>
<h1 id="stateful-objects">Stateful Objects</h1>
<p>Scala has support for something similar to C# properties. When a non-private <code>var</code> is defined in a class, a pair of getter and setters is automatically generated for that variable. For example, given the following declaration:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Time</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">hour</span>   <span class="k">=</span> <span class="mi">12</span>
  <span class="k">var</span> <span class="n">minute</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
</code></pre></figure>
<p>Changes the variable to be <code>private​[this]</code> so that it’s only accessible from the object itself, and the getters and setters take on the visibility of the original variable, this in effect restricts all external access to its generated getters and setters. The setter takes the form <code>x_=(arg)</code> <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Time</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">h</span> <span class="k">=</span> <span class="mi">12</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">m</span> <span class="k">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">h</span>
  <span class="k">def</span> <span class="n">hour_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="n">h</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>

  <span class="k">def</span> <span class="n">minute</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">m</span>
  <span class="k">def</span> <span class="n">minute_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="n">m</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>These getters and setters can be defined explicitly in order to encode things such as input validation:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Time</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">h</span> <span class="k">=</span> <span class="mi">12</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">m</span> <span class="k">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">h</span>
  <span class="k">def</span> <span class="n">hour_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="o">)</span>
    <span class="n">h</span> <span class="k">=</span> <span class="n">x</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">minute</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">m</span>
  <span class="k">def</span> <span class="n">minute_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="o">)</span>
    <span class="n">m</span> <span class="k">=</span> <span class="n">x</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>It’s also possible to define getters and setters that aren’t backed by a variable, which is particularly useful for converter functions, for example. Note that in the following example, <code>_</code> is used to give the <code>celsius</code> variable a default value (0 for numeric types) <a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Thermometer</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">celsius</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="k">_</span>

  <span class="k">def</span> <span class="n">fahrenheit</span> <span class="k">=</span> <span class="n">celsius</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span>
  <span class="k">def</span> <span class="n">fahrenheit_=</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">celsius</span> <span class="k">=</span> <span class="o">(</span><span class="n">f</span> <span class="o">-</span> <span class="mi">32</span><span class="o">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">fahrenheight</span> <span class="o">+</span> <span class="s">&quot;F/&quot;</span> <span class="o">+</span> <span class="n">celsius</span> <span class="o">+</span> <span class="s">&quot;C&quot;</span>
<span class="o">}</span>
</code></pre></figure>
<h1 id="type-parameterization">Type Parameterization</h1>
<p>It’s possible to hide the primary constructor by making it private. This makes its type usable but not its constructor, which can only be used from the class itself, such as through an auxiliary constructor, or its companion object.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">private</span> <span class="o">(</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span>  <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span>
</code></pre></figure>
<p>For example, a factory method can be created in the companion object:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">object</span> <span class="nc">Queue</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></figure>
<p>Another way is to define a <em>generic trait</em>, i.e. one that is parameterized, and hide the implementation inside the companion object, along with a factory method in the companion object:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Queue</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">class</span> <span class="nc">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span>  <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">mirror</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">enqueue</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<h2 id="variance">Variance</h2>
<p><em>Variance</em> refers to inheritance relationships of parameterized types, such as whether <code>Set​[String]</code> is a subtype of <code>Set​[AnyRef]</code>.</p>
<p>For example, if <code>S</code> is a subtype of <code>T</code> and <code>Queue​[S]</code> is considered a subtype of <code>Queue​[T]</code>, then <code>Queue</code> is <em>covariant</em> in its type parameter <code>T</code>. This would mean for example that we could pass <code>Queue​[String]</code> to a method that accepted types <code>Queue​[AnyRef]</code>.</p>
<p>However, generic types are <em>nonvariant</em> by default, meaning that there would be no such subtype relationship. It’s possible to annotate the type parameter as being <em>covariant</em> by prepending the type parameter with <code>+</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></figure>
<p><em>Contravariance</em> would mean that if <code>T</code> is a subtype of <code>S</code>, then <code>Queue​[S]</code> is a subtype of <code>Queue​[T]</code>. It’s also possible to annotate the type parameter to be <em>contravariant</em> by using the <code>-</code> annotation:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></figure>
<p>In order to make <code>Queue</code> covariant, it’s necessary to specify a lower bound on the <code>enqueue</code> method and make it polymorphic as well. The lower bound enforces the requirement that <code>U</code> be a supertype of <code>T</code>.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">(</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span>  <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">[</span><span class="kt">U</span> <span class="kt">:&gt;</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></figure>
<p>This means that given supertype <code>Fruit</code> and subtypes <code>Apple</code> and <code>Orange</code>, an <code>Orange</code> can be appended to a <code>Queue​[Apple]</code>, yielding a <code>Queue​[Fruit]</code> result.</p>
<p>There are also upper bounds which enforce the requirement that a type be a subtype of another, in the example below, it means that <code>T</code> must be a subtype of <code>Ordered​[T]</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">orderedMergeSort</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</code></pre></figure>
<h1 id="abstract-members">Abstract Members</h1>
<p>A member of a class or trait is <em>abstract</em> if it doesn’t have a complete definition within the class. The implementations are meant to be defined in subclasses. Unlike other object-oriented languages, it’s also possible to declare abstract fields and even abstract types. It’s possible to declare abstract types, methods, <code>val</code>s and <code>var</code>s:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">trait</span> <span class="nc">Abstract</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">val</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">var</span> <span class="n">current</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>
</code></pre></figure>
<p>This can then be implemented in a subclass:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Concrete</span> <span class="k">extends</span> <span class="nc">Abstract</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">String</span>
  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">val</span> <span class="n">initial</span> <span class="k">=</span> <span class="s">&quot;hi&quot;</span>
  <span class="k">var</span> <span class="n">current</span> <span class="k">=</span> <span class="n">initial</span>
<span class="o">}</span>
</code></pre></figure>
<p>It’s possible to override abstract methods with a concrete <code>val</code>, since the <code>val</code> will yield the same value every time, whereas the reverse can’t be guaranteed.</p>
<p>Abstract <code>var</code>s provide implicit getters and setters for certain values.</p>
<p>Class parameter arguments are evaluated <em>before</em> being passed to the class constructor, but concrete <code>val</code> definitions are evaluated <em>after</em> the superclass is initialized. The following yields an error for failing to satisfy the requirement, since at the time the requirement is checked, the value of <code>denomArg</code> is still 0, since it’s defined in the subclass.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">trait</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">val</span> <span class="n">denomArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="n">require</span><span class="o">(</span><span class="n">denomArg</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">2</span>

<span class="c1">// defines an anonymous class that mixes in RationalTrait</span>
<span class="c1">// with its definition enclosed</span>
<span class="k">new</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">}</span>

<span class="c1">// yields java.lang.IllegalArgumentException: requirement failed</span>
</code></pre></figure>
<p>Pre-initialized fields are one way to solve this problem by defining certain subclass fields before the superclass is called:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="c1">// anonymous class</span>
<span class="k">new</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">RationalTrait</span>

<span class="c1">// object definition</span>
<span class="k">object</span> <span class="nc">twoThirds</span> <span class="k">extends</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">2</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">3</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">RationalTrait</span>
</code></pre></figure>
<p>The other way to solve this problem is using lazy <code>val</code>s, which defers the evaluation of the <code>val</code>’s expression until the first time it the <code>val</code> is used, much like in Haskell.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">trait</span> <span class="nc">LazyRationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">val</span> <span class="n">denomArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">numerArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">denomArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">private</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="n">denomArg</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">gcd</span><span class="o">(</span><span class="n">numerArg</span><span class="o">,</span> <span class="n">denomArg</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>Abstract types are useful when there are abstract methods which take on parameters of types specific to the subclass. For example, it wouldn’t make sense to have the following because it would mean that we could pass any type of <code>Food</code> to any <code>Animal</code> subclass.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Food</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Food</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></figure>
<p>Instead of defining the <code>eat</code> method as taking a <code>Food</code> parameter, we could define it to take some abstract type with an upper bound enforcing that it is a subclass of <code>Food</code>. This way, a subclass of <code>Animal</code> could explicitly specify the type of <code>Food</code> it eats.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Food</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="k">&lt;:</span> <span class="kt">Food</span>
  <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">SuitableFood</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></figure>
<p>A <em>path-dependent type</em> is one that depends on its path, i.e. <code>some​.object​.Type</code>. Such a type can be instantiated using that syntax, since it implies a reference to <code>Type</code>’s outer object, particularly <code>object</code>. The syntax <code>Outer​#Inner</code> can’t be used to instantiate <code>Inner</code> since it doesn’t refer to any instance of <code>Outer</code>.</p>
<h2 id="structural-subtyping">Structural Subtyping</h2>
<p><em>Structural subtyping</em> is when two types get a subtyping relationship because they have the same members <a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>. This is contrasted to the more traditional <em>nominal subtyping</em>, where each type has a name they have an explicitly declared subtyping relationship. Structural subtyping is achieved in Scala using <em>refinement types</em>.</p>
<p>For example, to create a <code>Pasture</code> class full of <code>Animal</code>s that eat <code>Grass</code>, we can define:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="nc">Animal</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="o">=</span> <span class="nc">Grass</span> <span class="o">}</span>
<span class="k">class</span> <span class="nc">Pasture</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">animals</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Animal</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="kt">=</span> <span class="kt">Grass</span> <span class="o">}]</span> <span class="k">=</span> <span class="nc">Nil</span>
<span class="o">}</span>
</code></pre></figure>
<p>It can also be used to generalize a <code>using</code> method, such as Python’s <code>with</code> syntax, so that it works on any object that has a <code>close</code> method. The first attempt at generalization wouldn’t work because <code>T</code> could be any type, even one that <em>doesn’t</em> have a <code>close</code> method. This can be fixed by specifying an upper bound consisting of a refinement type. Note that if no base type is specified, like <code>Animal</code> preceding the braces above, then Scala uses <code>AnyRef</code></p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">using</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">S</span><span class="o">](</span><span class="n">obj</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="n">operation</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">operation</span><span class="o">(</span><span class="n">obj</span><span class="o">)</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">close</span><span class="o">()</span> <span class="c1">// type error</span>
  <span class="n">result</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">using</span><span class="o">[</span><span class="kt">T</span>, <span class="k">&lt;:</span> <span class="o">{</span> <span class="kt">def</span> <span class="kt">close</span><span class="o">()</span><span class="kt">:</span> <span class="kt">Unit</span> <span class="o">}</span>, <span class="kt">S</span><span class="o">](</span><span class="n">obj</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="n">operation</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">operation</span><span class="o">(</span><span class="n">obj</span><span class="o">)</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
  <span class="n">result</span>
<span class="o">}</span>
</code></pre></figure>
<h2 id="enumerations">Enumerations</h2>
<p>Enumerations in Scala aren’t defined at the language-level. Instead there is a class <code>scala​.Enumeration</code> that can be used to define enumerations, which works due to path-dependent types. This means that <code>Color​.Value</code> would be different from <code>Direction​.Value</code> becuase their parts differ:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">object</span> <span class="nc">Color</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">Red</span><span class="o">,</span> <span class="nc">Green</span><span class="o">,</span> <span class="nc">Blue</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Direction</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">North</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">&quot;North&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">East</span>  <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">&quot;East&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">South</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">&quot;South&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">West</span>  <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">&quot;West&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">for</span> <span class="o">(</span><span class="n">d</span> <span class="k">&lt;-</span> <span class="nc">Direction</span><span class="o">.</span><span class="n">values</span><span class="o">)</span> <span class="n">print</span> <span class="o">(</span><span class="n">d</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="o">)</span>

<span class="nc">Direction</span><span class="o">.</span><span class="nc">East</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">1</span>
<span class="nc">Direction</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>      <span class="o">==</span> <span class="nc">Direction</span><span class="o">.</span><span class="nc">East</span>
</code></pre></figure>
<h1 id="implicit-conversions-and-parameters">Implicit Conversions and Parameters</h1>
<p>Implicit conversions <a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> can be used to make two independent libraries interoperate in a simple manner. For example, using Swing in Scala would look something like this:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">button</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JButton</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">ActionListener</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">actionPerformed</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">)</span>
</code></pre></figure>
<p>However, code written this way reflects Java’s limitations and is therefore not idiomatic Scala. Using implicit conversions it can be possible to write it something like this:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="o">(</span><span class="k">_:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></figure>
<p>This is done using an implicit conversion function like this one. What happens is that Scala compiles it normally and encounters a type error in the above code, so it checks if there’s an implicit conversion function of the correct type, <code>ActionEvent =&gt; Unit</code>, and if it works then it continues compilation:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">implicit</span> <span class="k">def</span> <span class="n">function2ActionListener</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">ActionEvent</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">ActionListener</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">actionPerformed</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">event</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></figure>
<p>There are a variety of rules concerning implicit definitions.</p>
<ul>
<li>Only functions marked as <code>implicit</code> are tried.</li>
<li>The implicit conversion must be in the scope as a single identifier, i.e. not <code>some​.convert</code>. This is why some libraries include a <code>Preamble</code> object which often contains useful implicit conversions which can be imported with <code>import​.Preamble​._</code>
<ul>
<li>The <em>exception</em> to this rule is that the compiler also looks inside the companion object of the source or target types of the conversion.</li>
</ul></li>
<li>The compiler only attempts one implicit conversion, i.e. it won’t attempt converting <code>x + y</code> into <code>convert1(convert2(x)) + y</code>.</li>
</ul>
<p>Implicit conversions are also used on the receiver of a selection. For example, <code>&quot;abc&quot;​.exists</code> is converted to <code>stringWrapper(&quot;abc&quot;)​.exists</code>.</p>
<p>Implicit conversions are often used for simulating new syntax, such as the <code>-&gt;</code> in a <code>Map</code>, which is defined as:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">package</span> <span class="nn">scala</span>
<span class="k">object</span> <span class="nc">Predef</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">y</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Tuple2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Tuple2</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">any2ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">ArrowAssoc</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></figure>
<h2 id="implicit-parameters">Implicit Parameters</h2>
<p>Implicit parameters are those that can optionally be provided by the compiler. Note that the <code>implicit</code> applies to the entire last parameter list. Also, we didn’t use a direct <code>String</code> since the compiler selects implicit parameters based on their types, so this should lower the chances that another type is used to fulfill the implicit parameter. Finally, implicit parameters must be available as single identifiers, which is why they are usually declared in an object which is imported.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">class</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Greeter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">greet</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">prompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span><span class="o">,</span> <span class="n">drink</span><span class="k">:</span> <span class="kt">PreferredDrink</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Welcome &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;, have some &quot;</span> <span class="o">+</span> <span class="n">drink</span><span class="o">.</span><span class="n">preference</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">prompt</span><span class="o">.</span><span class="n">preference</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Preferences</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">prompt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="s">&quot;$ &quot;</span><span class="o">)</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">drink</span>  <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="s">&quot;tea&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">import</span> <span class="nn">Preferences._</span>
<span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">)(</span><span class="n">prompt</span><span class="o">,</span> <span class="n">drink</span><span class="o">)</span>
<span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">)</span> <span class="c1">// or implicitly</span>
</code></pre></figure>
<p>Implicit parameters are often used to provide information about a type in a preceding, explicit parameter list. For example, it can be used to pass a compare function to a function that yields the largest element in a list. Scala actually provides many <code>orderer</code> functions in the standard library, which makes this function usable with many standard types without explicitly providing an <code>orderer</code>. Note that again, types are made as specific as possible to reduce ambiguity to the developer and to restrict the options available to the compiler:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">orderer</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span>    <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;empty&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxList</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span> <span class="c1">// (ordered)  is implicit</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxRest</span><span class="o">)</span> <span class="n">x</span>          <span class="c1">// ordered(x) is implicit</span>
      <span class="k">else</span> <span class="n">maxRest</span>
  <span class="o">}</span>
</code></pre></figure>
<p>Also note that the implicit parameter can be used as an implicit parameter and conversion in the body, as a result, <code>ordered</code> doesn’t appear anywhere in the function body. This is a very common thing to do, and since the name of the implicit parameter isn’t used anywhere, it’s possible to use a <em>view bound</em>.</p>
<p>For example, the following code essentially enforces the requirement that <code>T</code> can be <em>treated</em> as an <code>Ordered​[T]</code>, where <em>treated</em> would mean that there is an implicit conversion available. If <code>T</code> is already an <code>Ordered​[T]</code>, then an identity function is used as the implicit conversion:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;%</span> <span class="kt">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">...</span>
</code></pre></figure>
<p>If multiple conversions apply for an implicit conversion, Scala generally refuses to insert a conversion. However, since Scala 2.8, it now does something similar to C++ where it’ll choose the most specific conversion available, where being <em>more specific</em> entails:</p>
<ul>
<li>the argument type is a subtype of another conversion’s argument type</li>
<li>both conversions are methods and the enclosing class extends the other conversion’s enclosing class</li>
</ul>
<h1 id="lists">Lists</h1>
<p>The left fold is possible with <code>/:</code> and <code>foldLeft</code> and the right fold with <code>:\</code> and <code>foldRight</code>. The <code>/:</code> and <code>:\</code> names represent the way the fold tree leans.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="k">def</span> <span class="n">flattenRight</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">xss</span> <span class="o">:\</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]())</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>
</code></pre></figure>
<p>An efficient way to append lists in constant time is to use <code>ListBuffers</code> <a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>
<span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="mi">3</span> <span class="o">+=:</span> <span class="n">buf</span>
<span class="n">buf</span><span class="o">.</span><span class="n">toList</span>
</code></pre></figure>
<p>An <code>ArrayBuffer</code> is similar to an <code>std​::vector</code> in that it automatically resizes itself to fit its contents.</p>
<h2 id="list-implementation">Implementation</h2>
<p>Lists are implemented as a covariant, abstract class <code>List</code> for which there are subclasses <code>::</code> and <code>Nil</code>. The covariant property allows a <code>List​[Int]</code> to be assigned to a <code>List​[Any]</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">package</span> <span class="nn">scala</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span>

<span class="nc">val</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></figure>
<p>The <code>Nil</code> object inherits from <code>List​[Nothing]</code> so that <code>Nil</code> can be assigned to any <code>List</code>. The methods <code>isEmpty</code>, <code>head</code>, and <code>tail</code> are implemented for <code>Nil</code>, where the first returns <code>true</code> and the latter two throw an exception, as in Haskell.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">case</span> <span class="k">object</span> <span class="nc">Nil</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>  <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="k">throw</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="k">throw</span> <span class="o">...</span>
<span class="o">}</span>
</code></pre></figure>
<p>The <code>::</code>, “cons” class is defined so that <code>x ​:: xs</code> is treated as <code>::(x​, xs)</code> where <code>::</code> is a case class defined as:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">::</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>
</code></pre></figure>
<p>List operations are defined so that the result type is “widened” to accommodate the types of all list elements. This is done by placing a lower bound</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="o">::[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Fruit</span>
<span class="k">class</span> <span class="nc">Apple</span> <span class="k">extends</span> <span class="nc">Fruit</span>
<span class="k">class</span> <span class="nc">Orange</span> <span class="k">extends</span> <span class="nc">Fruit</span>

<span class="k">val</span> <span class="n">apples</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Apple</span>  <span class="o">::</span> <span class="nc">Nil</span>
<span class="k">val</span> <span class="n">fruits</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Orange</span> <span class="o">::</span> <span class="n">apples</span>
</code></pre></figure>
<p>It turns out that the cons class is actually defined such that the tail is a mutable var, but only accessible within the <code>scala</code> package:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">::</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">U</span><span class="o">,</span> <span class="k">private</span><span class="o">[</span><span class="kt">scala</span><span class="o">]</span> <span class="k">var</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">hd</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="n">tl</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>
</code></pre></figure>
<p>A <code>ListBuffer</code> then works by directly modifying the tail of the last cons cell in the list. This means that the tails in the following two variables are shared to avoid copying <a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">ys</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">xs</span>
<span class="k">val</span> <span class="n">zs</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">::</span> <span class="n">xs</span>
</code></pre></figure>
<h1 id="for-expressions">For Expressions</h1>
<p>All <code>for</code> expressions that <code>yield</code> are translated by the compiler into combinations of <code>map</code>, <code>flatMap</code>, and <code>withFilter</code>, and those that don’t <code>yield</code> into combinations of <code>withFilter</code> and <code>foreach</code>. This means that the following are equivalent:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">persons</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">isMale</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">children</span> <span class="n">map</span> <span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">))))</span>

<span class="k">for</span> <span class="o">(</span><span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span><span class="o">;</span> <span class="k">if</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">isMale</span><span class="o">;</span> <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">p</span><span class="o">.</span><span class="n">children</span><span class="o">)</span>
<span class="k">yield</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">)</span>
</code></pre></figure>
<p><code>for</code> expressions are of the following form, where <em>seq</em> is a sequence of <em>generators</em>, <em>definitions</em>, and <em>filters</em> delimited by semicolons:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">for</span> <span class="o">(</span><span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr</span>

<span class="c1">// for example: seq = generator; definition; filter</span>
<span class="k">for</span> <span class="o">(</span><span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span><span class="o">;</span> <span class="n">n</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">;</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="n">startsWith</span> <span class="s">&quot;To&quot;</span><span class="o">))</span>
<span class="k">yield</span> <span class="n">n</span>
</code></pre></figure>
<p>Generators are of the form <code>pat &lt;- expr</code> where the pattern <code>pat</code> is matched for each element in the list. If the match succeeds, the variables are bound to the pattern components. If the match fails, the element is discarded from iteration.</p>
<h2 id="for-expression-translation">Translation</h2>
<p>The following are examples of how <code>for</code> expressions are translated into combinations of <code>map</code>, <code>flatMap</code>, and <code>withFilter</code>.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="c1">// case 1: one generator</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr2</span>
<span class="n">expr1</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">expr2</span><span class="o">)</span>

<span class="c1">// case 2: generator and filter</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span> <span class="k">if</span> <span class="n">expr2</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr3</span>
<span class="c1">// transform into case 1</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">.</span><span class="n">withFilter</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">expr2</span><span class="o">))</span> <span class="k">yield</span> <span class="n">expr3</span>
<span class="n">expr1</span><span class="o">.</span><span class="n">withFilter</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">expr2</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">expr3</span><span class="o">)</span>

<span class="c1">// case 3: two generators</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">expr2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr3</span>
<span class="n">expr1</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">y</span> <span class="k">&lt;-</span> <span class="n">expr2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr3</span><span class="o">)</span>

<span class="c1">// case 4: tuple pattern</span>
<span class="k">for</span> <span class="o">((</span><span class="n">x1</span><span class="o">,</span> <span class="o">...,</span> <span class="n">xn</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr2</span>
<span class="n">expr1</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">x1</span><span class="o">,</span> <span class="o">...,</span> <span class="n">xn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">expr2</span> <span class="o">}</span>

<span class="c1">// case 5: arbitrary pattern</span>
<span class="c1">//         first filter by successful match, then map.</span>
<span class="c1">//         guarantees no MatchError exception</span>
<span class="k">for</span> <span class="o">(</span><span class="n">pat</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr2</span>
<span class="n">expr1</span><span class="o">.</span><span class="n">withFilter</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span>   <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}.</span><span class="n">map</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="n">expr2</span>
<span class="o">}</span>

<span class="c1">// case 6: contains definitions</span>
<span class="c1">//         expr2 is evaluated each time x is generated</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">;</span> <span class="n">y</span> <span class="k">=</span> <span class="n">expr2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr3</span>
<span class="k">for</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">)</span> <span class="k">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">expr2</span><span class="o">);</span> <span class="n">seq</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">expr3</span>

<span class="c1">// case 7: side-effect loop</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">)</span> <span class="n">body</span>
<span class="n">expr1</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">body</span><span class="o">)</span>

<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">;</span> <span class="k">if</span> <span class="n">expr2</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">expr3</span><span class="o">)</span> <span class="n">body</span>
<span class="n">expr1</span><span class="o">.</span><span class="n">withFilter</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">expr2</span><span class="o">).</span><span class="n">foreach</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span>
  <span class="n">expr3</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="n">body</span><span class="o">))</span>
</code></pre></figure>
<h2 id="generalized-for-expressions">Generalized For Expressions</h2>
<p>It’s possible to add support for <code>for</code> expressions to any data type by defining <code>map</code>, <code>flatMap</code>, <code>withFilter</code>, and <code>foreach</code>. Depending on which of these functions are implemented, the following features of <code>for</code> expressions become available:</p>
<ul>
<li><code>map</code>: expressions with a single generator</li>
<li><code>flatMap</code> and <code>map</code>: expressions with multiple generators</li>
<li><code>foreach</code>: loops with single/multiple generators</li>
<li><code>withFilter</code>: filter expressions</li>
</ul>
<p>Type checking is performed after translation occurs. Given a parameterized type <code>C</code> denoting a collection, the following type signatures are generally used for the required methods. A standard technique to optimize <code>withFilter</code> is to not return an entire new object but to return a wrapper object that remembers that elements need to be filtered when they’re processed later:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// monad methods</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">C</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">withFilter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</code></pre></figure>
<h1 id="collections-api">Collections API</h1>
<p>The <code>Traversable</code> trait is at the top of the collections hierarchy and defines the following abstract operation, which is meant to traverse all elements of a collection and apply the operation <code>f</code> to each element:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span>
</code></pre></figure>
<p>The <code>Iterable</code> trait defines an abstract <code>iterator</code> method, which <code>Iterable</code> uses to define <code>foreach</code> of <code>Traversable</code> it extends from:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">iterator</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span> <span class="n">f</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">())</span>
<span class="o">}</span>
</code></pre></figure>
<h2 id="sequences">Sequences</h2>
<p>The sequence traits <code>Seq</code>, <code>IndexedSeq</code>, and <code>LinearSeq</code> represent iterables that have a length and whose elements have fixed indexed positions starting from 0.</p>
<p>Buffers are a sub-category of sequences that allow element insertions, removals, and appending operations. Common buffers are <code>ListBuffer</code> and <code>ArrayBuffer</code>.</p>
<h2 id="sets">Sets</h2>
<p>Sets are iterables with no duplicate elements. There are two subtraits <code>SortedSet</code> and <code>BitSet</code>. Ordering is preserved in <code>SortedSet</code>, and is backed by an ordered binary tree, with <code>immutable​.TreeSet</code> being a <a href="/notes/algorithms/#red-black-trees">red-black tree</a> that keeps the tree balanced. <code>BitSet</code> uses an array of <code>Long</code> values to efficiently represent a set of packed bits, much like C++’s <a href="http://en.cppreference.com/w/cpp/utility/bitset">bitset</a>.</p>
<h2 id="maps">Maps</h2>
<p>Maps’ <code>get</code> method returns an <code>Option​[Value]</code>, like <code>lookup</code> would return a <code>Maybe a</code> in Haskell. The <code>getOrElseUpdate</code> function facilitates the use of Maps as caches.</p>
<h2 id="streams">Streams</h2>
<p>Streams have elements that are computed lazily. The <code>#:​:</code> function is used to construct streams. Notice that only the head has been computed so far:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">str</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">#::</span> <span class="mi">2</span> <span class="o">#::</span> <span class="mi">3</span> <span class="o">#::</span> <span class="nc">Stream</span><span class="o">.</span><span class="n">empty</span>
<span class="c1">// Stream(1, ?)</span>

<span class="k">def</span> <span class="n">fibonacciFrom</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">a</span> <span class="o">#::</span> <span class="n">fibonacciFrom</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>

<span class="k">val</span> <span class="n">fibs</span> <span class="k">=</span> <span class="n">fibonacciFrom</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">).</span><span class="n">take</span><span class="o">(</span><span class="mi">7</span><span class="o">).</span><span class="n">toList</span>
<span class="c1">// List(1, 1, 2, 3, 5, 8, 13)</span>
</code></pre></figure>
<h2 id="vectors">Vectors</h2>
<p>Vectors are effectively constant time, random access sequences represented as broad, shallow trees where every tree node contains up to 32 elements of the vector or 32 other tree nodes. The <code>updated</code> method can be used to update particular elements and is also effectively constant time, since only the node that contains the element and every node that points to it must be copied. These are currently the default implementation of immutable indexed sequences, <code>collection​.immutable​.IndexedSeq</code>.</p>
<h2 id="ranges">Ranges</h2>
<p>Ranges can be defined as follows:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span>       <span class="c1">// =&gt; Range(1, 2, 3)</span>
<span class="mi">5</span> <span class="n">to</span> <span class="mi">14</span> <span class="n">by</span> <span class="mi">3</span> <span class="c1">// =&gt; Range(5, 8, 11, 14)</span>
<span class="mi">1</span> <span class="n">until</span> <span class="mi">3</span>    <span class="c1">// =&gt; Range(1, 2,)</span>
</code></pre></figure>
<h2 id="arrays">Arrays</h2>
<p>Scala arrays correspond to Java arrays such that <code>Array​[T]</code> in Scala is a <code>T[]</code> in Java. Scala arrays are compatible with sequences, and provide all operations that sequences provide. This is facilitated through implicit conversions to <code>scala​.collection​.mutable​.WrappedArray</code>. There’s also an implicit conversion to <code>ArrayOps</code> which supports various methods available to sequences, without actually turning the array into a sequence.</p>
<p>Java doesn’t allow generic arrays <code>T[]</code>, but this is made possible in Scala by creating an array of <code>Objects</code>. Creating generic arrays in Scala through <code>Array​[T]</code> requires a run-time hint, since the information about the type <code>T</code> gets erased at runtime. This is done with a <em>class manifest</em> of type <code>scala​.reflect​.ClassManifest</code>, which is a type descriptor object that describes the top-level class of a type. The compiler can be instructed to generate code to construct and pass a class manifest, this is done via an implicit parameter. This way, the compiler looks for an implicit value of type <code>ClassManifest​[T]</code> so that the correct type of array can be constructed at run-time:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">someMethod</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">m</span><span class="k">:</span> <span class="kt">ClassManifest</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// or with a context bound</span>
<span class="k">def</span> <span class="n">someMethod</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">ClassManifest</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</code></pre></figure>
<h2 id="views">Views</h2>
<p>Transformer methods are ones such as <code>map</code> and <code>filter</code> and come in strict and non-strict varieties. A strict transformer constructs a new collection on the spot. A non-strict transformer construct a proxy for the result collection such that its elements are constructed on demand.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">lazyMap</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">coll</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">iterator</span> <span class="k">=</span> <span class="n">coll</span><span class="o">.</span><span class="n">iterator</span> <span class="n">map</span> <span class="n">f</span>
  <span class="o">}</span>
</code></pre></figure>
<p>Most collections are strict by default in their transformers except for <code>Stream</code>. It’s possible to turn a collection into a lazy one and vice versa through <em>collection views</em>, which represent a base collection with the difference that the transformers are lazy. The <code>view</code> method is used to make the transformers lazy, and <code>force</code> is used to go back to strict transformers.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)).</span><span class="n">force</span>
</code></pre></figure>
<p>Views can provide a simple way to optimize otherwise costly operations <a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span>
<span class="k">def</span> <span class="n">findPalindrome</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">s</span> <span class="n">find</span> <span class="n">isPalindrome</span>

<span class="c1">// creates 1000000 element sequence</span>
<span class="n">findPalindrome</span><span class="o">(</span><span class="n">words</span> <span class="n">take</span> <span class="mi">1000000</span><span class="o">)</span>

<span class="c1">// creates no copy</span>
<span class="n">findPalindrome</span><span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="n">view</span> <span class="n">take</span> <span class="mi">1000000</span><span class="o">)</span>
</code></pre></figure>
<p>Views can also be used as subwindows into mutable sequences <a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a>.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">subarr</span> <span class="k">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">slice</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>

<span class="c1">// can now perform operations on that slice only</span>
<span class="c1">// i.e. negate all elements in the slice</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">subarr</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">subarr</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="o">-</span><span class="n">subarr</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
</code></pre></figure>
<h2 id="iterators">Iterators</h2>
<p>Iterators are affected by operations on them, such that for example a <code>map</code> called on an iterator leaves the iterator’s position at the end of the sequence, so that an extra call to <code>next</code> will throw a <code>NoSuchElementException</code>. This is mitigated by duplicating the iterator with <code>duplicate</code> <a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a>.</p>
<p>A <code>BufferedIterator</code> provides an extra method <code>head</code> that returns its first element without advancing the iterator.</p>
<h2 id="java-interop-collections">Java Interop</h2>
<p>Scala provides implicit conversions for the major collection types in Java through the <code>JavaConversions</code> object.</p>
<h2 id="collections-architecture">Architecture</h2>
<p>Most of the collection operations are implemented in terms of traversals and builders.</p>
<h3 id="builders">Builders</h3>
<p>Builders are in charge of building new collections. The <code>result</code> method yields the collection that has been constructed thus far, and the builder can be reset to a clean slate to construct another collection with the <code>clear</code> method. The <code>mapResult</code> method can be used to return a result of a different type.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">package</span> <span class="nn">scala.collection.generic</span>

<span class="k">class</span> <span class="nc">Builder</span><span class="o">[</span><span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="o">+=(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">this.type</span>
  <span class="k">def</span> <span class="n">result</span><span class="o">()</span><span class="k">:</span> <span class="kt">To</span>
  <span class="k">def</span> <span class="n">clear</span><span class="o">()</span>
  <span class="k">def</span> <span class="n">mapResult</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">To</span> <span class="o">=&gt;</span> <span class="nc">NewTo</span><span class="o">)</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">NewTo</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>
</code></pre></figure>
<h3 id="implementation-traits">Implementation Traits</h3>
<p>The code is kept <abbr title="Don&#39;t Repeat Yourself">DRY</abbr> by using <em>implementation traits</em> which are named with a <code>Like</code> suffix, such as <code>TraversableLike</code>. These traits implement concrete methods and are parameterized using the collection’s element type and its representation type, i.e. <code>Seq​[I]</code> or <code>List​[I]</code>. For example, <code>filter</code> is implemented here such that it creates a new builder for the representation type and appends elements to it if they satisfy the predicate, then the builder’s result is returned.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">package</span> <span class="nn">scala.collection</span>

<span class="k">class</span> <span class="nc">TraversableLike</span><span class="o">[</span><span class="kt">+Elem</span>, <span class="kt">+Repr</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">Repr</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">filder</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">newBuilder</span>
    <span class="n">foreach</span> <span class="o">{</span> <span class="n">elem</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">(</span><span class="n">elem</span><span class="o">))</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">elem</span> <span class="o">}</span>
    <span class="n">b</span><span class="o">.</span><span class="n">result</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>A problem presents itself when we want to return a different type of sequence from the one that is being operator one, for example:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;a&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;b&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// Map(1 -&gt; &quot;a&quot;, 2 -&gt; &quot;b&quot;)</span>

<span class="nc">Map</span><span class="o">(</span><span class="s">&quot;a&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;b&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">}</span>
<span class="c1">// List(1, 2)</span>

<span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toFloat</span><span class="o">)</span>
<span class="c1">// Set(1.0, 2.0, 3.0)</span>
</code></pre></figure>
<p>This is mitigated with an implicit parameter on the function so that a builder factory may produce the correct type of builder by passing it the implicit parameter.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">That</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">bf</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">That</span>, <span class="kt">This</span><span class="o">])</span><span class="k">:</span> <span class="kt">That</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">bf</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="k">this</span><span class="o">)</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="n">b</span><span class="o">.</span><span class="n">result</span>
<span class="o">}</span>

<span class="k">package</span> <span class="nn">scala.collection.generic</span>
<span class="k">trait</span> <span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">-From</span>, <span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">From</span><span class="o">)</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></figure>
<p>For example, in the case of a <code>BitSet</code>, the companion object for <code>BitSet</code> would define a builder factory of type <code>CanBuildFrom​[BitSet​, Int​, BitSet]</code>, with a more general fallback that converts to a regular <code>Set</code> with <code>CanBuildFrom​[Set​[_]​, A​, Set​[A]]</code>. Scala will then choose the more specific one when choosing the implicit instance.</p>
<p>Finally, collections are kept the same dynamic type. This is achieved through virtual dispatch by passing the source collection to the builder factory, which forwards the call to a <code>genericBuilder</code> method available on all generic, non-leaf classes, which itself calls the builder that belongs to the collection on which it is defined.</p>
<h3 id="creating-collections">Creating Collections</h3>
<p>Creating a new collection type <code>T</code> can be done by using traits <code>IndexedSeq​[Elem]</code> and <code>IndexedSeqLike​[Elem​, T]</code>. The latter requires the implementation of <code>newBuilder</code>. It’s also necessary to implement appropriate <code>CanBuildFrom</code> implicits.</p>
<h1 id="extractors">Extractors</h1>
<p>Extractors provide a way to define patterns that are decoupled from an object’s representation. This is done using an <code>unapply</code> method that matches a value and deconstructs it:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">object</span> <span class="nc">EMail</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">parts</span> <span class="k">=</span> <span class="n">str</span> <span class="n">split</span> <span class="s">&quot;@&quot;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">parts</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="nc">Some</span><span class="o">(</span><span class="n">parts</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">parts</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">else</span> <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>This is analogous to an <code>apply</code> method that constructs an object:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">object</span> <span class="nc">EMail</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">domain</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">user</span> <span class="o">+</span> <span class="s">&quot;@&quot;</span> <span class="o">+</span> <span class="n">domain</span>
<span class="o">}</span>
</code></pre></figure>
<p>This can be made more explicit by inheriting from the function type:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="c1">// equivalent to extends Function2[String, String, String]</span>
<span class="k">object</span> <span class="nc">EMail</span> <span class="k">extends</span> <span class="o">((</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></figure>
<p>Pattern matching in Scala checks for an <code>unapply</code> method to deconstruct the object. If <code>unapply</code> returns <code>None</code>, then the pattern doesn’t match and it moves on to the next pattern, throwing a <code>MatchError</code> if there are no other patterns that match. Remember that a single-tuple parameter can omit the set of parentheses, i.e. <code>func((a​, b)) -&gt; func(a​, b)</code>.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">selectorString</span> <span class="k">match</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></figure>
<p>It’s generally a good idea to ensure that the following property holds:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="nc">Obj</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="nc">Obj</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="o">==</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</code></pre></figure>
<p>In the case of a single pattern variable, that single variable is wrapped in an <code>Option</code> value.</p>
<p>It’s also possible for the pattern to not bind any variables, in which case a <code>Boolean</code> is returned to indicate whether the pattern matched:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">object</span> <span class="nc">UpperCase</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">toUpperCase</span> <span class="o">==</span> <span class="n">s</span>
<span class="o">}</span>
</code></pre></figure>
<p>It’s also possible to define variable argument extractors, to be able to match on an arbitrary number of variables. This is done using the <code>unapplySeq</code> function:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">object</span> <span class="nc">Domain</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">(</span><span class="n">whole</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">whole</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;\\.&quot;</span><span class="o">).</span><span class="n">reverse</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></figure>
<p>This allows matching like this:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">domain</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">&quot;org&quot;</span><span class="o">,</span> <span class="s">&quot;acm&quot;</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;acm.org&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">&quot;net&quot;</span><span class="o">,</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;some .net domain&quot;</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></figure>
<h2 id="compared-to-case-classes">Compared to Case Classes</h2>
<p>Modifying the case classes has an effect on client code, whereas extractors provide a layer of indirection between the data representation and the way it’s viewed by clients. However, case classes to have advantages over extractors. They’re easier and simpler to define. Case classes can also end up generating more efficient pattern matches because the compiler can optimize them since they’re defined at the language level. Finally, case classes derived from a <code>sealed</code> base class can allow the compiler to check for pattern match exhaustiveness.</p>
<h2 id="regular-expressions">Regular Expressions</h2>
<p>Regular expressions can be constructed using the <code>Regex</code> constructor or with a <code>r</code> method on a string. It’s possible to pattern match on a regular expression match using a predefined extractor. The matching is done by binding every matched group. If a group didn’t match, it’ll bind the variable to <code>null</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="nc">Decimal</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;(-)?(\d+)(\.\d*)?&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
<span class="k">val</span> <span class="nc">Decimal</span><span class="o">(</span><span class="n">sign</span><span class="o">,</span> <span class="n">integerpart</span><span class="o">,</span> <span class="n">decimalpart</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;-1.23&quot;</span>
<span class="c1">// sign = &quot;-&quot;, integerpart = &quot;1&quot;, decimalpart = &quot;.23&quot;</span>
</code></pre></figure>
<h1 id="annotations">Annotations</h1>
<p>Annotations are like meaningful comments for the compiler. They can support generation of documentation (Scaladoc), for example. Annotations can be placed on any kind of declaration or definition, as well as expressions:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="nd">@deprecated</span> <span class="k">def</span> <span class="n">oldMethod</span><span class="o">()</span> <span class="k">=</span> <span class="o">...</span>

<span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">@unchecked</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="c1">// non-exhaustive cases</span>
<span class="o">}</span>
</code></pre></figure>
<p>The general form of annotations is as follows. The <code>@</code> prefixed to an annotation can read as <code>new</code> since underneath the compiler is simply instantiating a class named after the annotation. Passing an annotation as argument to another has the consequence that it must use <code>new</code> instead of <code>@</code>.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="nd">@annotation</span><span class="o">(</span><span class="n">exp1</span><span class="o">,</span> <span class="n">exp2</span><span class="o">,</span> <span class="o">...)</span>
</code></pre></figure>
<p>The <code>@deprecated</code> annotation can mark something as deprecated, which elicits a compiler warning if some code uses it. It accepts an optional message:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="nd">@deprecated</span><span class="o">(</span><span class="s">&quot;use newOne() instead&quot;</span><span class="o">)</span>
<span class="k">def</span> <span class="n">oldOne</span><span class="o">()</span> <span class="k">=</span> <span class="o">...</span>
</code></pre></figure>
<p>The <code>@volatile</code> annotation informs the compiler that the variable in question will be used by multiple threads. This makes reads/writes slower, but accesses from multiple threads behave more predictably.</p>
<p>The <code>@serializable</code> annotation marks a class as serializable. The <code>@SerialVersionUID(id)</code> annotation marks the current version of a class. The <code>@transient</code> annotation marks fields that should not be serialized.</p>
<p>The <code>@scala​.reflect​.BeanProperty</code> annotation generates automatic get and set methods, i.e. <code>age</code> generates <code>getAge</code> and <code>setAge</code>. This is useful for Java-centric frameworks. The generated methods are available only after compilation, i.e. not within one’s own code.</p>
<p>The <code>@tailrec</code> annotation designates that a method should be tail-recursion optimized. If the optimization cannot be performed, a warning is emitted.</p>
<p>The <code>@unchecked</code> annotation tells the compiler not to check for exhaustive match cases.</p>
<p>The <code>@native</code> annotation means that the method’s implementation is supplied by the runtime, via the Java Native Interface (JNI), rather than in Scala.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="nd">@native</span>
<span class="k">def</span> <span class="n">nativeMethod</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* empty body required */</span> <span class="o">}</span>
</code></pre></figure>
<h1 id="xml">XML</h1>
<p>Scala allows XML literals anywhere that an expression is valid. The type of an XML literal is <code>Elem</code>. Class <code>Node</code> is the abstract superclass of all XML node classes. Class <code>Text</code> is a node holding just text. Class <code>NodeSeq</code> corresponds to a sequence of nodes, in fact, <code>Node</code> extends from <code>NodeSeq</code>, so a <code>Node</code> can be thought of as a one-element <code>NodeSeq</code>.</p>
<p>It’s possible to interpolate Scala code within XML literals using braces <code>{}</code>. The interpolated code can itself contain XML literals, effectively allowing arbitrary nesting of XML code. Two braces in a row are used to print literal braces.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">var</span> <span class="n">res</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="o">}</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="c1">// scala.xml.Elem = &lt;a&gt; 7 &lt;/a&gt;</span>

<span class="k">var</span> <span class="n">yearMade</span> <span class="k">=</span> <span class="mi">1955</span>
<span class="k">var</span> <span class="n">res2</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{</span> <span class="k">if</span> <span class="o">(</span><span class="n">yearMade</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="o">)</span> <span class="o">&lt;</span><span class="n">old</span><span class="o">&gt;{</span><span class="n">yearMade</span><span class="o">}&lt;/</span><span class="n">old</span><span class="o">&gt;</span>
                 <span class="k">else</span> <span class="n">xml</span><span class="o">.</span><span class="nc">NodeSeq</span><span class="o">.</span><span class="nc">Empty</span><span class="o">}</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="c1">// &lt;a&gt; &lt;old&gt;1955&lt;/old&gt; &lt;/a&gt;</span>
</code></pre></figure>
<p>Scala’s XML support can be leveraged to provide object serialization:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">SomeClass</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">description</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">val</span> <span class="n">year</span><span class="k">:</span> <span class="kt">Int</span>

  <span class="k">def</span> <span class="n">toXML</span> <span class="k">=</span>
    <span class="o">&lt;</span><span class="n">someclass</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;{</span><span class="n">description</span><span class="o">}&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">year</span><span class="o">&gt;{</span><span class="n">year</span><span class="o">}&lt;/</span><span class="n">year</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">someclass</span><span class="o">&gt;</span>
<span class="o">}</span>
</code></pre></figure>
<p>There are various ways to deconstruct XML in Scala. The <code>text</code> method retrieves all of the text from the entire element tree, <code>flatMap</code> style. Scala also supports <a href="http://en.wikipedia.org/wiki/XPath">XPath</a> through the methods <code>\</code> (for sub-elements) and <code>\\</code> (for recursive/deep search). Attributes can be extracted using the <code>@</code> sign before the attribute.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">var</span> <span class="n">res</span>  <span class="k">=</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\</span> <span class="s">&quot;b&quot;</span>
<span class="c1">// &lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;</span>

<span class="k">var</span> <span class="n">res2</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\\</span> <span class="s">&quot;c&quot;</span>
<span class="c1">// &lt;c&gt;hello&lt;/c&gt;</span>

<span class="k">val</span> <span class="n">employee</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">employee</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Joe&quot;</span> <span class="n">rank</span><span class="o">=</span><span class="s">&quot;officer&quot;</span> <span class="n">serial</span><span class="o">=</span><span class="s">&quot;IG-88&quot;</span><span class="o">/&gt;</span>
<span class="k">val</span> <span class="n">res3</span> <span class="k">=</span> <span class="n">employee</span> <span class="o">\</span> <span class="s">&quot;@name&quot;</span>
<span class="c1">// &quot;Joe&quot;</span>
</code></pre></figure>
<p>It’s also possible to define a <code>fromXML</code> method to deserialize an object.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">object</span> <span class="nc">SomeClass</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fromXML</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Node</span><span class="o">)</span><span class="k">:</span> <span class="kt">SomeClass</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">SomeClass</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">description</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span> <span class="s">&quot;description&quot;</span><span class="o">).</span><span class="n">text</span>
      <span class="k">val</span> <span class="n">year</span>        <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span> <span class="s">&quot;year&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>It’s possible to save a file from an XML node using, and conversely, load it:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="n">xml</span><span class="o">.</span><span class="nc">XML</span><span class="o">.</span><span class="n">save</span><span class="o">(</span><span class="s">&quot;serialized.xml&quot;</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span>
<span class="k">val</span> <span class="n">loadednode</span> <span class="k">=</span> <span class="n">xml</span><span class="o">.</span><span class="nc">XML</span><span class="o">.</span><span class="n">loadFile</span><span class="o">(</span><span class="s">&quot;serialized.xml&quot;</span><span class="o">)</span>
</code></pre></figure>
<p>It’s possible to pattern match on XML. This is done by using XML literals where instead of interpolating expressions, variables are interpolated in order to bind to the matched data. In the context of XML, the <code>_*</code> is interpreted as matching any sequence of nodes down the XML tree.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">def</span> <span class="n">proc</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Node</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="n">node</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;{</span><span class="n">contents</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s an a: &quot;</span> <span class="o">+</span> <span class="n">contents</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;{</span><span class="n">contents</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">b</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s a b: &quot;</span>  <span class="o">+</span> <span class="n">contents</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;Something else.&quot;</span>
  <span class="o">}</span>

<span class="c1">// proc(&lt;a&gt;a &lt;em&gt;b&lt;/em&gt; c&lt;/a&gt;) =&gt; &quot;It&#39;s an a: ArrayBuffer(a, &lt;em&gt;b&lt;/em&gt;, c)&quot;</span>
</code></pre></figure>
<h1 id="modular-programming">Modular Programming</h1>
<p>When a module grows too large for a single file, it may be useful to split the module up into separate traits defined in separate files, which can then be mixed into the original module.</p>
<p>A problem can arise when one such compartmentalized trait wants to refer to another trait that ultimately gets mixed into the same class. This can be circumvented by specifying the <em>self type</em> which essentially defines the value of type of <code>this</code> for whenever it’s referred to in the class. For example, assuming trait <code>Second</code> needs to refer to trait <code>First</code>’s method <code>count</code>, we can do:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">trait</span> <span class="nc">First</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">5</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Second</span> <span class="o">{</span>
  <span class="k">this:</span> <span class="kt">First</span> <span class="o">=&gt;</span>

  <span class="k">def</span> <span class="n">printCount</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">count</span><span class="o">())</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>It’s also possible to select types at runtime:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">db</span><span class="k">:</span> <span class="kt">Database</span> <span class="o">=</span>
  <span class="k">if</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="s">&quot;student&quot;</span><span class="o">)</span>
    <span class="nc">StudentDatabase</span>
  <span class="k">else</span>
    <span class="nc">SimpleDatabase</span>
</code></pre></figure>
<p>Sometimes the compiler won’t be able to determine that two types are the same, as in the following case:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">object</span> <span class="nc">Obj</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">db</span><span class="k">:</span> <span class="kt">Database</span> <span class="o">=</span> <span class="nc">SomeDatabase</span>

  <span class="k">object</span> <span class="nc">browser</span> <span class="k">extends</span> <span class="nc">Browser</span> <span class="o">{</span>
    <span class="c1">// compiler doesn&#39;t know `database` is</span>
    <span class="c1">// same type as `db`</span>
    <span class="k">val</span> <span class="n">database</span> <span class="k">=</span> <span class="n">db</span>
  <span class="o">}</span>

  <span class="c1">// error: type mismatch</span>
  <span class="c1">// found: db.SomeCategory</span>
  <span class="c1">// required: browser.database.SomeCategory</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">category</span> <span class="k">&lt;-</span> <span class="n">db</span><span class="o">.</span><span class="n">allCategories</span><span class="o">)</span>
    <span class="n">browser</span><span class="o">.</span><span class="n">displayCategory</span><span class="o">(</span><span class="n">category</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></figure>
<p>This can be resolved by using a singleton type through the <code>type</code> property, which is an extremely specific type that refers to the type of the specific object <a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">object</span> <span class="nc">browser</span> <span class="k">extends</span> <span class="nc">Browser</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">database</span><span class="k">:</span> <span class="kt">db.</span><span class="k">type</span> <span class="o">=</span> <span class="n">db</span>
<span class="o">}</span>
</code></pre></figure>
<h1 id="object-equality">Object Equality</h1>
<p>To recap, Scala’s equality operators are equivalent to Java’s <code>equals</code> methods, that is, unlike Java’s equality operators which refer to object identity for reference types. Object identity is available through the <code>eq</code> method though it’s rarely used.</p>
<p>There are four main pitfalls when defining equals methods:</p>
<ol type="1">
<li>wrong signature</li>
<li>changing it without also changing <code>hashCode</code></li>
<li>defining it in terms of mutable fields</li>
<li>failing to define it as an equivalent relation</li>
</ol>
<h2 id="wrong-signature">Wrong Signature</h2>
<p>Given a simple type like the following, the accompanying <code>equals</code> method is too naive. What happens is that when it’s added to a collection, it’s static type becomes <code>Any</code>, which would trigger the <code>equals</code> method for <code>Any</code> since overloading in Scala and Java is based on the static type. It turns out that the <code>equals</code> method in <code>Any</code> is simply object identity.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">y</span>
<span class="o">}</span>
</code></pre></figure>
<p>A more robust <code>equals</code> operator would assume that the parameter is of static type <code>Any</code>, and then perform a pattern match for its dynamic type:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</code></pre></figure>
<p>It’s also a common mistake to want to define the <code>==</code> operator directly, which is impossible since it’s defined as <code>final</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">final</span> <span class="k">def</span> <span class="o">==</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="n">eq</span> <span class="k">this</span><span class="o">)</span> <span class="o">{</span><span class="kc">null</span> <span class="n">eq</span> <span class="n">that</span><span class="o">}</span> <span class="k">else</span> <span class="o">{</span><span class="k">this</span> <span class="n">equals</span> <span class="n">that</span><span class="o">}</span>
</code></pre></figure>
<p>However, if this method is defined with a different parameter type, the compiler would regard it as an overloaded variant, and would allow the definition to occur, but the same problem would occur as above, where the parameter type isn’t <code>Any</code>.</p>
<h2 id="hash-code">Hash Code</h2>
<p>When the <code>equals</code> method is redefined, it’s also logically necessary to redefine the <code>hashCode</code> method, which by default is defined in <code>AnyRef</code> to be some transformation of the object’s address. In fact, if two objects are determined to be equal as per the <code>equals</code> method, then they must return the same <code>hashCode</code>.</p>
<p>The <code>hashCode</code> method can be defined for <code>Point</code> so that it only references fields that were used in <code>equals</code> for equality determination.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span><span class="mi">41</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="n">y</span>
</code></pre></figure>
<h2 id="mutable-fields">Mutable Fields</h2>
<p>Making the <code>hashCode</code> and as a result the <code>equals</code> method depend on mutable fields can have bad consequences. Adding an item to a collection and then changing that item’s mutable field, which itself aids in equivalence determination, will mean that the collection will no longer find the object, since the collection (a <code>HashSet</code>) will keep looking in the wrong bucket, where it would expect to find the item based on its new data representation. Instead it may have been better to avoid redefining <code>hashCode</code> and create a separate comparison function such as <code>equalContents</code>.</p>
<h2 id="equivalence-relation">Equivalence Relation</h2>
<p>The <code>equals</code> method should implement an equivalence relation on non-null objects, that is:</p>
<ul>
<li><p>it’s <em>reflexive</em>: for any non-null value x</p>
<p><code>x.equals(x) == true</code></p></li>
<li><p>it’s <em>symmetric</em>: for non-null values x and y</p>
<p><code>x.equals(y) == true == y​.equals(x)</code></p></li>
<li><p>it’s <em>transitive</em>: for non-null values x, y, and z</p>
<p><code>x.equals(y) &amp;&amp; y​.equals(z) == true == x​.equals(z)</code></p></li>
<li><p>it’s <em>consistent</em>: for non-null values x and y, multiple invocations of <code>x.equals(y)</code> should consistently return the same value provided no information used in equality determination is modified</p></li>
<li><p><code>x.equals(null)</code> should return false</p></li>
</ul>
<h2 id="subtype-equality">Subtypes</h2>
<p>There’s a mistake that can be made given a subtype that redefines its <code>equals</code> method. If a supertype is compared to a subtype and appears on the left hand side, it would invoke the supertype’s <code>equals</code> method which would <em>only</em> compare those properties common to both types, meaning that the equality would not be symmetric.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span> <span class="o">&amp;&amp;</span> <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">p</span>  <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">cp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Red</span><span class="o">)</span>

<span class="n">p</span>  <span class="n">equals</span> <span class="n">cp</span> <span class="o">==</span> <span class="kc">true</span>
<span class="n">cp</span> <span class="n">equals</span> <span class="n">p</span>  <span class="o">==</span> <span class="kc">false</span>
</code></pre></figure>
<p>A way to solve this is to define a <code>canEqual</code> method in classes that override <code>equals</code> and <code>hashCode</code>, which determines whether or not an object can be compared for equality with the given class. This allows subclasses of the class that redefined <code>canEqual</code> to continue to compare for equality with objects of the superclass. This is especially important for the anonymous class instantiation syntax:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span><span class="mi">41</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="n">y</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
      <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="kc">false</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.value</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="mi">41</span> <span class="o">*</span> <span class="k">super</span><span class="o">.</span><span class="n">hashCode</span> <span class="o">+</span> <span class="n">color</span><span class="o">.</span><span class="n">hashCode</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
      <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="kc">false</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">ColoredPoint</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></figure>
<h1 id="java-interop">Java Interop</h1>
<p>The Scala compiler will attempt to use direct mappings to Java value types, such as an <code>Int</code>. However, sometimes this assumption can’t be made, as in a collection, in which case it’ll use wrapper classes like <code>java​.lang​.Integer</code>.</p>
<p>Singleton <code>objects</code> the compiler creates a Java class with suffix <code>$</code> which contains all of the methods and fields of the Scala singleton object as well as a <code>MODULE$</code> static field that holds the singleton instance created at runtime. If the singleton object has no companion class then a class without the <code>$</code> suffix is created which has a static forwarder method for each method in the singleton object.</p>
<p>Traits get compiled down to Java interfaces if they only contain abstract methods.</p>
<h2 id="existential-types">Existential Types</h2>
<p>Existential types in Scala are mainly used to facilitate Java’s wildcard types and raw types. They take the form:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">type</span> <span class="k">forSome</span> <span class="o">{</span> <span class="kt">declarations</span> <span class="o">}</span>
</code></pre></figure>
<p>For example, the following is equivalent to Java’s <code>Iterator &lt;?&gt;</code> and reads as it being an <code>Iterator</code> of <code>T</code>’s for some type <code>T</code>. It’s also possible to use <em>placeholder syntax</em> which is similar to the one used in patterns. For each underscore present in the type a type parameter is added to the <code>forSome</code> clause:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="nc">Iterator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">T</span> <span class="o">}</span>

<span class="c1">// equivalently: placeholder syntax</span>
<span class="nc">Iterator</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>
</code></pre></figure>
<p>Similarly, Java’s <code>Iterator&lt;? extends Component&gt;</code> can be represented as follows in Scala, where it reads as being an <code>Iterator</code> of <code>T</code> for some type <code>T</code> that is a subtype of <code>Component</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="nc">Iterator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Component</span> <span class="o">}</span>

<span class="c1">// equivalently: placeholder syntax</span>
<span class="nc">Iterator</span><span class="o">[</span><span class="k">_</span> <span class="k">&lt;:</span> <span class="kt">Component</span><span class="o">]</span>
</code></pre></figure>
<p>Given a Java class with wildcards like this:</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wild</span> <span class="o">{</span>
  <span class="n">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">contents</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Collection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stuff</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
    <span class="n">stuff</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">);</span>
    <span class="n">stuff</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">);</span>
    <span class="n">stuff</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;see&quot;</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">stuff</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>If we want to create a new <code>Set</code> from the contents of this collection, we’ll have trouble naming the type:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">import</span> <span class="nn">scala.collection.mutable.Set</span>
<span class="k">val</span> <span class="n">iter</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Wild</span><span class="o">).</span><span class="n">contents</span><span class="o">.</span><span class="n">iterator</span>
<span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">???</span><span class="o">]</span> <span class="c1">// what type?</span>
<span class="k">while</span> <span class="o">(</span><span class="n">iter</span><span class="o">.</span><span class="n">hasMore</span><span class="o">)</span>
  <span class="n">set</span> <span class="o">+=</span> <span class="n">iter</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
</code></pre></figure>
<p>The solution to this is to create an abstract class with methods for each of the types in the <code>forSome</code> clause:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">SetAndType</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Elem</span> <span class="c1">// required for defining `set`</span>
  <span class="k">val</span> <span class="n">set</span><span class="k">:</span> <span class="kt">set</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">java2scala</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">jset</span><span class="k">:</span> <span class="kt">Collection</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">SetAndType</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">sset</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="c1">// T can be used, inferred from parameter</span>
  <span class="k">val</span> <span class="n">iter</span> <span class="k">=</span> <span class="n">jset</span><span class="o">.</span><span class="n">iterator</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">iter</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span>
    <span class="n">sset</span> <span class="o">+=</span> <span class="n">iter</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nc">SetAndType</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="n">T</span>
    <span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="n">sset</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<h2 id="compiling-heterogenous-projects">Compiling Heterogenous Projects</h2>
<p>Usually one would compile the Java code and add the output to the classpath when building the Scala code. However, this wouldn’t work if the Java code references the Scala code, or vice versa. For this reason, Scala allows processing of Java source files as if they were Scala files. They won’t be compiled, but they’ll be scanned to determine what they contain. This is done with this sequence of commands:</p>
<figure class="codeblock"><pre><code class="highlight language-bash"><span class="nv">$ </span>scalac -d bin FileAnalysis.scala FileItem.java File.java
<span class="nv">$ </span>javac -cp bin -d bin File.java FileItem.java FileManagement.java
<span class="nv">$ </span>scala -cp bin FileManagement
<span class="c"># program output</span>
</code></pre></figure>
<h1 id="actors-and-concurrency">Actors and Concurrency</h1>
<p>Scala uses actors similar to Erlang’s as its primary concurrency primitive. <strong>Note</strong> that this actors library is <a href="http://docs.scala-lang.org/overviews/core/actors-migration-guide.html">deprecated</a>; <a href="http://akka.io/">Akka</a> actors will be covered later and are the default actors library since Scala 2.10.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">import</span> <span class="nn">scala.actors._</span>

<span class="k">object</span> <span class="nc">PrintActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">act</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="s">&quot;acting&quot;</span><span class="o">)</span>
      <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nc">SillyActor</span><span class="o">.</span><span class="n">start</span><span class="o">()</span> <span class="c1">// prints &quot;acting&quot; five times</span>

<span class="c1">// equivalent: .start()s as soon as it&#39;s defined</span>
<span class="k">val</span> <span class="nc">PrintActor2</span> <span class="k">=</span> <span class="n">actor</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;acting&quot;</span><span class="o">)</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></figure>
<p>Actors can be sent messages using the <code>!</code> method. The following actor prints out the messages it receives:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">echoActor</span> <span class="k">=</span> <span class="n">actor</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">receive</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;received: &quot;</span> <span class="o">+</span> <span class="n">msg</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">echoActor</span> <span class="o">!</span> <span class="s">&quot;testing&quot;</span>
<span class="c1">// received: testing</span>
</code></pre></figure>
<p>The way this works is that the <code>receive</code> method accepts a partial function, which in this case is specified as a partial function literal <a href="#case-sequence">case sequence</a>. The actor will block until a message is received that matches a pattern in the partial function, and non-matching messages are silently ignored.</p>
<p>It’s also possible to treat “native” threads as actors through <code>Actor​.self</code>, which yields an actor representing the current thread. This is useful for debugging, by specifically setting a <code>receive</code> function:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">import</span> <span class="nn">scala.actors.Actor._</span>
<span class="n">self</span> <span class="o">!</span> <span class="s">&quot;hello&quot;</span>
<span class="n">self</span><span class="o">.</span><span class="n">receive</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">}</span>
<span class="c1">// res1: Any = hello</span>

<span class="c1">// 1 second timeout to avoid blocking repl</span>
<span class="n">self</span><span class="o">.</span><span class="n">receiveWithin</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">}</span>
</code></pre></figure>
<p>Every actor is given its own thread so that they can each perform the <code>act</code> method. This is resource heavy, so a <code>react</code> method can be used that is similar to <code>receive</code>. The <code>react</code> method doesn’t return after it finds and processes a message, instead it only evaluates the message handler. This means that the implementation doesn’t need to preserve the call stack of the current thread, allowing it to reuse the thread for the next actor that wakes up.</p>
<p>Since <code>react</code> doesn’t return, it’s usually common to return the information (if any) by sending the message to another actor, then recursing the message handler <code>act</code> to continue to process messages. This recursion pattern is common enough that there’s a method <code>loop</code> that can wrap around the <code>react</code> method so that it loops infinitely.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">object</span> <span class="nc">Resolver</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">java.net.</span><span class="o">{</span><span class="nc">InetAddress</span><span class="o">,</span> <span class="nc">UnknownHostException</span><span class="o">}</span>

  <span class="k">def</span> <span class="n">act</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">react</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">receiver</span><span class="k">:</span> <span class="kt">Actor</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">receiver</span> <span class="o">!</span> <span class="n">getIp</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
        <span class="n">act</span><span class="o">()</span>
      <span class="k">case</span> <span class="s">&quot;EXIT&quot;</span> <span class="k">=&gt;</span>
        <span class="n">println</span><span class="o">(</span><span class="s">&quot;exiting&quot;</span><span class="o">)</span> <span class="c1">// doesn&#39;t recurse again</span>
      <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span>
        <span class="n">println</span><span class="o">(</span><span class="s">&quot;unhandled msg: &quot;</span> <span class="o">+</span> <span class="n">msg</span><span class="o">)</span>
        <span class="n">act</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">getIp</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">InetAddress</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="nc">Some</span><span class="o">(</span><span class="nc">InetAddress</span><span class="o">.</span><span class="n">getByName</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
      <span class="k">case</span> <span class="k">_:</span><span class="kt">UnknownException</span> <span class="o">=&gt;</span> <span class="nc">None</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nc">Resolver</span><span class="o">.</span><span class="n">start</span><span class="o">()</span>

<span class="nc">Resolver</span> <span class="o">!</span> <span class="o">(</span><span class="s">&quot;www.scala-lang.org&quot;</span><span class="o">,</span> <span class="n">self</span><span class="o">)</span>
<span class="n">self</span><span class="o">.</span><span class="n">receiveWithin</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">}</span>
<span class="c1">// Some(ww.scala-lang.org/&lt;some-ip&gt;)</span>
</code></pre></figure>
<p>Actor’s shouldn’t block, such as while processing a message, since this can even cause deadlocks while actors wait on each other. If an actor needs to perform an operation that blocks in order to process a message, a separate actor should be created that performs the blocking operation and then notifies the original actor when its work is complete. In the following example, the actor will continue to accept requests even while it continues to perform blocking operations, which it delegates to a sub-actor.</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">val</span> <span class="n">someActor</span> <span class="k">=</span> <span class="n">actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">emoteLater</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">mainActor</span> <span class="k">=</span> <span class="n">self</span>
    <span class="n">actor</span> <span class="o">{</span>
      <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
      <span class="n">mainActor</span> <span class="o">!</span> <span class="s">&quot;Emote&quot;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">var</span> <span class="n">emoted</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="n">emoteLater</span><span class="o">()</span>

  <span class="n">loop</span> <span class="o">{</span>
    <span class="n">react</span> <span class="o">{</span>
      <span class="k">case</span> <span class="s">&quot;Emote&quot;</span> <span class="k">=&gt;</span>
        <span class="n">println</span><span class="o">(</span><span class="s">&quot;acting&quot;</span><span class="o">)</span>
        <span class="n">emoted</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">emoted</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">)</span>
          <span class="n">emoteLater</span><span class="o">()</span>
      <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span>
        <span class="n">println</span><span class="o">(</span><span class="s">&quot;received: &quot;</span> <span class="o">+</span> <span class="n">msg</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*</span>
<span class="cm">acting</span>
<span class="cm">acting</span>
<span class="cm">someActor ! &quot;hello&quot;</span>
<span class="cm">Received: hello</span>
<span class="cm">acting</span>
<span class="cm">acting</span>
<span class="cm">*/</span>
</code></pre></figure>
<p>It’s very important to communicate with actors only via messages. However, unlike Erlang’s actors, Scala allows mixing the traditional shared data &amp; locks model with actors. For example, if multiple actors were to share a common mutable map, there are two approaches that can be taken to achieve this. The first would entail creating an actor that owns the map, defining messages for every kind of map operation that would be required such as getting and setting values. An alternative approach, however, would be to pass a thread-safe map such as <code>ConcurrentHashMap</code>.</p>
<p>It’s also a good idea to keep actors self-contained. A good idea is to send contextual information about the request (if not the request itself) along with the response, to the original actor, since some time may have passed since the actor performed the request. It’s also more readable to create case classes when possible:</p>
<figure class="codeblock"><pre><code class="highlight language-scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">LookupIP</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">respondTo</span><span class="k">:</span> <span class="kt">Actor</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">LookupResult</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">address</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">InetAddress</span><span class="o">])</span>

<span class="k">object</span> <span class="nc">Resolver</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">act</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">loop</span> <span class="o">{</span>
      <span class="n">react</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">LookupIP</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">actor</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">actor</span> <span class="o">!</span> <span class="nc">LookupResult</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">getIp</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">getIp</span> <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>
</code></pre></figure>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Reminds me of Ruby’s ‘EigenClasses’, but I’m not quite sure yet if it’s indeed similar, or if companion objects truly are just a separation for specifying class-wide values/methods.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Reminds me of <code>std​::bind</code> in C++11, which does the same thing by creating a functor, or <a href="http://en.wikipedia.org/wiki/Function_object#In_C_and_C.2B.2B">function object</a> (not to be confused with the category theory <a href="http://en.wikipedia.org/wiki/Functor">Functor</a> more common in <a href="http://www.haskell.org/haskellwiki/Functor">Haskell</a>).<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Reminds me of Ruby’s modules that can be included.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>This is of course very similar to setters in Ruby, which take the form <code>attr=(arg)</code>.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>This reminds me of a <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html">Monoid</a>’s identity, <code>mempty</code> in the Haskell typeclass, but I doubt that <code>_</code> is backed by a Monoid typeclass because a Monoid would also require an associative binary operation. Perhaps it’s simply more like the <a href="http://hackage.haskell.org/package/data-default">default</a> package’s default typeclass.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>This reminds me of <a href="/notes/go/#interfaces">Go’s interfaces</a>.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Now that I’ve learned what implicit conversions are in Scala, I have formed an opinion about them. Implicit conversions are one of the parts that make C++ <a href="/notes/cpp/#conversion-ambiguity">very complex</a>. Scala’s implicit conversions don’t seem as complex as C++’s, here they’re implicit at the site of use, but explicit at the site of definition. In C++ it feels that they’re implicit on both ends, since you can have overloaded conversion operators and conversion constructors on either type, which is further made ambiguous with arithmetic type conversions.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>I wonder if these are similar to Haskell’s <a href="http://hackage.haskell.org/package/dlist/docs/Data-DList.html">difference lists</a>.<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>It seems like Scala uses mutability to leave optimization up to the developer. Contrast this with Haskell, where everything is immutable at the language level and the optimizations are done underneath at compile time or at the runtime level. The cons <code>:</code> in Haskell for example would also reuse the tail, creating a <a href="http://en.wikipedia.org/wiki/Persistent_data_structure#Linked_lists">persistent linked list</a>, but the developer doesn’t have to worry about how to best implement something like this for efficiency. Scala of course affords one more flexibility in how they implement something, but it expects that every developer be mindful of how best to implement things in the unusual functional and imperative environment.<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>Something like this would be implicit in Haskell due to its non-strict nature.<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>This is of course very much like <a href="http://golang.org/doc/effective_go.html#slices">Go’s slices</a> and <a href="http://static.rust-lang.org/doc/master/tutorial.html#vectors-and-strings">Rust’s slices</a>.<a href="#fnref11">↩</a></p></li>
<li id="fn12"><p>This reminds me of <a href="http://man7.org/linux/man-pages/man2/open.2.html">open file descriptions</a> which record the file offset and status flags. Duplicate file descriptors <a href="http://man7.org/linux/man-pages/man2/dup.2.html">share this information</a>. To avoid this, it’s necessary to perform a separate <code>open</code> call.<a href="#fnref12">↩</a></p></li>
<li id="fn13"><p>This <em>definitely</em> reminds me of Ruby’s EigenClasses.<a href="#fnref13">↩</a></p></li>
</ol>
</section></div>
  <div class="meta">
    <div class="meta-component"><i class="fa fa-calendar fa-fw"></i> October 12, 2013</div>
    <div class="meta-component"><i class="fa fa-code-fork fa-fw"></i> <a href="https://github.com/blaenk/blaenk.github.io/commits/source/provider/notes/scala.markdown">History</a><span class="hash">, <a href="https://github.com/blaenk/blaenk.github.io/commit/5fedf3b" title="prefer italic over bold">5fedf3b</a></span></div>
    <div class="meta-component"><i class="fa fa-pencil fa-fw"></i> <a href="..">Notes</a></div>
  </div>
</article>


    <footer id="footer">
  <div id="social">
    <a href="https://github.com/blaenk" title="github"><i class="fa fa-github-alt"></i></a>
    &middot;
    <a href="http://stackoverflow.com/users/101090/jorge-israel-pena" title="stackoverflow"><i class="fa fa-stack-overflow"></i></a>
    &middot;
    <a href="https://twitter.com/blaenk" title="twitter"><i class="fa fa-twitter"></i></a>
    &middot;
    <a href="mailto:jorge.israel.p@gmail.com" title="email"><i class="fa fa-envelope"></i></a>
    &middot;
    <a href="/atom.xml" title="feed"><i class="fa fa-rss-square"></i></a>
  </div>
  <!-- <div id="credit">
    Designed by <a href="http://www.blaenkdenum.com">Jorge Israel Peña</a>
  </div> -->
</footer>





<!-- google analytics -->
<script async="true" type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37339861-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

<!--MathJax CDN-->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    messageStyle: "none"
  });

  MathJax.Hub.Register.MessageHook('End Process', function() {
    jQuery('#MathJax_Font_Test').empty();
    jQuery('.MathJax_Display').parent('.math').addClass('mobile-math');
  });
</script>
<script async="true" type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>

  </div>
</body>
</html>
