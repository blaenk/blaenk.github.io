<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>C++ - Blaenk Denum</title>
  <meta name="author" content="Jorge Israel Peña">
  <meta name="description" content="AKA Blaenk Denum">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="/favicon.png" rel="shortcut icon">
  <link href='http://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Merriweather:900italic,900,700italic,400italic,700,400,300italic,300' rel='stylesheet' type='text/css'>
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='/css/screen.css' rel='stylesheet' type='text/css' />
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured"></script>
  <script src="https://rawgit.com/ekalinin/typogr.js/master/typogr.min.js"></script>
  <script src='/js/blaenk.js' type='text/javascript'></script>
</head>
<body>
  <div class="page-wrapper">
    <header id="header">
  <div id="stamp">
    <h1 id="name">
      <a href="/">
        <span class="emboldened">Jorge</span>.Israel.<span class="emboldened">Peña</span>
      </a>
    </h1>
    <h4 id="pseudonym">
      AKA <span class="emboldened">Blaenk</span>.Denum
    </h4>
  </div>
  <nav id="main-nav">
    <ul class="main">
      <li><a href="/about/">About</a></li>
      <li><a href="/notes/">Notes</a></li>
      <li><a href="/work/">Work</a></li>
      <li><a href="/lately/">Lately</a></li>
      <li><a id="search_btn">Search</a></li>
    </ul>
  </nav>
  <nav id="mobile-nav">
    <div class="menu">
      <a class="button">Menu</a>
      <div class="container">
        <ul class="main">
          <li><a href="/about/">About</a></li>
          <li><a href="/notes/">Notes</a></li>
          <li><a href="/work/">Work</a></li>
          <li><a href="/lately/">Lately</a></li>
        </ul>
      </div>
    </div>
    <div class="search">
      <a class="button"></a>
      <div class="container">
        <form action="http://google.com/search" method="get">
          <input type="text" name="q" results="0">
          <input type="hidden" name="q" value="site:blaenkdenum.com">
        </form>
      </div>
    </div>
  </nav>
</header>
<form class="desk_search" action="http://google.com/search" method="get">
  <input id="search" type="text" name="q" results="0" placeholder="Search" autocomplete="off" spellcheck="false">
  <input type="hidden" name="q" value="site:blaenkdenum.com">
</form>

    
        <article class="post">
  <h2 class="title"><a href="/notes/cpp"><span>C++</span></a></h2>
  <div class="entry-content"><p>A lot of people really dislike C++ because it&#39;s a very complex language that often catches one by surprise. Despite this, C++ is undisputed when it comes to striking a balance between abstraction and speed. Those that need to use it for these reasons generally take one of two approaches, while the rest completely dismiss it as an option to begin with.</p>

<p>The first consists of restricting its usage to a specific subset of the language specification; for example, exceptions are generally avoided.</p>

<p>The other approach, perhaps an extreme, is for people to become &quot;language lawyers,&quot; poring over the language specification for every minute detail.</p>

<p>I try to take a pragmatic approach. I do appreciate C++&#39;s advantage in striking a balance between speed and abstraction, I do limit my use of it to a certain subset of the language, and I do try to learn as much about the language short of actually reading the specification to lower the probability that the language may catch me off guard.</p>

<p>To that end, these are non-exhaustive notes about C++---particularly the trickier bits---including C++11 and C++14 changes.</p>

<p>For C++11 in particular, some compilers are faster than others at adopting the new feature set. <a href="http://msdn.microsoft.com/en-us/library/vstudio/hh567368%28v=vs.120%29.aspx">Visual Studio</a> is particularly behind the rest, while <a href="http://clang.llvm.org/cxx_status.html">Clang</a> and <a href="http://gcc.gnu.org/projects/cxx0x.html">GCC</a> seem to be very quick on adopting the new features.</p>

<nav id="toc">
<h3>Contents</h3><ol>
<li>
<a href="#type-aliasing">Type Aliasing</a>
</li>
<li>
<a href="#lookup">Lookup</a>
<ol>
<li>
<a href="#overload-resolution">Overload Resolution</a>
</li>
</ol>
</li>
<li>
<a href="#constexpr">constexpr</a>
</li>
<li>
<a href="#decltype">decltype</a>
</li>
<li>
<a href="#auto">auto</a>
</li>
<li>
<a href="#new">new</a>
</li>
<li>
<a href="#type-conversions">Type Conversions</a>
<ol>
<li>
<a href="#pointer-decay">Pointer Decay</a>
</li>
<li>
<a href="#c-style-casts">C-Style Casts</a>
</li>
<li>
<a href="#functional-casts">Functional Casts</a>
</li>
<li>
<a href="#static_cast">static_cast</a>
</li>
<li>
<a href="#const_cast">const_cast</a>
</li>
<li>
<a href="#dynamic_cast">dynamic_cast</a>
</li>
<li>
<a href="#reinterpret_cast">reinterpret_cast</a>
</li>
<li>
<a href="#signed-to-unsigned">Signed-to-Unsigned</a>
</li>
<li>
<a href="#integer-promotion">Integer Promotion</a>
</li>
<li>
<a href="#mixing-unsigned-types">Mixing Unsigned Types</a>
</li>
<li>
<a href="#negative-modulus">Negative Modulus</a>
</li>
</ol>
</li>
<li>
<a href="#exceptions">Exceptions</a>
</li>
<li>
<a href="#lambdas">Lambdas</a>
</li>
<li>
<a href="#enumerations">Enumerations</a>
</li>
<li>
<a href="#temporaries">Temporaries</a>
</li>
<li>
<a href="#value-categories">Value Categories</a>
</li>
<li>
<a href="#static-variables">Static Variables</a>
</li>
<li>
<a href="#templates">Templates</a>
<ol>
<li>
<a href="#parameter-packs">Parameter Packs</a>
</li>
<li>
<a href="#template-specialization">Template Specialization</a>
</li>
<li>
<a href="#variable-templates">Variable Templates</a>
</li>
<li>
<a href="#function-templates">Function Templates</a>
</li>
<li>
<a href="#template-template-parameters">Template Template Parameters</a>
</li>
<li>
<a href="#integral-template-parameters">Integral Template Parameters</a>
</li>
<li>
<a href="#explicit-template-instantiation">Explicit Template Instantiation</a>
</li>
<li>
<a href="#implicit-template-instantiation">Implicit Template Instantiation</a>
</li>
<li>
<a href="#member-templates">Member Templates</a>
</li>
<li>
<a href="#template-argument-deduction">Template Argument Deduction</a>
</li>
</ol>
</li>
<li>
<a href="#move-semantics">Move Semantics</a>
<ol>
<li>
<a href="#rvalue-references">rvalue-references</a>
<ol>
<li>
<a href="#reference-collapsing">Reference Collapsing</a>
</li>
<li>
<a href="#type-matching">Type-Matching</a>
</li>
<li>
<a href="#reference-qualifiers">Reference Qualifiers</a>
</li>
</ol>
</li>
</ol>
</li>
<li>
<a href="#classes">Classes</a>
<ol>
<li>
<a href="#rule-of-five">Rule of Five</a>
</li>
<li>
<a href="#rule-of-zero">Rule of Zero</a>
</li>
<li>
<a href="#class-initialization">Class Initialization</a>
<ol>
<li>
<a href="#member-initialization">Member Initialization</a>
</li>
<li>
<a href="#list-initialization">List-Initialization</a>
</li>
<li>
<a href="#aggregate-initialization">Aggregate-Initialization</a>
</li>
<li>
<a href="#constant-initialization">Constant-Initialization</a>
</li>
<li>
<a href="#copy-initialization">Copy-Initialization</a>
</li>
<li>
<a href="#copy-list-initialization">Copy-List-Initialization</a>
</li>
<li>
<a href="#direct-initialization">Direct-Initialization</a>
</li>
<li>
<a href="#direct-list-initialization">Direct-List-Initialization</a>
</li>
<li>
<a href="#default-initialization">Default-Initialization</a>
</li>
<li>
<a href="#value-initialization">Value-Initialization</a>
</li>
<li>
<a href="#zero-initialization">Zero-Initialization</a>
</li>
</ol>
</li>
<li>
<a href="#access-specifiers">Access Specifiers</a>
</li>
<li>
<a href="#base-classes">Base Classes</a>
</li>
<li>
<a href="#virtual-base-classes">Virtual Base Classes</a>
</li>
<li>
<a href="#default-constructors">Default Constructors</a>
</li>
<li>
<a href="#destructors">Destructors</a>
</li>
<li>
<a href="#copy-constructors">Copy Constructors</a>
</li>
<li>
<a href="#copy-assignment-operators">Copy-Assignment Operators</a>
</li>
<li>
<a href="#move-constructors">Move Constructors</a>
</li>
<li>
<a href="#move-assignment-operator">Move-Assignment Operator</a>
<ol>
<li>
<a href="#synthesis">Synthesis</a>
</li>
</ol>
</li>
<li>
<a href="#conversions">Conversions</a>
<ol>
<li>
<a href="#converting-constructors">Converting Constructors</a>
</li>
<li>
<a href="#conversion-operators">Conversion Operators</a>
</li>
<li>
<a href="#conversion-ambiguity">Conversion Ambiguity</a>
<ol>
<li>
<a href="#mutual-conversions">Mutual Conversions</a>
</li>
<li>
<a href="#redundant-built-in-conversions">Redundant Built-In Conversions</a>
</li>
</ol>
</li>
</ol>
</li>
<li>
<a href="#delete">Delete</a>
</li>
<li>
<a href="#swapping">Swapping</a>
</li>
<li>
<a href="#inheritance">Inheritance</a>
<ol>
<li>
<a href="#virtual-functions">Virtual Functions</a>
</li>
<li>
<a href="#constructors">Constructors</a>
</li>
<li>
<a href="#inherited-constructors">Inherited Constructors</a>
</li>
<li>
<a href="#copy-and-move-operations">Copy and Move Operations</a>
</li>
<li>
<a href="#copy-assignment-operator">Copy-Assignment Operator</a>
</li>
<li>
<a href="#destructors">Destructors</a>
</li>
</ol>
</li>
<li>
<a href="#operator-overloading">Operator Overloading</a>
</li>
<li>
<a href="#size-of-every-object">Size of Every Object</a>
</li>
</ol>
</li>
<li>
<a href="#namespaces">Namespaces</a>
</li>
<li>
<a href="#raw-strings">Raw Strings</a>
</li>
<li>
<a href="#unicode-strings">Unicode Strings</a>
</li>
<li>
<a href="#static-assertions">Static Assertions</a>
</li>
<li>
<a href="#attributes">Attributes</a>
</li>
<li>
<a href="#source-translation">Source Translation</a>
</li>
<li>
<a href="#volatile">volatile</a>
</li>
<li>
<a href="#performance">Performance</a>
</li>
<li>
<a href="#duff39s-device">Duff&#39;s Device</a>
</li>
<li>
<a href="#user-defined-literals">User-Defined Literals</a>
</li>
<li>
<a href="#unions">Unions</a>
</li>
<li>
<a href="#linkage">Linkage</a>
</li>
<li>
<a href="#elaborated-type-specifier">Elaborated Type Specifier</a>
</li>
<li>
<a href="#standard-template-library">Standard Template Library</a>
<ol>
<li>
<a href="#initializer-lists">Initializer Lists</a>
</li>
<li>
<a href="#integral_constant">integral_constant</a>
</li>
<li>
<a href="#array">Array</a>
</li>
<li>
<a href="#pairs">Pairs</a>
</li>
<li>
<a href="#tuples">Tuples</a>
</li>
<li>
<a href="#unordered-containers">Unordered Containers</a>
</li>
<li>
<a href="#bitsets">Bitsets</a>
</li>
<li>
<a href="#strings">Strings</a>
</li>
<li>
<a href="#numeric-limits">Numeric Limits</a>
</li>
<li>
<a href="#smart-pointers">Smart Pointers</a>
<ol>
<li>
<a href="#unique_ptr">unique_ptr</a>
</li>
<li>
<a href="#shared_ptr">shared_ptr</a>
</li>
</ol>
</li>
<li>
<a href="#callables">Callables</a>
</li>
<li>
<a href="#iterators">Iterators</a>
</li>
<li>
<a href="#collection-exception-safety">Collection Exception-Safety</a>
</li>
<li>
<a href="#algorithms">Algorithms</a>
<ol>
<li>
<a href="#testing">Testing</a>
</li>
<li>
<a href="#searching">Searching</a>
</li>
<li>
<a href="#reducing">Reducing</a>
</li>
<li>
<a href="#mutating">Mutating</a>
</li>
<li>
<a href="#sorting">Sorting</a>
</li>
<li>
<a href="#partitioning">Partitioning</a>
</li>
<li>
<a href="#transferring">Transferring</a>
</li>
<li>
<a href="#sets">Sets</a>
</li>
<li>
<a href="#heaps">Heaps</a>
</li>
<li>
<a href="#permutations">Permutations</a>
</li>
</ol>
</li>
<li>
<a href="#random">Random</a>
</li>
<li>
<a href="#concurrency">Concurrency</a>
</li>
</ol>
</li>
</ol>
</nav>
<h1 id="type-aliasing">
<span class="hash">#</span>
<a href="#type-aliasing" class="header-link">Type Aliasing</a>
</h1>
<p>Type aliases are similar to <code>typedef</code>s but they can also be used with template names.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">using</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ios_base</span><span class="o">::</span><span class="n">fmtflags</span><span class="p">;</span>
<span class="k">using</span> <span class="n">func</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">T</span><span class="o">*</span><span class="p">;</span>

<span class="c1">// int* = ptr&lt;int&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">B</span> <span class="o">=</span> <span class="n">Blah</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// B&lt;int&gt; == Blah&lt;int&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Container</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typename</span> <span class="n">Container</span><span class="o">::</span><span class="n">value_type</span> <span class="n">n</span><span class="p">;</span>
</code></pre></figure>
<p>A <em>dependent name</em> is one that depends on a type parameter. For example, in the following code, <code>ty</code> is a dependent name because its lookup depends on the type of template argument <code>T</code>, such that it can&#39;t be looked up until the template argument is known. For example, <code>T::C</code> may end up being a type for one <code>T</code> while it may be a static integer member for another <code>T</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="n">T</span><span class="o">::</span><span class="n">C</span> <span class="n">ty</span><span class="p">;</span>  <span class="c1">// ambiguous whether it&#39;s a type or value</span>
<span class="p">};</span>
</code></pre></figure>
<p>A dependent name is assumed to not name a type unless the name is qualified with the <code>typename</code> specifier. A <code>typename</code> specifier isn&#39;t necessary in certain simple cases, such as <code>T *ptr</code>. The <code>typename</code> specifier is only allowed for qualified names, unqualified names are assumed to be types.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">C</span> <span class="n">ty</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</code></pre></figure>
<p>A name that is not a member of the current instantiation and is dependent on a template argument is not considered a type unless it&#39;s marked with the <code>typename</code> specifier <em>or</em> it was defined as a type name, such as via a <code>typedef</code> or a <code>using</code> alias.</p>

<p>The same applies to templates. Consider the following <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">;</span>
</code></pre></figure>
<p>Consider the following implementation of <code>boost::function</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">function</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>In this case, the original code would end up being parsed as <code>boost::function</code> which is zero, compared to <code>int()</code> which is zero, compared to <code>f</code>.</p>

<p>In order to explicitly specify that a name is a template, the <code>template</code> specifier can be used:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span><span class="o">::</span><span class="k">template</span> <span class="n">foo</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">s</span><span class="p">.</span><span class="k">template</span> <span class="n">foo</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">();</span>

<span class="k">this</span><span class="o">-&gt;</span><span class="k">template</span> <span class="n">foo</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">();</span>

<span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="k">template</span> <span class="n">iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="n">v</span><span class="p">;</span>
</code></pre></figure><h1 id="lookup">
<span class="hash">#</span>
<a href="#lookup" class="header-link">Lookup</a>
</h1>
<p>The non-right side of the scope resolution operator during unqualified or qualified lookup only considers namespaces, class types, enumerations, or templates whose specializations are types.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">A</span><span class="p">;</span>
  <span class="n">A</span><span class="o">::</span><span class="n">n</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// OK: unqualified lookup ignores the variable</span>
  <span class="n">A</span> <span class="n">b</span><span class="p">;</span>       <span class="c1">// error: unqualified lookup of A finds the variable A</span>
<span class="p">}</span>
</code></pre></figure>
<p>Argument-dependent lookup (ADL) makes it possible to use operators defined in a different namespace. For example, ADL finds the correct definition of the stream insertion operator because its argument is in the <code>std</code> namespace.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="s">&quot;Test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</code></pre></figure>
<p>ADL is not considered if the lookup set produced by unqualified lookup contains any of:</p>

<ul>
<li>class member declaration</li>
<li>block-scope function declaration</li>
<li>any non-function &amp; non-function template declaration</li>
</ul>

<p>ADL checks each function call argument and template function template argument to determine the associated set of namespaces and classes it will add to the lookup.</p>

<p>ADL adds an associated set of namespaces and classes for every argument in a function call of type:</p>

<ol>
<li>fundamental type: empty</li>
<li>class type, including unions: add:

<ol>
<li>the class</li>
<li>its direct/indirect base classes</li>
<li>enclosing class (if any)</li>
<li>enclosing namespaces</li>
</ol></li>
<li>template specialization: add:

<ol>
<li>the types of all template arguments for type template parameters</li>
<li>classes and namespaces in which template template arguments are members</li>
</ol></li>
<li>enumeration: class and namespace it&#39;s defined in</li>
<li>pointer to <code>T</code> or array of <code>T</code>: ADL set of <code>T</code></li>
<li>function: ADL set of parameters and return type</li>
<li>pointer-to-member function <code>F</code> of class <code>X</code>: ADL set of parameter types, return type, and class <code>X</code></li>
<li>type pointer-to-data member <code>T</code> of class <code>X</code>: ADL set of member type <code>T</code> and class <code>X</code></li>
<li>name or address-of expression for overloaded function or function template: ADL set of every function in overload set

<ol>
<li>if named by template name and arguments: ADL set of type template arguments and template template arguments</li>
</ol></li>
</ol>

<p>A condensed summary of ADL specifies that the associated-namespaces are:</p>

<ul>
<li>class member: the class itself, its base classes, and enclosing namespaces</li>
<li>namespace member: enclosing namespaces</li>
<li>built-in type: none</li>
</ul>

<p>Due to ADL, non-member functions and operators defined in the same namespace as a class are considered part of the public interface of that class.</p>

<p>ADL only applies during unqualified lookup of function names in function-call expressions.</p>

<p>ADL can find a friend function that is defined entirely within a class or class template even if it was never declared at namespace level.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">number</span> <span class="p">{</span>
 <span class="n">number</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

 <span class="k">friend</span> <span class="n">number</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">number</span> <span class="n">x</span><span class="p">,</span> <span class="n">number</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">};</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span>
 <span class="n">number</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
 <span class="n">a</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p>A function call to a function template with explicitly-specified template arguments requires a declaration of the template found by ordinary lookup, such as via a using-declaration:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">namespace</span> <span class="n">N1</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">S</span> <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">X</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">N2</span> <span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">N1</span><span class="o">::</span><span class="n">S</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">f</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>     <span class="c1">// syntax error: unqualified lookup finds no `f`</span>
  <span class="n">N2</span><span class="o">::</span><span class="n">f</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// error: wrong `f`, no ADL because qualified</span>

  <span class="k">using</span> <span class="n">N2</span><span class="o">::</span><span class="n">f</span><span class="p">;</span>
  <span class="n">f</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// ok: unqualified lookup finds N2::f,</span>
           <span class="c1">// ADL kicks in and finds N1::f</span>
<span class="p">}</span>
</code></pre></figure>
<p>When a name appears to the right of the scope resolution operator <code>::</code>, it is looked up via qualified lookup. Otherwise it is looked up using unqualified lookup. Note that this means that the <code>std</code> in <code>std::cout</code> will be looked up with unqualified lookup, while <code>cout</code> via qualified lookup.</p>

<p>For example, given the following:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">namespace</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">X</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">Y</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">B</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 1</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">A</span><span class="o">::</span><span class="n">X</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// 2</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">h</span><span class="p">(</span><span class="n">A</span><span class="o">::</span><span class="n">Y</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">h</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="c1">// 3</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure>
<p>The following results are observed:</p>

<ol>
<li>endless recursion because ADL is not used since <code>int</code> is a fundamental type, and unqualified lookup finds <code>B::f</code>.</li>
<li>ambiguity error because unqualified lookup finds <code>B::q</code> and ADL finds <code>A::g</code>.</li>
<li>endless recursion because ADL finds no <code>A::h</code> and unqualified lookup finds <code>B::h</code>.</li>
</ol>

<p>Given the following expression:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></figure>
<p>Each of the names are looked up as follows:</p>

<ul>
<li><code>std</code>: unqualified lookup finds the namespace in <code>&lt;iostream&gt;</code></li>
<li><code>cout</code>: qualified lookup finds the variable declaration in <code>std</code></li>
<li><code>endl</code>: qualified lookup finds the function template declaration in <code>std</code></li>
<li><code>operator&lt;&lt;</code>: ADL finds multiple function template declarations in <code>std</code></li>
</ul>
<h2 id="overload-resolution">
<span class="hash">#</span>
<a href="#overload-resolution" class="header-link">Overload Resolution</a>
</h2>
<p>Overload resolution ranks candidate functions as:</p>

<ol>
<li>exact match: no conversions</li>
<li>promotions: integral promotion or <code>float</code> to <code>double</code></li>
<li>standard conversions: <code>int</code> ↔ <code>double</code>, <code>Derived*</code> to <code>Base*</code>, <code>T*</code> to <code>void*</code>, <code>int</code> to <code>unsigned</code></li>
<li>user-defined conversions: <code>double</code> to <code>complex&lt;double&gt;</code></li>
<li>ellipsis: <code>...</code> in a function declaration, e.g. <code>printf</code></li>
</ol>

<p>If more than one match is found at the highest level where a match is found, the call is rejected as ambiguous.</p>

<p>If a function and a template specialization are equally good matches for overload resolution, the function is preferred.</p>

<p>Overload resolution only considers the functions of a single scope. Use a using-declaration to bring declarations into scope.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
  <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// calls f(double)</span>
<span class="p">}</span>
</code></pre></figure>
<p>Overloading a function on both integral and pointer types should be avoided because calling the function with <code>0</code> will call the integral overload, not the pointer-type overload, unless the caller <em>always</em> uses <code>nullptr</code> instead of <code>0</code>.</p>

<p>Overloading functions for which an overload taking a forwarding reference exists is discouraged because the forwarding reference overload will be very greedy, inducing perfect matches in situations where conversions would have matched more appropriate overloads.</p>

<p>Passing overloaded functions can lead to ambiguity errors. This can be resolved by explicitly selecting the desired overload by casting the function to the desired prototype.</p>
<h1 id="constexpr">
<span class="hash">#</span>
<a href="#constexpr" class="header-link">constexpr</a>
</h1>
<p><code>constexpr</code> functions yield compile-time constants when called with compile-time constants, otherwise they return runtime values if called with runtime values.</p>

<p>Constructors and member functions can be <code>constexpr</code>.</p>

<p><code>constexpr</code> forms part of the type&#39;s interface. That is, adding for example I/O for debugging purposes would no longer permit <code>constexpr</code>, which could break a lot of existing code.</p>
<h1 id="decltype">
<span class="hash">#</span>
<a href="#decltype" class="header-link">decltype</a>
</h1>
<table>
<thead>
<tr>
<th style="text-align: left">Input</th>
<th style="text-align: left">Deduction</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">identifier</td>
<td style="text-align: left">type</td>
</tr>
<tr>
<td style="text-align: left"><code>(identifier)</code></td>
<td style="text-align: left">lvalue reference of type</td>
</tr>
<tr>
<td style="text-align: left"><code>function()</code></td>
<td style="text-align: left">return type</td>
</tr>
<tr>
<td style="text-align: left">rvalue</td>
<td style="text-align: left">rvalue reference type</td>
</tr>
<tr>
<td style="text-align: left">lvalue</td>
<td style="text-align: left">lvalue reference type</td>
</tr>
</tbody>
</table>

<p>The <code>decltype</code> operator can deduce and &quot;return&quot; the type of the argument to be used to declare something else such as a variable of a function. The rules for what gets returned depends on the expression:</p>

<ul>
<li><strong>identifier</strong> (name of object or function) or <strong>class member access</strong>, <em>yieds</em> type of identifier or class member access</li>
<li><strong>parenthesized identifier</strong> becomes an lvalue expresion, <em>yields</em> lvalue reference to type of expression</li>
<li><strong>function call</strong>, <em>yields</em> return type of the function</li>
<li><strong>rvalue</strong>, <em>yields</em> rvalue reference to type of expression</li>
<li><strong>lvalue</strong>, <em>yields</em> lvalue reference to type of expression</li>
</ul>

<p>The suffix-return syntax is useful when the return type is deduced from information---such as the function arguments---and has to appear after the function argument list so that the arguments are &quot;in scope&quot;:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>Suffix-return syntax can also be useful in class methods in classes with nested types. Given the following class:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">LL</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Link</span> <span class="p">{};</span>
  <span class="n">Link</span> <span class="o">*</span><span class="nf">erase</span><span class="p">(</span><span class="n">Link</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></figure>
<p>Given the following declaration:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">LL</span><span class="o">::</span><span class="n">Link</span> <span class="o">*</span><span class="n">LL</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">Link</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></figure>
<p>Using suffix-return syntax, after the compiler reads <code>LL::erase</code> it enters the class scope of <code>LL</code>, making it unnecessary to fully qualify the <code>Link</code> type that&#39;s nested within <code>LL</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">auto</span> <span class="n">LL</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">Link</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Link</span> <span class="o">*</span> <span class="p">{}</span>
</code></pre></figure><h1 id="auto">
<span class="hash">#</span>
<a href="#auto" class="header-link">auto</a>
</h1>
<p>The <code>auto</code> keyword allows for type-deduction and should be preferred in the following circumstances:</p>

<ul>
<li>when an expression would otherwise be repeated on both sides</li>
<li>lambdas, though can also use <code>std::function</code></li>
<li>iterators and other long type names</li>
</ul>

<p><code>auto</code> type deduction rules are the same as that of Template Argument Deduction, except when initialized with a braced-init-list in which case the type is deduced to be <code>std::iitializer_list</code>.</p>

<p><code>auto</code> variable type deduction rules follow those of Template Argument Deduction (TAD), that is, <code>auto&amp;&amp;</code> is deduced as an lvalue reference or rvalue reference.</p>

<p>Note that the use of <code>auto</code> in a function&#39;s trailing return type does <em>not</em> perform automatic type deduction.</p>

<p>When <code>auto</code> is used as the function return type, TAD is used on the <code>return</code> statement&#39;s operand. Note that if an lvalue reference is returned, TAD will ignore/remove the reference. To return an lvalue reference, <code>decltype</code> deduction rules must be used instead:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">I</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">I</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">authenticate</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// returns Element not Element&amp;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">I</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">I</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">authenticate</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></figure>
<p>When <code>decltype(auto)</code> is used for variable type deduction, the <code>auto</code> keyword is replaced with the expression of the initializer, then regular <code>decltype</code> deduction rules take place.</p>

<p>When <code>decltype(auto)</code> is used as a function&#39;s return type, the <code>auto</code> keyword is replaced with the <code>return</code> statement&#39;s operand, then regular <code>decltype</code> deduction rules take place.</p>

<p>Lambda parameters can be declared <code>auto</code>.</p>

<p>When <code>auto</code> is used on a <code>new</code> expression, the type is deduced from the initializer.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="k">auto</span><span class="p">(</span><span class="sc">&#39;x&#39;</span><span class="p">);</span>
</code></pre></figure>
<p>Sometimes it&#39;s necessary to use the <em>explicitly-typed initializer</em> idiom to guide <code>auto</code> type deduction. For example, <code>vector&lt;bool&gt;::operator[]</code> returns a proxy class <code>vector&lt;bool&gt;::reference</code> as an implementation detail which implicitly converts to <code>bool</code>. However, if using <code>auto</code> type deduction the type will be declared as <code>vector&lt;bool&gt;::reference</code> instead of the desired <code>bool</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">auto</span> <span class="n">isSet</span> <span class="o">=</span> <span class="n">bool_vector</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// doesn&#39;t deduce to bool</span>
<span class="k">auto</span> <span class="n">isSet</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bool_vector</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</code></pre></figure><h1 id="new">
<span class="hash">#</span>
<a href="#new" class="header-link">new</a>
</h1>
<p>Calling <code>delete</code> on a <code>nullptr</code> does not call any destructors or deallocators.</p>

<p>Creating a dynamic array with <code>new</code> has the restriction that only the first dimension can be dynamic; all the other dimensions must be an integral constant expression.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">5</span><span class="p">];</span> <span class="c1">// Error</span>

<span class="k">auto</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">5</span><span class="p">];</span> <span class="c1">// OK</span>
<span class="k">auto</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">n</span><span class="p">];</span> <span class="c1">// Error</span>
</code></pre></figure>
<p>Placement-<code>new</code> can be used to construct objects in storage that has already been allocated. Objects can be destroyed without deallocating their storage by explicitly calling their destructors.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
<span class="n">T</span><span class="o">*</span> <span class="n">tptr</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="n">T</span><span class="p">;</span> <span class="c1">// construct in ptr storage</span>

<span class="n">tptr</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>   <span class="c1">// destruct</span>
<span class="k">delete</span><span class="p">[]</span> <span class="n">ptr</span><span class="p">;</span> <span class="c1">// deallocate</span>
</code></pre></figure><h1 id="type-conversions">
<span class="hash">#</span>
<a href="#type-conversions" class="header-link">Type Conversions</a>
</h1>
<p>The result of a cast expression is:</p>

<ul>
<li>an lvalue if <code>new_type</code> is an lvalue reference type or rvalue reference to function type</li>
<li>xvalue if <code>new_type</code> is rvalue reference to object type</li>
<li>prvalue otherwise</li>
</ul>
<h2 id="pointer-decay">
<span class="hash">#</span>
<a href="#pointer-decay" class="header-link">Pointer Decay</a>
</h2>
<p>Array-to-pointer decay for multidimensional arrays only converts the array to a pointer to the <em>first</em> element, row, or plane. The pointer type has to be the type of the first element, row, or plane.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>         <span class="c1">// first element</span>

<span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
<span class="c1">// int *err = b;     // can&#39;t convert int (*)[3][4] to int*</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p2</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>    <span class="c1">// first 3-element row</span>

<span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p3</span><span class="p">)[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// first 3x4 element plane</span>
</code></pre></figure>
<p>A function name automatically converts to a pointer to that function.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">;</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">p2</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
</code></pre></figure>
<p>For a pointer-to-member, only the type of the member matters, not which <em>specific member</em> is being poitned to. Pointer-to-members can also point to member functions. Members are dereferenced with the syntax <code>.*</code> or <code>-&gt;*</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">C</span> <span class="p">{</span>
 <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
 <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">C</span><span class="o">::*</span> <span class="n">data_member</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">m</span><span class="p">;</span>
<span class="kt">void</span> <span class="p">(</span><span class="n">C</span><span class="o">::*</span> <span class="n">member_function</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">f</span><span class="p">;</span>

<span class="n">C</span> <span class="n">c</span>   <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">};</span>  <span class="n">c</span><span class="p">.</span><span class="o">*</span><span class="n">data_member</span><span class="p">;</span>
<span class="n">C</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>   <span class="n">cp</span><span class="o">-&gt;*</span><span class="n">data_member</span><span class="p">;</span>

<span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="o">*</span><span class="n">member_function</span><span class="p">)(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></figure>
<p>A pointer-to-member of a base class can be implicitly converted to a pointer to the same member of a derived class.</p>

<p>A pointer-to-member of derived class can be used on the base class by converting it to a pointer-to-member of base class via <code>static_cast</code>. It&#39;s undefined behavior if the base class doesn&#39;t contain the member.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">Base</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">Derived</span> <span class="p">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">m</span><span class="p">;</span> <span class="p">};</span>

<span class="kt">int</span> <span class="n">Derived</span><span class="o">::*</span> <span class="n">dp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Derived</span><span class="o">::</span><span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">Base</span><span class="o">::*</span> <span class="n">bp</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">Base</span><span class="o">::*&gt;</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
</code></pre></figure>
<p>The type of a pointer-to-member can itself be a pointer-to-member.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">A</span><span class="o">::*</span> <span class="k">const</span> <span class="n">p</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">A</span><span class="o">::*</span> <span class="k">const</span> <span class="n">A</span><span class="o">::*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">p</span><span class="p">;</span>
<span class="k">const</span> <span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">m</span><span class="p">};</span>

<span class="n">a</span><span class="p">.</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">A</span><span class="o">::*</span> <span class="k">const</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
<span class="n">a</span><span class="p">.</span><span class="o">*</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span>
</code></pre></figure>
<p>Pointer-to-member functions can be used as callbacks or function objects using <code>std::mem_fn</code> or <code>std::bind</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;ab&quot;</span><span class="p">,</span> <span class="s">&quot;abc&quot;</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">l</span><span class="p">),</span>
               <span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size</span><span class="p">));</span>
</code></pre></figure><h2 id="c-style-casts">
<span class="hash">#</span>
<a href="#c-style-casts" class="header-link">C-Style Casts</a>
</h2>
<p>C-Style casts are discouraged. C++-style explicit casts such as <code>static_cast</code> are preferred instead. A C-Style cast expression in C++ is interpreted as the first of the following which satisfy the requirements of the respective cast:</p>

<ol>
<li><code>const_cast</code></li>
<li><code>static_cast</code> with extensions, i.e. a pointer or reference to a derived class is allowed to be cast to a pointer or reference to the base class</li>
<li><code>static_cast</code> with extensions followed by <code>const_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li><code>reinterpret_cast</code> followed by <code>const_cast</code></li>
</ol>

<p>As is evident above, the exact behavior of a C-Style cast can vary widely, which is why it&#39;s preferred to use explicit C++ casts.</p>
<h2 id="functional-casts">
<span class="hash">#</span>
<a href="#functional-casts" class="header-link">Functional Casts</a>
</h2>
<p>A functional cast expression is a single-word type name followed by a single expression in parentheses. It&#39;s exactly equivalent to the corresponding C-style cast expression, i.e.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">int</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="mi">45</span>
</code></pre></figure><h2 id="static_cast">
<span class="hash">#</span>
<a href="#static_cast" class="header-link">static_cast</a>
</h2>
<p>The sequence that <code>static_cast</code> follows is:</p>

<ol>
<li>if <code>new_type</code> can be direct-initialized from the expression, then return a <code>new_type</code> temporary</li>
<li>if <code>new_type</code> is pointer or reference to <code>D</code> and expression is pointer or reference to its base <code>B</code>, then perform a unsafe downcast</li>
<li>if <code>new_type</code> is rvalue reference, then return an xvalue referring to expression</li>
<li>if <code>new_type</code> is <code>void</code>, then discard the value of the expression after evaluation</li>
<li>given the existence of a standard conversion sequence from <code>new_type</code> to expression type, it can perform the inverse of the conversion</li>
<li>it can perform explicit conversion of lvalue-to-rvalue, array-to-pointer, or function-to-pointer</li>
<li>a scoped enumeration can be converted to integer or floating-point</li>
<li>an integer, floating-point, or enumeration type can be converted to any enumeration. It is undefined behavior if the value is out of the range of target enumeration type</li>
<li>a pointer-to-member of class <code>D</code> can be unsafe upcast to pointer-to-member of base class <code>B</code>. Note that there is no check to ensure that the member actually exists in base class.</li>
<li>prvalue of type pointer to <code>void</code> can be converted to pointer to any type</li>
</ol>

<p><code>static_cast</code> can be used to disambiguate function overloads by performing a function-to-pointer conversion with a specific type:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// choose std::toupper(int)</span>
<span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">toupper</span><span class="p">);</span>
</code></pre></figure>
<p><code>static_cast</code> can be used to perform an unsafe downcast:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">D</span> <span class="n">d</span><span class="p">;</span>
<span class="n">B</span><span class="o">&amp;</span> <span class="n">b_ref</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

<span class="n">D</span><span class="o">&amp;</span> <span class="n">downcast</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">b_ref</span><span class="p">);</span>
</code></pre></figure><h2 id="const_cast">
<span class="hash">#</span>
<a href="#const_cast" class="header-link">const_cast</a>
</h2>
<p><code>const_cast</code> can be used to cast away <code>const</code>-ness or volatility (<code>volatile</code>). The sequence consists of:</p>

<ol>
<li>two possibly multi-level pointers to the <em>same type</em> may be converted between each other regardless of cv-qualifiers at each level</li>
<li>lvalue may be converted to lvalue reference or rvalue reference of the same type of any cv-qualification</li>
<li>rvalue may be converted to rvalue reference of the same type of any cv-qualification</li>
<li>null pointer value may be converted to null pointer value of <code>new_type</code></li>
</ol>

<p>It is undefined behavior to use <code>const_cast</code> to remove <code>const</code>-ness or volatility from a pointer or reference and using it to either write to an object declared <code>cosnt</code> or access an object declared <code>volatile</code>.</p>
<h2 id="dynamic_cast">
<span class="hash">#</span>
<a href="#dynamic_cast" class="header-link">dynamic_cast</a>
</h2>
<p>The behavior of <code>dynamic_cast</code> in the event of failure depends on whether <code>new_type</code> is a pointer type or a reference type. If it&#39;s a pointer type, <code>dynamic_cast</code> returns a <code>nullptr</code>. If it&#39;s a reference type, <code>dynamic_cast</code> throws an <code>std::bad_cast</code> exception.</p>

<p>The sequence of <code>dynamic_cast</code> consists of:</p>

<ol>
<li>can add <code>const</code>-ness</li>
<li><code>dynamic_cast&lt;T&gt;(nullptr)</code> → <code>nullptr</code> of <code>T</code></li>
<li><code>dynamic_cast&lt;Base*&gt;(Derived*)</code> → <code>Base*</code></li>
<li><code>dynamic_cast&lt;void*&gt;(Polymorphic*)</code> → <code>DynamicType*</code></li>
<li><code>dynamic_cast&lt;Derived*&gt;(Base*)</code> → <code>Derived*</code>, i.e. <em>downcast</em>, if the dynamic type of <code>Base</code> IS-A <code>Derived</code></li>
<li><code>dynamic_cast&lt;OtherBase*&gt;(Base*)</code> → <code>OtherBase*</code>, i.e. <em>sidecast</em>, if dynamic type of <code>Base</code> IS-A <code>OtherBase</code></li>
<li>if not 5 or 6:

<ol>
<li><code>dynamic_cast&lt;T*&gt;(expr)</code> → <code>nullptr</code></li>
<li><code>dynamic_cast&lt;T&amp;&gt;(expr)</code> → <code>throw std::bad_cast</code></li>
</ol></li>
<li>if within a constructor or destructor, and the expression refers to an object currently under construction or destruction, that object is the dynamic type. It is undefined behavior if <code>new_type</code> is not a pointer or reference to the constructor or destructor&#39;s own class or one of its bases</li>
</ol>

<p>The <em>static type</em> of an expression is the one that results from compile-time analysis, it doesn&#39;t change during run-time.</p>

<p>The <em>dynamic type</em> of an expression is the type of the most derived polymorphic object.</p>

<p>An incomplete type is one of:</p>

<ul>
<li><code>void</code></li>
<li>a class type that has been declared (e.g. forward declaration) but not defined</li>
<li>an array of unknown size</li>
<li>an array of elements of incomplete type</li>
<li>an enumeration type from point of declaration until the underlying type is determined</li>
</ul>
<h2 id="reinterpret_cast">
<span class="hash">#</span>
<a href="#reinterpret_cast" class="header-link">reinterpret_cast</a>
</h2>
<p>A <code>reinterpret_cast</code> is purely a compiler directive to treat a sequence of bits of the expression as if it had the type <code>new_type</code>.</p>

<p>Given the cast:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">AliasedType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">DynamicType</span><span class="p">)</span>
</code></pre></figure>
<p>The strict aliasing rule says that the cast always succeeds, but the resulting pointer can only be used if one of the following holds, otherwise it is undefined behavior:</p>

<ul>
<li><code>AliasedType</code> is the (possibly cv-qualified) <code>DynamicType</code></li>
<li><code>AliasedType</code> and <code>DynamicType</code> are both pointers to same type <code>T</code></li>
<li><code>AliasedType</code> is a base class of <code>DynamicType</code></li>
<li><code>AliasedType</code> is <code>char</code> or <code>unsigned char</code></li>
<li><code>AliasedType</code> is the signed or unsigned variant of <code>DynamicType</code></li>
<li><code>AliasedType</code> is an aggregate or <code>union</code> type which holds one of the types as element or member</li>
</ul>
<h2 id="signed-to-unsigned">
<span class="hash">#</span>
<a href="#signed-to-unsigned" class="header-link">Signed-to-Unsigned</a>
</h2>
<p>When a signed value is assigned to an unsigned variable, the underlying bit representation <strong>is not altered</strong>. Instead, the signed value is simply treated literally as if it were an unsigned value.</p>

<p>If the signed value is negative, then it is likely represented at the bit-level in <a href="http://en.wikipedia.org/wiki/Two%27s_complement">Two&#39;s Complement</a>. For example, given:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">uint8_t</span> <span class="n">var</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</code></pre></figure>
<p>The value <code>-1</code> is encoded by first representing it as a positive number:</p>

<p><script type="math/tex; mode=display"> 0000\ 0001 </script></p>

<p>The digits are then flipped, so that 1s become 0s and vice versa:</p>

<p><script type="math/tex; mode=display"> 1111\ 1110 </script></p>

<p>Finally, the value is incremented by 1 to arrive at the Two&#39;s Complement representation of <code>-1</code>:</p>

<p><script type="math/tex; mode=display"> 1111\ 1111 </script></p>

<p>When this value is assigned to an unsigned integer, the value is simply interpreted as if it were unsigned to begin with. Therefore, this value is interpreted as being <code>255</code>.</p>
<h2 id="integer-promotion">
<span class="hash">#</span>
<a href="#integer-promotion" class="header-link">Integer Promotion</a>
</h2>
<p>In general, operands are converted to the same type of the widest operand type in the expression. Loss of precision is avoided, so this also means that when integral and floating-point values are mixed, they&#39;re all converted to floating-point values.</p>

<p><strong>Integer promotion</strong> concerns converting small integral types to larger integral types.</p>

<p><code>bool</code>, <code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short</code>, <code>unsigned short</code> are promoted to <code>int</code> if all possible values fit within an <code>int</code>. Otherwise, they are promoted to <code>unsigned int</code>.</p>

<p>Larger types are promoted to the smallest type of <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long</code>, or <code>unsigned long long</code> which fits the value.</p>
<h2 id="mixing-unsigned-types">
<span class="hash">#</span>
<a href="#mixing-unsigned-types" class="header-link">Mixing Unsigned Types</a>
</h2>
<p>If the types still don&#39;t match but the signs match, then the type of the smaller value is promoted to the type of the larger value.</p>

<p>If the signs don&#39;t match and the type of the unsigned operand is the same as or larger than that of the signed operand, then the signed operand is converted to unsigned as described in <a href="#signed-to-unsigned">Signed-to-Unsigned</a>, which most likely yields unexpected behavior.</p>

<p>If the signs don&#39;t match and the type of the unsigned operand is smaller than that of the signed operand, the <strong>result is machine-dependent</strong>. If all values in the unsigned type fit in the larger signed type, it&#39;s converted to the larger signed type. Otherwise, the signed operand is converted to the unsigned type as described in <a href="#signed-to-unsigned">Signed-to-Unsigned</a>, which most likely yields unexpected behavior.</p>
<h2 id="negative-modulus">
<span class="hash">#</span>
<a href="#negative-modulus" class="header-link">Negative Modulus</a>
</h2>
<p>The modulus operation <code>%</code> simply calculates the remainder of the left expression divided by the right expression. There is confusion when it comes to modulus operations with negative operands, which as far as I know isn&#39;t clearly defined mathematically. For example, the operation <code>-1 % 256</code>.</p>

<p>The equation generally used to calculate the modulus is:</p>

<p><script type="math/tex; mode=display"> \text{mod}(a, n) = a - \lfloor a / n \rfloor * n </script></p>

<p>The operation <code>-1 % 256</code> yields the result <code>255</code> with this implementation. This is the result yielded in languages such as Python and Ruby.</p>

<p>C and C++ uses the same equation as the above, <strong>but</strong> the division operation has an additional restriction when used with negative operands:</p>

<p><script type="math/tex; mode=display"> \text{div}(-a, n) = \text{div}(a, -n) = -(a/n) </script></p>

<p>With these definitions, the division of <code>-1 / 256</code> in the above equation becomes <code>-(1 / 256)</code>. The result of <code>1 / 256</code> is zero due to truncation. The negation of this result is still zero, so the result of the modulus operation is simply <code>-1</code>, which is <strong>very different</strong> from the result of <code>256</code> yielded above without these restrictions.</p>

<p>Given the above restriction on the division operation with negative operands, the definition of the modulus operation with negative operands can be simplified to:</p>

<p><script type="math/tex; mode=display">
\begin{align}
  \text{mod}(\phantom {-} a, -n) &= \phantom {-} \text{mod}(a, n) \\
  \text{mod}(-a, \phantom {-} n) &= -\text{mod}(a, n)
\end{align}
</script></p>
<h1 id="exceptions">
<span class="hash">#</span>
<a href="#exceptions" class="header-link">Exceptions</a>
</h1>
<p>A <em>function-try-block</em> is a way of wrapping an exception handler around a function body.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">try</span> <span class="p">{</span>
  <span class="o">++</span><span class="n">n</span><span class="p">;</span>
  <span class="k">throw</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">4</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>A catch-all handler can be specified with three dots <code>...</code> as the catch parameter.</p>

<p>If a catch handler doesn&#39;t match the exception thrown in the corresponding try-block, then the exception is rethrown to the containing try-block, or <code>std::terminate</code> is called if there is none.</p>

<p>A catch handler can rethrow the caught exception explicitly to propagate it up the call stack by using the empty <code>throw;</code> statement.</p>

<p>A <code>noexcept</code> specification specifies that a function throws exceptions if the expression argument evaluates to <code>true</code>. If missing, it is assumed to be <code>noexcept(false)</code>, meaning that the function <em>may</em> throw exceptions, whereas <code>noexcept</code> on its own is equivalent to <code>noexcept(true)</code>.</p>

<p>A <code>noexcept</code> specification is part of the function type, so it can be used for function parameters that are function pointers to function that don&#39;t throw, or to create type aliases for pointers to functions that don&#39;t throw.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>

<span class="c1">// func is noexcept is T()</span>
<span class="c1">// constructor is also noexcept</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">T</span><span class="p">()))</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></figure>
<p>If a function declaration is given a <code>noexcept</code> specification, <em>all</em> other overloads must have the <em>same</em> <code>noexcept</code> specification.</p>

<p>The <code>noexcept</code> operator performs a compile-time check and returns <code>true</code> if the expression argument is declared to not throw exceptions. It is usually used in a <code>noexcept</code> specifier to encode the possibility for example that a function may throw if a function it uses may throw for a given parameter.</p>

<p>Destructors are implicitly <code>noexcept</code> unless the class contains a member whose destructor is explicitly <code>noexcept(false)</code>.</p>

<p>A function-try-block can also be used around a constructor as a way to catch exceptions during initialization within a member initializer list. It begins before the function body and includes the member initializer list. Every catch must terminate by throwing an exception, otherwise an implicit rethrow occurs at the end of a catch clause scope.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">()</span> <span class="k">try</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// succeeded</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// failed</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></figure>
<p>A function-try-block can also be used around a destructor. The catch clauses may perform explicit <code>return</code>s, otherwise an implicit rethrow is occurs at the end of a catch clause scope.</p>

<p>Some classes make guarantees about what occurs in the event that exceptions are thrown. For example, <code>std::vector</code> guarantees that if an exception occurs during <code>push_back</code>, the original <code>vector</code> would be left unchanged. In the event that the <code>push_back</code> would have had to reallocate space, if the <code>vector</code> decided to use the move constructor to move the objects to the new space and an exception were thrown at some point, the original <code>vector</code> would be left in an inconsistent state, with some of its elements having been moved to the new allocation of memory.</p>

<p>For this reason, such classes use copy constructors unless they are guaranteed that a type&#39;s move constructor doesn&#39;t throw exceptions. This guarantee is specified using the <code>noexcept</code> declaration on a function definition as shown above.</p>
<h1 id="lambdas">
<span class="hash">#</span>
<a href="#lambdas" class="header-link">Lambdas</a>
</h1>
<p>A lambda expression is conceptually transformed into an unnamed prvalue temporary object of a unique, unnamed, non-union, non-aggregate type that overloads its function-call operator, with one data member for each captured variable.</p>

<p>Lambda captures by copy can&#39;t be modified if the <code>mutable</code> keyword is missing after the parameter list. The <code>mutable</code> keyword allows the lambda body to modify the parameters captured by the copy. Conversely, a lambda <em>with</em> the <code>mutable</code> keyword essentially removes the <code>const</code>-qualifier for the converse effect.</p>

<p>Conceptually, a lambda without a <code>mutable</code> keyword has the effect of adding a <code>const</code>-qualifier to the function-call operator&#39;s declaration, thereby preventing the lambda body from mutating the captured variables.</p>

<p>If the lambda&#39;s return type is omitted, it is assumed to be <code>auto</code>.</p>

<p>Conceptually, a lambda with a parameter type of <code>auto</code> has the effect of making the function-call operator a template function with the corresponding parameter as a template parameter.</p>

<p>If the lambda&#39;s parameter list is omitted, it is assumed to be empty:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="p">[</span><span class="n">capture</span> <span class="n">list</span><span class="p">]</span> <span class="p">{</span> <span class="n">body</span> <span class="p">}</span>
</code></pre></figure>
<table>
<thead>
<tr>
<th style="text-align: left">Captures</th>
<th style="text-align: left">Effect</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>[a, &amp;b]</code></td>
<td style="text-align: left"><code>a</code> by-value, <code>b</code> by-referece</td>
</tr>
<tr>
<td style="text-align: left"><code>[this]</code></td>
<td style="text-align: left"><code>this</code> by-value</td>
</tr>
<tr>
<td style="text-align: left"><code>[&amp;]</code></td>
<td style="text-align: left">default all by-reference</td>
</tr>
<tr>
<td style="text-align: left"><code>[=]</code></td>
<td style="text-align: left">default all by-value</td>
</tr>
<tr>
<td style="text-align: left"><code>[]</code></td>
<td style="text-align: left">capture nothing</td>
</tr>
</tbody>
</table>

<p>If a lambda capture list contains a capture-default specifier, other captures can&#39;t use the same capture type. That is, if by-value is specified as the capture default, any other listed captures must be by-reference.</p>

<p>Default capture specifiers are discouraged because they can lead to implicit and unexpected captures, which can lead to dangling references.</p>

<p>Note that by-value captures in lambdas can still cause dangling references if pointers are captured. Likewise, by-value default captures can implicitly capture the <code>this</code> pointer when a data member of method is accessed within the lambda. That can be avoided by using a generalized capture to create a local copy.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="p">[</span><span class="n">age</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">](</span><span class="kt">int</span> <span class="n">years</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">age</span> <span class="o">+</span> <span class="n">years</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></figure>
<p><code>static</code> variables are essentially captured by-reference, even given a by-value default capture mode. Use a generalized capture initializer to explicitly perform a copy.</p>

<p>A lambda capture with an initializer has the effect of declaring and explicitly capturing a variable with type <code>auto</code>. This is useful for capturing move-only types:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="p">[</span><span class="n">move_only_obj</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">move_only_obj</span><span class="p">)](</span><span class="k">const</span> <span class="kt">int</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span>
  <span class="err">…</span>
<span class="p">}</span>
</code></pre></figure>
<p>It&#39;s also possible to capture by reference:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="p">[</span><span class="o">&amp;</span><span class="n">my_ref</span> <span class="o">=</span> <span class="n">some_lvalue</span><span class="p">]()</span> <span class="p">{</span>
  <span class="err">…</span>
<span class="p">}</span>
</code></pre></figure>
<p>A lambda capture initializer can also be used to inject values into the lambda:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="p">[</span><span class="n">pw</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">)]()</span> <span class="p">{</span>
  <span class="c1">// use pw</span>
<span class="p">};</span>
</code></pre></figure><h1 id="enumerations">
<span class="hash">#</span>
<a href="#enumerations" class="header-link">Enumerations</a>
</h1>
<p><em>Scoped enumerations</em> can be created to avoid symbol clashing and enumerations&#39; underlying type can be specified explicitly:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">enum</span> <span class="k">class</span> <span class="nc">EventType</span> <span class="o">:</span> <span class="kt">uint8_t</span> <span class="p">{</span> <span class="n">STATUS</span><span class="p">,</span> <span class="n">LOG</span><span class="p">,</span> <span class="n">ERROR</span> <span class="p">};</span>

<span class="n">EventType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">EventType</span><span class="o">::</span><span class="n">STATUS</span><span class="p">;</span>
</code></pre></figure>
<p>Scoped enumerations can be forward-declared because the underlying type is <em>always</em> known because it is either explicitly specified or the default is <code>int</code>. Unscoped enumerations can only be forward-declared if the underlying type is explicitly specified in the forward-declaration.</p>

<p>Unscoped enumerations introduce their enumerators into the enclosing scope. If an unscoped enumeration is defined in a class, the enumerators are accessible with the member access operators.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">X</span> <span class="p">{</span>
  <span class="k">enum</span> <span class="n">Direction</span> <span class="p">{</span> <span class="n">Left</span><span class="p">,</span> <span class="n">Right</span> <span class="p">};</span>
<span class="p">};</span>

<span class="n">X</span> <span class="n">x</span><span class="p">;</span>
<span class="n">X</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>

<span class="c1">// enumerator `Left` is accessible via</span>
<span class="n">X</span><span class="o">::</span><span class="n">Direction</span><span class="o">::</span><span class="n">Left</span>
<span class="n">X</span><span class="o">::</span><span class="n">Left</span>
<span class="n">x</span><span class="p">.</span><span class="n">Left</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">Left</span>
</code></pre></figure>
<p>If the underlying type is not explicitly specified, then the type will either be <code>int</code> or the largest integral type that can represent all values.</p>

<p>Enumerators of unscoped enumerations are implicitly convertible to integral types, while those of scoped enumerations must perform an explicit <code>static_cast</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// unscoped enumeration, implicit conversion</span>
<span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">RED</span><span class="p">,</span> <span class="n">GREEN</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">BLUE</span> <span class="p">};</span>

<span class="n">Color</span> <span class="n">r</span> <span class="o">=</span> <span class="n">BLUE</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>  <span class="c1">// n == 21</span>

<span class="c1">// scoped enumeration, explicit conversion</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">RED</span><span class="p">,</span> <span class="n">GREEN</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">BLUE</span> <span class="p">};</span>

<span class="n">Color</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">BLUE</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>  <span class="c1">// n = 21</span>
</code></pre></figure>
<p>Each <em>enumerator</em>, i.e. a possible enumeration value, can be associated with a value of a <code>constexpr</code>. If an enumerator doesn&#39;t have an initializer, it takes on the value of the previous enumerator plus 1, or zero if it&#39;s the first.</p>

<p>Initializers can refer to previous enumerators.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">enum</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">,</span>
  <span class="n">B</span><span class="p">,</span>
  <span class="n">C</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
  <span class="n">D</span><span class="p">,</span>
  <span class="n">E</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">F</span><span class="p">,</span>
  <span class="n">G</span> <span class="o">=</span> <span class="n">F</span> <span class="o">+</span> <span class="n">C</span>
<span class="p">};</span>

<span class="c1">// A = 0</span>
<span class="c1">// B = 1</span>
<span class="c1">// C = 10</span>
<span class="c1">// D = 11</span>
<span class="c1">// E = 1</span>
<span class="c1">// F = 2</span>
<span class="c1">// G = 12</span>
</code></pre></figure><h1 id="temporaries">
<span class="hash">#</span>
<a href="#temporaries" class="header-link">Temporaries</a>
</h1>
<p>The lifetime of a temporary is extended to match the lifetime of a reference bound to it, except when:</p>

<ul>
<li><p>A temporary is bound to a return value of a function. In this case, the temporary is destroyed immediately at the end of the <code>return</code> expression, yielding a dangling reference.</p></li>
<li><p>A temporary is bound to a reference parameter in a function call. In this case, the temporary exists until the end of the full expression containing the function call. If the function returns a reference to the temporary, it becomes a dangling reference.</p></li>
<li><p>A temporary is bound to a reference in a <code>new</code>-expression initializer. In this case, the temporary exists until the end of the full expression containing the <code>new</code>-expression. If the initialized object outlives the full expression, its reference member becomes a dangling reference.</p></li>
</ul>
<h1 id="value-categories">
<span class="hash">#</span>
<a href="#value-categories" class="header-link">Value Categories</a>
</h1>
<p>An lvalue (&quot;left value&quot;) expression is one that has identity and cannot be moved from. It designates a function or object. Note that the <em>name</em> of a variable or function in scope, even if the variable type is rvalue reference, is itself an lvalue.</p>

<p>An xvalue (&quot;expiring value&quot;) expression is one that has identity and can be moved from, i.e. it&#39;s &quot;expiring&quot;. It&#39;s usually near the end of its lifetime, e.g. a function-returned rvalue reference.</p>

<p>A glvalue (&quot;generalized lvalue&quot;) expression is one that has identity but may or may not be moved from, i.e. it&#39;s <em>either</em> an lvalue <em>or</em> an xvalue.</p>

<p>A prvalue (&quot;pure rvalue&quot;) expression is one that has no identity and cannot be moved from, i.e. it&#39;s an rvalue and is not an xvalue, e.g. a function-returned value that is not a reference.</p>

<p>An rvalue (&quot;right value&quot;) expression is one that can be moved from, but may or may not have identity, i.e. it&#39;s <em>either</em> a prvalue <em>or</em> an xvalue.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Category</th>
<th style="text-align: center">Has Identity</th>
<th style="text-align: center">Can Move From</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">lvalue</td>
<td style="text-align: center">✓</td>
<td style="text-align: center">❌</td>
</tr>
<tr>
<td style="text-align: left">xvalue</td>
<td style="text-align: center">✓</td>
<td style="text-align: center">✓</td>
</tr>
<tr>
<td style="text-align: left">glvalue</td>
<td style="text-align: center">✓</td>
<td style="text-align: center">?</td>
</tr>
<tr>
<td style="text-align: left">prvalue</td>
<td style="text-align: center">❌</td>
<td style="text-align: center">❌</td>
</tr>
<tr>
<td style="text-align: left">rvalue</td>
<td style="text-align: center">?</td>
<td style="text-align: center">✓</td>
</tr>
</tbody>
</table>

<p>When a glvalue appears where a prvalue is expected, the glvalue is converted to a prvalue.</p>

<p>An lvalue transformation is one of:</p>

<ul>
<li>lvalue-to-rvalue conversion</li>
<li>array-to-pointer conversion</li>
<li>function-to-pointer conversion</li>
</ul>

<p>An lvalue-to-rvalue conversion is one in which a prvalue temporary object is copy-constructed from a glvalue.</p>
<h1 id="static-variables">
<span class="hash">#</span>
<a href="#static-variables" class="header-link">Static Variables</a>
</h1>
<p>Local <code>static</code> variables are initialized the first time control passes through their declaration. Subsequent passes skip the declaration.</p>

<p>If the initialization of local static variable throws an exception, the variable isn&#39;t considered to be initialized, and so initialization is attempted again on the next pass.</p>

<p>Static local variable destructors run at program exit as long as they were ever successfully initialized.</p>

<p>Static members can be declared in the class definition and defined outside of it.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>  <span class="c1">// declaration</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">S</span><span class="o">::</span><span class="n">X</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// definition</span>
</code></pre></figure><h1 id="templates">
<span class="hash">#</span>
<a href="#templates" class="header-link">Templates</a>
</h1>
<p>All special member functions can be templates except for copy-constructors and destructors.</p>
<h2 id="parameter-packs">
<span class="hash">#</span>
<a href="#parameter-packs" class="header-link">Parameter Packs</a>
</h2>
<p>Parameter packs can be used to allow a function to accept an arbitrary number of parameters with potentially differing types.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="err">...</span><span class="nc">Us</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">Us</span><span class="p">...</span> <span class="n">pargs</span><span class="p">)</span> <span class="p">{</span>
  <span class="err">…</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="err">...</span><span class="nc">Ts</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">Ts</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">...);</span> <span class="c1">// into &amp;a1, &amp;a2, etc</span>
<span class="p">}</span>
</code></pre></figure>
<p>In order to process each parameter, possibly a different way based on its type, the recursive variadic template function pattern may be used. For example, in the following code, the second function is called as long as there is more than one remaining parameter. As soon as there is only one remaining parameter, the first function is called which only prints that parameter, terminating the recursion.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">Targs</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">Targs</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span>
 <span class="n">print</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
<span class="p">}</span>
</code></pre></figure>
<p>It&#39;s similar to the following contrived Haskell code:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-haskell"><span class="nf">print</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="n">x</span>

<span class="nf">print</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="n">x</span>
                  <span class="n">print</span> <span class="n">xs</span>
</code></pre></figure>
<p>The size of a parameter pack can be obtained with the <code>sizeof...</code> operator.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">make_array</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">ts</span><span class="p">)</span>
 <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">ts</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">)...</span> <span class="p">};</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">make_array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></figure><h2 id="template-specialization">
<span class="hash">#</span>
<a href="#template-specialization" class="header-link">Template Specialization</a>
</h2>
<p>A partial template specialization is one where some but not all of the template parameters are specialized in a template specialization.</p>

<p>Members of partial specializations aren&#39;t related to members of the primary template.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">I</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">A</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">a0</span><span class="p">;</span>
<span class="n">a0</span><span class="p">.</span><span class="n">f</span><span class="p">();</span>  <span class="c1">// ok: f() definition in primary template A&lt;T, I&gt;</span>

<span class="n">A</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">;</span>
<span class="n">a2</span><span class="p">.</span><span class="n">f</span><span class="p">();</span>  <span class="c1">// error: no f() definition in partial spec A&lt;T, 2&gt;</span>
</code></pre></figure>
<p>When an enclosing class template is fully specialized, all of the partial specializations of member templates are ignored for the given specialization of the enclosing class.</p>

<p>A full class template specialization can change the base class.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">is_void</span> <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="p">{};</span>

<span class="c1">// full specialization for T = void</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">is_void</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{};</span>
</code></pre></figure>
<p>A member of a class template specialization doesn&#39;t require an explicit template argument list.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">C</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// no template &lt;&gt;</span>
<span class="kt">void</span> <span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></figure>
<p>A member or member template of a class template can be explicitly specialized even if it is defined in the class template definition.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">h</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kt">void</span> <span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">h</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></figure>
<p>A nested class member template cannot be specialized if its enclosing class is not specialized.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T2</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T3</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">mf1</span><span class="p">(</span><span class="n">T3</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">mf2</span><span class="p">();</span> <span class="c1">// non-template member</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="c1">// error:</span>
<span class="c1">//   member template B&lt;double&gt; is specialized</span>
<span class="c1">//   so its enclosing class A must be specialized</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Y</span><span class="o">&gt;</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kt">void</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;::</span><span class="n">B</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">mf2</span><span class="p">()</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></figure><h2 id="variable-templates">
<span class="hash">#</span>
<a href="#variable-templates" class="header-link">Variable Templates</a>
</h2>
<p>A variable template can be used to define a variable with different values based on the type.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="n">T</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mf">3.1415926535897932385</span><span class="p">);</span>

<span class="c1">// specialization</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">pi</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">circular_area</span><span class="p">(</span><span class="n">T</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">pi</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>When used in a class scope, variable templates declare a static data member template.</p>
<h2 id="function-templates">
<span class="hash">#</span>
<a href="#function-templates" class="header-link">Function Templates</a>
</h2>
<p>When the template argument list (even if empty) is omitted, overload resolution examines both template and non-template overloads.</p>
<h2 id="template-template-parameters">
<span class="hash">#</span>
<a href="#template-template-parameters" class="header-link">Template Template Parameters</a>
</h2>
<p>Template template parameters make it possible to accept a template as a template argument <sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>. It can be read as &quot;template parameter that itself is a template.&quot;</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span>
          <span class="k">class</span> <span class="nc">Container</span><span class="p">,</span>
          <span class="k">typename</span> <span class="n">Element</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Thing</span> <span class="p">{</span>
  <span class="n">Container</span><span class="o">&lt;</span><span class="n">Element</span><span class="o">&gt;</span> <span class="n">things</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Thing</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">thing</span><span class="p">;</span>
</code></pre></figure><h2 id="integral-template-parameters">
<span class="hash">#</span>
<a href="#integral-template-parameters" class="header-link">Integral Template Parameters</a>
</h2>
<p>These are used for example with <code>std::array</code> to specify the dimension.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></figure><h2 id="explicit-template-instantiation">
<span class="hash">#</span>
<a href="#explicit-template-instantiation" class="header-link">Explicit Template Instantiation</a>
</h2>
<p>It&#39;s possible to explicitly instantiate a class and all of its members for the provided template arguments.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// instantiated Vector&lt;int&gt; definition</span>
<span class="k">template</span> <span class="k">class</span> <span class="nc">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="kt">void</span> <span class="n">f</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="k">template</span> <span class="kt">void</span> <span class="n">f</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span>
<span class="k">template</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</code></pre></figure>
<p>It&#39;s possible to signal that a given template instantiation is explicitly instantiated in another compilation unit, so that the current one should not instantiate it either implicitly or explicitly.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">extern</span> <span class="k">template</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">template</span> <span class="kt">void</span> <span class="n">f</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</code></pre></figure>
<p>An explicit template specialization must be declared in the same namespace as the primary template, after its definition, before the first use that would cause an implicit instantiaton.</p>

<p>An explicit template specialization of a function template is <code>inline</code> only if it&#39;s declared with the <code>inline</code> specifier, regardless of whether the primary template is <code>inline</code> or not.</p>

<p>An explicit template specialization of a function template cannot be a friend declaration.</p>

<p>An explicit template specialization of a function template cannot contain default function arguments.</p>
<h2 id="implicit-template-instantiation">
<span class="hash">#</span>
<a href="#implicit-template-instantiation" class="header-link">Implicit Template Instantiation</a>
</h2>
<p>Implicit class template instantiation occurs when a completely defined type of a class template is needed. For example, when an object of that type is instantiated, but not when a pointer to that type is constructed. The same applies to members of class type, i.e. they&#39;re only instantiated if they&#39;re used.</p>

<p>Implicit function template instantiation occurs when code requires the function definition to exist and it hasn&#39;t been explicitly instantiated.</p>
<h2 id="member-templates">
<span class="hash">#</span>
<a href="#member-templates" class="header-link">Member Templates</a>
</h2>
<p>A member function template cannot be virtual.</p>

<p>A member function template in a derived class cannot override a virtual member function from the base class, i.e. it may exist alongside one that does override.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">Derived</span> <span class="p">:</span> <span class="n">Base</span> <span class="p">{</span>
  <span class="c1">// does not override B::f</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

  <span class="c1">// override can call the template</span>
  <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">f</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></figure>
<p>A member function template of special member function <em>does not</em> prevent implicit generation of the corresponding member function.</p>

<p>Given a conflict between a template member function and a non-template member function, the non-template member function is chosen unless an explicit template argument list is supplied.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T2</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">A</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">ac</span><span class="p">;</span>
<span class="n">ac</span><span class="p">.</span><span class="n">f</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">);</span> <span class="c1">// template function f&lt;char&gt;(int)</span>
<span class="n">ac</span><span class="p">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">// non-template function f(int)</span>
<span class="n">ac</span><span class="p">.</span><span class="n">f</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// template function f&lt;int&gt;(int)</span>
</code></pre></figure>
<p>A user-defined conversion function can be a template:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">operator</span> <span class="n">T</span><span class="o">*</span><span class="p">();</span> <span class="c1">// conversion to pointer to any type</span>
<span class="p">};</span>

<span class="c1">// out-of-class definition</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">A</span><span class="o">::</span><span class="k">operator</span> <span class="n">T</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// explicit specialization for char*</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="n">A</span><span class="o">::</span><span class="k">operator</span> <span class="kt">char</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>Nested templates, such as a function template inside of a class template, all need to be specified in the same order when defining a function that depends on multiple types.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">String</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">S</span><span class="o">&gt;</span>
  <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">S</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">String</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="err">…</span>
<span class="p">}</span>
</code></pre></figure><h2 id="template-argument-deduction">
<span class="hash">#</span>
<a href="#template-argument-deduction" class="header-link">Template Argument Deduction</a>
</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Parameter</th>
<th style="text-align: left">Argument</th>
<th style="text-align: left">Deduction</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>T&amp;&amp;</code></td>
<td style="text-align: left"><code>A&amp;</code></td>
<td style="text-align: left"><code>A&amp;</code></td>
</tr>
<tr>
<td style="text-align: left"><code>T&amp;&amp;</code></td>
<td style="text-align: left"><code>A&amp;&amp;</code></td>
<td style="text-align: left"><code>A&amp;&amp;</code></td>
</tr>
</tbody>
</table>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// T = int&amp;, param = int&amp;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>
<span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// T = int, param = int&amp;&amp;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// T = const int&amp;, param = const int&amp;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// T = int, param = int</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// T = int, param = int</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// T = int, param = int</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// T = int, param = int&amp;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// T = const int, const int&amp;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// T = const int, const int&amp;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">array</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">array</span><span class="p">);</span> <span class="c1">// array-to-pointer decay</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">array</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">array</span><span class="p">);</span> <span class="c1">// reference to array</span>
</code></pre></figure>
<p>TAD for forwarding references follow normal TAD rules unless the argument is an lvalue, in which case the deduced type parameter and the parameter type are both lvalue references to the same type. A pointer-to-<code>const</code> remains pointer-to-<code>const</code> because the <code>const</code>-ness that would be ignored is that of the pointer, not what the pointer points to.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;test&quot;</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">// T = const char *, param = cost char *</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="c1">// T = const char *, param = const char *</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span> <span class="c1">// T = const char[4], param = const char (&amp;)[4]</span>
</code></pre></figure>
<p>For non-pointer, non-reference template parameters, TAD ignores the reference, <code>const</code>, or <code>volatile</code> components. The reason that TAD ignores the <code>const</code>-qualifier of a by-value template parameter is that, just because the argument can&#39;t be modified doesn&#39;t mean that a copy of the same type can&#39;t be.</p>

<p>TAD can be used to determine the size of an array.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">N</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">array_size</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">N</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>TAD for no-forwarding reference parameters treat lvalue refereces as non-references, that is, given <code>int&amp;</code>, it deduces <code>int</code>.</p>
<h1 id="move-semantics">
<span class="hash">#</span>
<a href="#move-semantics" class="header-link">Move Semantics</a>
</h1>
<p>C++11 introduced <em>move semantics</em> which simply refers to recognizing the notion of moving objects instead of only being able to copy them. With this introduction came <em>rvalue-references</em> which designate an object as being &quot;moveable,&quot; usually because it&#39;s about to be destroyed anyways.</p>

<p>A simple explanation for the act of &quot;moving&quot; is that of a string class with an underlying <code>char</code> array. If there is an instance <strong>A</strong> that needs to be replicated into instance <strong>B</strong>, it can be done by copying <strong>A</strong> into <strong>B</strong> using a copy constructor which would make a copy of the underlying array. However, if <strong>A</strong> was going to be destroyed shortly after, then the copy would have been unnecessary. Instead of copying the array from <strong>A</strong>, it could simply <em>steal</em> its pointer.</p>
<h2 id="rvalue-references">
<span class="hash">#</span>
<a href="#rvalue-references" class="header-link">rvalue-references</a>
</h2>
<p><em>rvalue-references</em> are simply references that can <em>only</em> be bound to rvalues. rvalues are either temporary objects or literals, both of which are ephemeral over the course of evaluating an expression. It then follows naturally that an object bound to an rvalue-reference has no &quot;owner&quot;, and more importantly that the object is <em>about to be destroyed</em>, <strong>so code is free to steal its contents</strong>. rvalue-references are simply a way of &quot;tagging&quot; such objects, to be able to write functions that apply specifically to objects that are about to be destroyed, i.e. a move constructor.</p>

<p>Aside from binding rvalue-references to rvalues, it is possible to derive an rvalue-reference from an lvalue through the use of <code>static_cast</code>. Such a cast has been implemented as the function <code>std::move</code> in order to be more semantic:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">Object</span> <span class="o">&amp;&amp;</span><span class="n">ref</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
</code></pre></figure>
<p>However, deriving an rvalue-reference from an lvalue is seen as a promise that the lvalue will no longer be used other than to assign or destroy it, as the actual value of the lvalue is not well defined or guaranteed.</p>

<p>Forwarding references can be used to forward parameters exactly the same way they were passed.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span><span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="n">Object</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Object</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></figure>
<p>This can also be done with lambdas by using <code>decltype</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Object</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...);</span>
<span class="p">};</span>
</code></pre></figure><h3 id="reference-collapsing">
<span class="hash">#</span>
<a href="#reference-collapsing" class="header-link">Reference Collapsing</a>
</h3>
<p>rvalue-references to template parameters have special rules. For example, given the definition:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>
</code></pre></figure>
<p>If an lvalue <code>int</code> is passed to the function, a language rule states that the template parameter <code>T</code> will be deduced as being an lvalue-refernece, <code>int&amp;</code>. This poses a problem, since the function parameter&#39;s type ends up being an lvalue-reference to an rvalue-reference, <code>int&amp; &amp;&amp;</code>. A reference to a reference, of any type, can&#39;t usually be created but an <strong>exception</strong> is made for template parameters.</p>

<p>Template parameters that are deduced as being references to references undergo a process that is referred to as <em>reference collapsing</em>, the rules of which are as follows:</p>

<table>
<thead>
<tr>
<th style="text-align: left">Input</th>
<th style="text-align: left">Output</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>X&amp; &amp;</code></td>
<td style="text-align: left"><code>X&amp;</code></td>
</tr>
<tr>
<td style="text-align: left"><code>X&amp; &amp;&amp;</code></td>
<td style="text-align: left"><code>X&amp;</code></td>
</tr>
<tr>
<td style="text-align: left"><code>X&amp;&amp; &amp;</code></td>
<td style="text-align: left"><code>X&amp;</code></td>
</tr>
<tr>
<td style="text-align: left"><code>X&amp;&amp; &amp;&amp;</code></td>
<td style="text-align: left"><code>X&amp;&amp;</code></td>
</tr>
</tbody>
</table>

<p>Basically, if both references (the template parameter and the deduced type) are rvalue references, collapse to an rvalue reference. Otherwise, collapse to an lvalue reference.</p>

<p>Reference collapsing occurs in the following contexts:</p>

<ol>
<li>template instantiation</li>
<li>auto variables</li>
<li>typedefs, using aliases</li>
<li>decltype</li>
</ol>

<p>The consequence of this is that function parameters that are an rvalue-reference to a template parameter type can match <em>any</em> type.</p>

<p>This is the mechanism behind the <code>std::move</code> function, which is defined by the standard as:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p>This has the effect that rvalues are passed through as-is. Instead, when an lvalue is passed to <code>std::move</code>, the templated function is instantiated as follows:</p>

<ol>
<li><code>T</code> type deduces to <code>string&amp;</code></li>
<li><code>remove_reference</code> is instantiated with <code>string&amp;</code></li>
<li><code>remove_reference&lt;string&amp;&gt;::type</code> is <code>string</code></li>
<li>return type of <code>move</code> is therefore <code>string&amp;&amp;</code></li>
<li>function parameter instantiates as <code>string&amp; &amp;&amp;</code> which collapses to <code>string&amp;</code></li>
</ol>

<p>The above instantiation procedure yields the following function signature:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">move</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>
</code></pre></figure>
<p>The actual <code>static_cast</code> is what yields and returns an rvalue-reference.</p>

<p>Perfect forwarding can fail with arguments that are:</p>

<ul>
<li>braced-init-lists</li>
<li>null pointers 0 and NULL</li>
<li>declaration-only integral <code>const</code> <code>static</code> data members</li>
<li>template and overloaded function names</li>
<li>bitfields</li>
</ul>
<h3 id="type-matching">
<span class="hash">#</span>
<a href="#type-matching" class="header-link">Type-Matching</a>
</h3>
<p>An rvalue-reference can be converted to a <code>const</code> reference. This means that if a class defines copy constructor but not a move constructor and as a result the compiler <a href="#move-operation-synthesis">defines the move constructor as deleted</a>, rvalue-references will type match with <code>const</code> references and as a result, rvalue-reference arguments will use the copy constructor seamlessly.</p>

<p>If an rvalue reference is bound to a temporary, it has the effect of extending the lifetime of the temporary while remaining modifiable, unlike <code>const</code>-lvalue references to temporaries.</p>
<h3 id="reference-qualifiers">
<span class="hash">#</span>
<a href="#reference-qualifiers" class="header-link">Reference Qualifiers</a>
</h3>
<p>It&#39;s usually the case that member functions can be called on objects regardless of whether they&#39;re lvalues or rvalues. However, this can lead to unexpected usage of objects such as the following:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&quot;wow!&quot;</span><span class="p">;</span>
</code></pre></figure>
<p>C++11 allows for the explicit restriction on the usage of a member function based on the lvalue/rvalue property of the calling object using a <em>reference qualifier</em>, which is similar to a <code>const</code> qualifier in that it appears at the end of the parameter list but <em><em>after</em></em> the <code>const</code> qualifier, and must appear in both the declaration and definition of the function.</p>

<p>Two possible reference qualifiers exist:</p>

<ol>
<li><code>&amp;</code> can only be called from an lvalue</li>
<li><code>&amp;&amp;</code> can only be called from an rvalue</li>
</ol>

<p><strong>Note</strong>: If a function has a reference qualifier, than <em>all</em> of the same functions require a reference qualifier.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">A</span><span class="o">&amp;</span> <span class="n">A</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure><h1 id="classes">
<span class="hash">#</span>
<a href="#classes" class="header-link">Classes</a>
</h1>
<p>It&#39;s a good thing to remember that the <em>only</em> distinction between a <code>class</code> type and a <code>struct</code> type is that <code>struct</code> has by default public visibility and <code>class</code> has default private visibility. That&#39;s all!</p>

<p>Members can be defined <code>mutable</code> so that they can be modified even in a <code>const</code> class or <code>const</code> member function. This should usually only be done when the member doesn&#39;t affect the externally-visible state of the class.</p>

<p><code>const</code> member functions should be thread safe because they convey the idea of reading, not writing, so <code>const</code> member functions that perform mutations (e.g. to mutable members) should employ some means of synchronization.</p>

<p>Functions defined entirely within a class, struct, or union, are implicitly inline.</p>
<h2 id="rule-of-five">
<span class="hash">#</span>
<a href="#rule-of-five" class="header-link">Rule of Five</a>
</h2>
<p>The copy constructor, move constructor, copy-assignment operator, move-assignment operator, and destructor should be thought of as a unit: if one needs to be defined, then the rest should be defined as well.</p>

<ul>
<li>if a class needs a destructor, it likely also needs a copy-assignment operator and copy constructor</li>
<li>if a class needs a copy constructor, it likely so needs a copy-assignment operator, <strong>and vice versa</strong></li>
</ul>
<h2 id="rule-of-zero">
<span class="hash">#</span>
<a href="#rule-of-zero" class="header-link">Rule of Zero</a>
</h2>
<p>This <a href="http://flamingdangerzone.com/cxx11/2012/08/15/rule-of-zero.html">recent rule</a> is unlike the <a href="http://en.cppreference.com/w/cpp/language/rule_of_three">other two</a> in that it instead says that classes that contain custom destructors, copy/move constructors, or copy/move assignment operators should deal <em>exclusively</em> with ownership, i.e. encapsulating a so called <em>ownership policy</em> which handles the allocation and deallocation of a particular resource (via RAII). All other classes should <strong>not have</strong> custom destructors, copy/move constructors, or copy/move assignment operators.</p>

<p>This rule is enforceable out-of-the-box in C++11 through the use of smart pointers such as <code>shared_ptr</code> and <code>unique_ptr</code> along with custom deleters when necessary.</p>
<h2 id="class-initialization">
<span class="hash">#</span>
<a href="#class-initialization" class="header-link">Class Initialization</a>
</h2>
<p>Classes are initialized as follows:</p>

<ol>
<li>virtual base classes in depth-first, left-to-right order</li>
<li>direct base classes in left-to-right order</li>
<li>default member initializers top-to-bottom</li>
<li>constructor initializer lists in top-to-bottom member definition order</li>
<li>constructor body initialization</li>
</ol>
<h3 id="member-initialization">
<span class="hash">#</span>
<a href="#member-initialization" class="header-link">Member Initialization</a>
</h3>
<p>The order of initializing member variables is:</p>

<ol>
<li>default member initialization</li>
<li>constructor initializer lists in top-to-bottom member definition order</li>
<li>constructor body initialization</li>
</ol>

<p>Constructor initializer lists initialize member variables. If a member variable is missing from the initializer list it is default initialized. Members that are <code>const</code> or references must be initialized in the constructor initializer lists. Members in a constructor initializer list are initialized in the order in which they are defined in the class definition.</p>

<p>It is considered best practice to use default member initializers for member variables, opting for constructor initializer lists for edge cases, and for constructor initialization in the worst case.</p>

<p>If a member has a default member initializer and also appears in a constructor&#39;s member initializer list, the default member initializer is ignored. The default member initializer can be thought of as the initializer to use if the member would otherwise be default-initialized.</p>

<p>Value initialization occurs when:</p>

<ul>
<li>in an array initialization, fewer declarations appear than the size of the array</li>
<li>defining a local static object without an initializer</li>
<li>explicitly requesting value initialization by writing expressions of the form <code>T()</code> where <code>T</code> is the name of the type</li>
</ul>

<p>Member functions defined inside the class definition are inlined.</p>
<h3 id="list-initialization">
<span class="hash">#</span>
<a href="#list-initialization" class="header-link">List-Initialization</a>
</h3>
<p>A <em>narrowing conversion</em> is:</p>

<ul>
<li>from floating-point to integral type</li>
<li>from <code>long double</code> to <code>double</code> or <code>float</code>, unless source is a <code>constexpr</code> and there is no overflow</li>
<li>from <code>double</code> to <code>float</code>, unless source is a <code>constexpr</code> and there is no overflow</li>
<li>from integral type to floating-point type, unless source is a <code>constexpr</code> whose value can be represented <em>exactly</em> in the target type</li>
<li>from integral or unscoped enumeration to an integral type that cannot represent all values of the original, unless source is a <code>constexpr</code> whose value can be represented exactly in the target type</li>
</ul>

<p>A <em>braced-init-list</em> is <em>not</em> an expression, and by extension it has no type. For this reason, it can&#39;t be used as an argument to <code>decltype()</code>. Since it has no type, template argument deduction <em>cannot</em> deduce a type that matches a braced-init-list.</p>

<p>The following is ill-formed because the braced-init-list has no type and thus a type cannot be deduced, so a function template cannot be instantiated.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="n">f</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span>
</code></pre></figure>
<p>The <code>auto</code> keyword makes an exception in that it deduces any braced-init-list as an <code>std::initializer_list</code>.</p>

<p>The list-initialization sequence consists of:</p>

<ol>
<li>If <code>T</code> is a class type and there&#39;s a single element that IS-A <code>T</code>, then initialize from that element.</li>
<li>If <code>T</code> is a character array and there&#39;s a single element that is a string literal, then initialize from the string literal</li>
<li>If <code>T</code> is an aggregate type, then perform <a href="#aggregate-initialization">aggregate-initialization</a>.</li>
<li>If <code>T</code> is a class type with a default constructor and the braced-init-list is empty, then perform <a href="#value-initialization">value-initialization</a></li>
<li>If <code>T</code> is an <code>std::initializer_list</code>, then initialize from the temporary rvalue <code>std::initializer_list</code>.</li>
<li>If <code>T</code> is a class type then overload resolution chooses between its constructors:

<ol>
<li>those that only take an <code>std::initializer_list</code> (despite default parameters)</li>
<li>those with parameters matching the braced-init-list elements as arguments, barring narrowing conversions.</li>
</ol></li>
<li>If there&#39;s a single element of type <code>E</code> and <code>T</code> is not a reference type, or <em>is</em> a reference type <em>and</em> IS-A <code>E</code>, then initialize from the element barring narrowing conversions</li>
<li>If <code>T</code> is an lvalue <code>const</code> reference or rvalue reference, then bind to the rvalue reference of the list-initialize temporary</li>
<li>If the braced-init-list is empty, then perform <a href="#value-initialization">value-initialization</a>.</li>
</ol>
<h3 id="aggregate-initialization">
<span class="hash">#</span>
<a href="#aggregate-initialization" class="header-link">Aggregate-Initialization</a>
</h3>
<p>An aggregate is an object is either an array or a class type that has:</p>

<ul>
<li>no <code>private</code> or <code>protected</code> members</li>
<li>no user-provided constructors, though it&#39;s allowed to explicitly mark them <code>default</code> or <code>delete</code></li>
<li>no base classes</li>
<li>no virtual member functions</li>
<li>no default member initializers</li>
</ul>

<p>Aggregate-initialization occurs whenever an aggregate type is initialized.</p>

<p>The aggregate-initialization sequence consists of:</p>

<ol>
<li>Copy-initialize each array element or member</li>
<li><p>If the braced-init-list&#39;s size is greater than the number of members or empty, then the remaining members are initialized by their default member initializers, or if there are none, using <a href="#value-initialization">value-initialization</a>.</p>

<p>A consequence of this is that it&#39;s possible to initialize only the first column of a 2D array, for example, such that the following two arrays are equivalent:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">}};</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">}};</span>
</code></pre></figure></li>
<li><p>Braces around nested subaggregate initializer lists may be omitted, i.e. the following two initializations are equivalent:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}};</span>
</code></pre></figure></li>
</ol>
<h3 id="constant-initialization">
<span class="hash">#</span>
<a href="#constant-initialization" class="header-link">Constant-Initialization</a>
</h3>
<p>Constant-initialization occurs after zero-initialization of static and thread-local objects, but before <em>all other</em> initializations.</p>
<h3 id="copy-initialization">
<span class="hash">#</span>
<a href="#copy-initialization" class="header-link">Copy-Initialization</a>
</h3>
<p>Copy-initialization only considers non-explicit constructors and non-explicit user-defined conversion functions.</p>

<p>Copy-initialization occurs when:</p>

<ul>
<li><p>Assigning to a new object with the equals sign (not assignment operator):</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span> <span class="n">object</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span>
</code></pre></figure></li>
<li><p>Passing a parameter by-value:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">f</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
</code></pre></figure></li>
<li><p>Returning a by-value:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">return</span> <span class="n">other</span><span class="p">;</span>
</code></pre></figure></li>
<li><p>Throwing or catching by-value:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">throw</span> <span class="n">object</span><span class="p">;</span>

<span class="k">catch</span> <span class="p">(</span><span class="n">T</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></figure></li>
<li><p>Placing an object in a brace-initializer:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span> <span class="n">array</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">other</span><span class="p">};</span>
</code></pre></figure></li>
</ul>

<p>Given a target type <code>T</code> and initializing expression <code>E</code>, the copy-initialization sequence consists of:</p>

<ol>
<li>If <code>T</code> is a class type and <code>E</code> IS-A <code>T</code>, overload resolution chooses the best converting constructor</li>
<li><p>If either:</p>

<ul>
<li><code>T</code> is a class type and <code>E</code> is of a different type</li>
<li><code>T</code> is not a class type but <code>E</code> is a class type</li>
</ul>

<p>Then overload resolution chooses the best user-defined conversion, the result of which is used for direct-initialization</p></li>
<li><p>If <code>T</code> nor <code>E</code> are class types, standard conversions are used</p></li>
</ol>
<h3 id="copy-list-initialization">
<span class="hash">#</span>
<a href="#copy-list-initialization" class="header-link">Copy-List-Initialization</a>
</h3>
<p>Copy-list-initialization, like copy-initialization, only considers non-explicit constructors.</p>

<p>Copy-list-initialization occurs when:</p>

<ul>
<li><p>initialization of a named variable with a braced-init-list <em>after</em> an equals sign <code>=</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span> <span class="n">object</span> <span class="o">=</span> <span class="p">{</span><span class="n">arg</span><span class="p">,</span> <span class="err">…</span><span class="p">};</span>
</code></pre></figure></li>
<li><p>in a function call expression with a braced-init-list as an argument which is used to list-initialize the function parameter:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">function</span><span class="p">({</span><span class="n">arg</span><span class="p">,</span> <span class="err">…</span><span class="p">});</span>
</code></pre></figure></li>
<li><p>in a <code>return</code> statement with a braced-init-list which is used to list-initialize the returned object:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">return</span> <span class="p">{</span><span class="n">arg</span><span class="p">,</span> <span class="err">…</span><span class="p">};</span>
</code></pre></figure></li>
<li><p>in a subscript expression with a user-defined <code>operator[]</code> which list-initializes the parameter of the overloaded operator:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">object</span><span class="p">[{</span><span class="n">arg</span><span class="p">,</span> <span class="err">…</span><span class="p">}];</span>
</code></pre></figure></li>
<li><p>in an assignment expression which list-initializes the parameter of the overloaded <code>operator=</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">object</span> <span class="o">=</span> <span class="p">{</span><span class="n">arg</span><span class="p">,</span> <span class="err">…</span><span class="p">};</span>
</code></pre></figure></li>
<li><p>in a functional cast expression which uses a braced-init-list to copy-list-initialize a constructor&#39;s <em>parameter</em>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">U</span><span class="p">({</span><span class="n">arg</span><span class="p">,</span> <span class="err">…</span><span class="p">});</span>
</code></pre></figure></li>
<li><p>in a data member initializer of a non-static data member that uses an equals sign <code>=</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">member</span> <span class="o">=</span> <span class="p">{</span><span class="n">arg</span><span class="p">,</span> <span class="err">…</span><span class="p">};</span>
<span class="p">};</span>
</code></pre></figure></li>
</ul>
<h3 id="direct-initialization">
<span class="hash">#</span>
<a href="#direct-initialization" class="header-link">Direct-Initialization</a>
</h3>
<p>Direct-initialization considers all constructors.</p>

<p>Direct-initialization occurs when:</p>

<ul>
<li><p>Non-empty parenthesized initialization</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span> <span class="nf">obj</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="err">…</span><span class="p">);</span>
</code></pre></figure></li>
<li><p>List-initialization</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span> <span class="n">obj</span> <span class="p">{</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="err">…</span> <span class="p">};</span>
</code></pre></figure></li>
<li><p>Functional cast</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
</code></pre></figure></li>
<li><p>Static cast</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
</code></pre></figure></li>
<li><p>Base or member constructor initializer list</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span><span class="o">::</span><span class="n">T</span><span class="p">()</span> <span class="o">:</span> <span class="n">member</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="err">…</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span>
</code></pre></figure></li>
<li><p>By-copy closure captures</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="p">[</span><span class="n">arg</span><span class="p">]()</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></figure></li>
</ul>

<p>The direct-initialization sequence consists of:</p>

<ul>
<li>If <code>T</code> is a class type, overloaded resolution determines the best constructor</li>
<li>Otherwise if <code>T</code> is a non-class type, use standard conversions</li>
</ul>
<h3 id="direct-list-initialization">
<span class="hash">#</span>
<a href="#direct-list-initialization" class="header-link">Direct-List-Initialization</a>
</h3>
<p>Direct-List-Initialization occurs when:</p>

<ul>
<li><p>Initializing a named variable with a braced-init-list:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span> <span class="n">object</span><span class="p">{</span><span class="n">arg</span><span class="p">,</span> <span class="err">…</span><span class="p">};</span>
</code></pre></figure></li>
<li><p>Initializing an unnamed temporary with a braced-init-list:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span><span class="p">{</span><span class="n">arg</span><span class="p">,</span> <span class="err">…</span><span class="p">};</span>
</code></pre></figure></li>
<li><p>Initialization of dynamic object with a braced-init-list:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">new</span> <span class="n">T</span><span class="p">{</span><span class="n">arg</span><span class="p">,</span> <span class="err">…</span><span class="p">};</span>
</code></pre></figure></li>
<li><p>Default member initializer for non-static data member that doesn&#39;t use an equals sign <code>=</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">member</span><span class="p">{</span><span class="n">arg</span><span class="p">,</span> <span class="err">…</span><span class="p">};</span>
<span class="p">};</span>
</code></pre></figure></li>
<li><p>Member initialization when using a braced-init-list in a member initializer list:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">()</span> <span class="o">:</span> <span class="n">T</span><span class="p">{</span><span class="n">arg</span><span class="p">,</span> <span class="err">…</span><span class="p">}</span> <span class="p">{</span>
    <span class="err">…</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></figure></li>
</ul>
<h3 id="default-initialization">
<span class="hash">#</span>
<a href="#default-initialization" class="header-link">Default-Initialization</a>
</h3>
<p>Default-initialization occurs when no parentheses or empty parentheses are used with a constructor, or when a base class or member is omitted from a constructor initializer list and there is no default member initializer.</p>

<p>Given a target type <code>T</code>, the default-initialization sequence consists of:</p>

<ul>
<li>If <code>T</code> is a class type, overload resolution determines the best (default) constructor.</li>
<li>If <code>T</code> is an array type, every element is default-initialized.</li>
<li>Otherwise objects with automatic storage and their subobjects are initialized to <em>indeterminate values</em></li>
</ul>
<h3 id="value-initialization">
<span class="hash">#</span>
<a href="#value-initialization" class="header-link">Value-Initialization</a>
</h3>
<p>Value-initialization occurs when:</p>

<ul>
<li><p>Nameless temporary object created with empty parentheses of braces</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span><span class="p">();</span>
<span class="n">T</span><span class="p">{};</span>
<span class="n">T</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">();</span>
<span class="n">T</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">{};</span>
</code></pre></figure></li>
<li><p>Named temporary object with empty braces</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span> <span class="n">object</span><span class="p">{};</span>
</code></pre></figure></li>
<li><p>Member initializer with empty parentheses or braces</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">T</span><span class="o">::</span><span class="n">T</span><span class="p">()</span> <span class="o">:</span> <span class="n">member</span><span class="p">()</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
<span class="n">T</span><span class="o">::</span><span class="n">T</span><span class="p">()</span> <span class="o">:</span> <span class="n">member</span><span class="p">{}</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></figure></li>
</ul>

<p>The value-initialization sequence consists of:</p>

<ul>
<li><p>If <code>T</code> is a class type with either:</p>

<ul>
<li>no default constructor</li>
<li>a user-provided default constructor</li>
<li>deleted default constructor</li>
</ul>

<p>Then the object is <a href="#default-initialization">default-initialized</a>.</p></li>
<li><p>If <code>T</code> is a class type with a default constructor that&#39;s <em>neither</em> user-provided <em>nor</em> deleted (i.e. it may be defaulted or implicitly-defined), then the object is <a href="#zero-initialization">zero-initialized</a> and then if it has a non-trivial default constructor it is also <a href="#default-initialization">default-initialized</a>.</p></li>
<li><p>If <code>T</code> is an array type, each element is value-initialized</p></li>
<li><p>Otherwise the object is <a href="#zero-initialization">zero-initialized</a>.</p></li>
</ul>
<h3 id="zero-initialization">
<span class="hash">#</span>
<a href="#zero-initialization" class="header-link">Zero-Initialization</a>
</h3>
<p>Zero-initialization occurs when:</p>

<ul>
<li><p>For every named variable with static or thread-local storage duration, <em>before any other initialization</em>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">static</span> <span class="n">T</span> <span class="n">object</span><span class="p">;</span>
</code></pre></figure></li>
<li><p>As part of the value-initialization sequence for non-class types of members of value-initialized class types that have no constructors:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">int</span><span class="p">();</span>
</code></pre></figure></li>
<li><p>Character array is initialized with string literal that is too short, so remainder of the array is zero-initialized:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">char</span> <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
</code></pre></figure></li>
</ul>

<p>The zero-initialization sequence consists of:</p>

<table>
<thead>
<tr>
<th style="text-align: left">Type</th>
<th style="text-align: left">Effect</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">scalar</td>
<td style="text-align: left">integral constant zero explicitly converted to <code>T</code></td>
</tr>
<tr>
<td style="text-align: left">non-union class type</td>
<td style="text-align: left">base classes &amp; members zero initialized; constructors ignored</td>
</tr>
<tr>
<td style="text-align: left">union type</td>
<td style="text-align: left">first named member is zero-initialized</td>
</tr>
<tr>
<td style="text-align: left">array</td>
<td style="text-align: left">each element is zero-initialized</td>
</tr>
<tr>
<td style="text-align: left">reference</td>
<td style="text-align: left">nothing</td>
</tr>
</tbody>
</table>
<h2 id="access-specifiers">
<span class="hash">#</span>
<a href="#access-specifiers" class="header-link">Access Specifiers</a>
</h2>
<p>Access specifiers are used for class members in class definitions and on base classes when inheriting.</p>

<p>Class member access specifiers specify the <em>external visibility</em> of members, including deriving classes. That is, if a member is given <code>private</code> visibility, not even a deriving class will be able to access that member, unless it&#39;s a <code>friend</code>. The default member access is <code>public</code> for <code>struct</code>s and <code>private</code> for <code>class</code>es.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Specifier</th>
<th style="text-align: left">Accessible from</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>public</code></td>
<td style="text-align: left">anywhere</td>
</tr>
<tr>
<td style="text-align: left"><code>protected</code></td>
<td style="text-align: left">members and friends of the class and direct inheritors</td>
</tr>
<tr>
<td style="text-align: left"><code>private</code></td>
<td style="text-align: left">members and friends of the class</td>
</tr>
</tbody>
</table>

<p>Inheritance access specifiers specify the <em>external visibility</em> of <em>inherited members</em>, which means this affects classes that derive from the derived class. The default inheritance access specifier is <code>public</code> for <code>struct</code>s and <code>private</code> for <code>class</code>es.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Specifier</th>
<th style="text-align: left">Effect</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>public</code></td>
<td style="text-align: left">inherited members retain their member access</td>
</tr>
<tr>
<td style="text-align: left"><code>protected</code></td>
<td style="text-align: left">inherited <code>public</code> members become <code>protected</code></td>
</tr>
<tr>
<td style="text-align: left"><code>private</code></td>
<td style="text-align: left">inherited <code>public</code> and <code>protected</code> members become <code>private</code></td>
</tr>
</tbody>
</table>

<p>In effect, member access specifiers specify what and how members are externally visible, whereas inheritance access specifiers are a way to specify what and how inherited members <em>which are accessible to the derived class</em> are externally visible.</p>

<p>For example, consider base <code>A</code>, inheritor <code>B: A</code>, and <code>C: B</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="n">A</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{};</span>
</code></pre></figure>
<p>If <code>A</code> marks member <code>x</code> as <code>private</code>, then <code>B</code> nor <code>C</code> will be able to access it. However, if <code>A</code> were to specify a <code>public</code> accessor method for <code>x</code> then <code>B</code> would be able to access it that way. It makes sense that <code>A</code> should be able to guard access to its internal state so that inheritors don&#39;t come to rely on it or even corrupt it.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">private</span><span class="o">:</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>

<span class="c1">// can&#39;t access x</span>
<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="n">A</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{};</span>
</code></pre></figure>
<p>If <code>A</code> marks member <code>x</code> as <code>public</code> but <code>B</code> inherits <code>A</code> as <code>private</code>, i.e. <code>B: private A</code>, then <code>C</code> won&#39;t be able to access <code>x</code>. In effect, <code>B</code> has &quot;closed off&quot; access to <code>x</code>. This can be useful if <code>B</code> has added some behavior around <code>A</code>&#39;s internal state that it doesn&#39;t want inheritors to mess up.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">private</span> <span class="n">A</span> <span class="p">{};</span>

<span class="c1">// can&#39;t access x</span>
<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{};</span>
</code></pre></figure>
<p>Note that a <code>protected</code> member is only externally accessible from derived classes. If a derived class defines a method which accepts a parameter of the base class, the <code>protected</code> member won&#39;t be accessible through that parameter even though it&#39;s in a method of the derived class:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">protected</span><span class="o">:</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
 <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">B</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// can access A::x via B</span>
 <span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// can&#39;t access A::x</span>
<span class="p">};</span>
</code></pre></figure>
<p>A name that is private according to unqualified name lookup may still be accessible through qualified name lookup.</p>

<p>Accessibility for names of virtual functions is checked at the call point using the static type of the expression. Access of the final overrider is ignored.</p>
<h2 id="base-classes">
<span class="hash">#</span>
<a href="#base-classes" class="header-link">Base Classes</a>
</h2>
<p>A base class should explicitly mark <code>default</code> all operations that it requires:</p>

<ol>
<li>virtual destructor</li>
<li>move operations (won&#39;t be implicitly defined since destructor defined)</li>
<li>copy operations (won&#39;t be implicitly defined since move operations defined)</li>
</ol>
<h2 id="virtual-base-classes">
<span class="hash">#</span>
<a href="#virtual-base-classes" class="header-link">Virtual Base Classes</a>
</h2>
<p>A virtual base class is one that is included only once for every time it is inherited as a virtual base class in the hierarchy.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">T</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">B</span> <span class="p">{};</span>
</code></pre></figure><h2 id="default-constructors">
<span class="hash">#</span>
<a href="#default-constructors" class="header-link">Default Constructors</a>
</h2>
<p>The best practice is to always define a default constructor if any other constructors are defined.</p>

<p>Default constructors are synthesized only if all of the following criteria are met:</p>

<ol>
<li>no other constructors are defined</li>
<li>all of the members of built-in or compound type have default member initializers</li>
<li>all members of class type have default constructors</li>
</ol>

<p>If other constructors are defined but otherwise all other criteria is met for synthesizing a default constructor, the default constructor can be constructed using the <code>= default</code> directive:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></figure>
<!-- TODO this isn't specific to default constructors -->

<p>Class members can be initialized inside the class definition. These initializers are known as <em>default member initializers</em>. Default member initializers must be defined either using the <code>=</code> assignment operator or list initialization syntax <code>{}</code>.</p>

<p>Constructors can <em>delegate</em> their constructing to other constructors inside the constructor initializer list. In this case, the delegated constructor must be the only initializer in the member initializer list.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>

  <span class="n">S</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>

  <span class="n">S</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">S</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
    <span class="err">…</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></figure>
<p>Virtual functions can be explicitly overridden in derived classes using the <code>override</code> trailing keyword.</p>

<p>Class methods or entire classes can be defined <code>final</code> which prevents their overriding or deriving, respectively.</p>

<p>A default-constructor is trivial if:</p>

<ul>
<li>it performs no action</li>
<li>it isn&#39;t user-provided</li>
<li>there are no virtual bases or virtual member functions</li>
<li>there are no members with default member initializers</li>
<li>every direct base and member of class type has a trivial default-constructor</li>
</ul>

<p>A default-constructor is implicitly-declared if:</p>

<ul>
<li>there are no user-defined constructors of <em>any kind</em>; OR</li>
<li>user forces the declaration via <code>default</code></li>
</ul>

<p>An implicitly-declared default-constructor is deleted if:</p>

<ul>
<li>there&#39;s a reference member without a default member initializer</li>
<li>there&#39;s a <code>const</code> member without a default-member initializer or user-defined default constructor</li>
<li>there&#39;s a member without a default member initializer and a deleted or inaccessible default-constructor</li>
<li>there&#39;s a direct base with a deleted or inaccessible default-constructor or destructor</li>
</ul>

<p>An implicitly-declared, default-constructor is implicitly-defined if it&#39;s not deleted. The effect of the implicitly-defined default-constructor is the same as a constructor with an empty initializer list and body, i.e. it calls the default-constructors of bases and members (unless the member has a default member initializer).</p>
<h2 id="destructors">
<span class="hash">#</span>
<a href="#destructors" class="header-link">Destructors</a>
</h2>
<p>Destructors do whatever work must be done to free resources used by an object, e.g. file handles. While in constructors the members are initialized before the constructor body runs, a destructor body&#39;s body executes first and then the members are destroyed afterward, in the reverse order of declaration in the class definition.</p>

<p>A destructor can be called directly on an object, but it is undefined behavior to do so more than once. For this reason, directly calling a destructor on a local object would yield undefined behavior when the destructor is automatically and implicitly called again at the end of the scope.</p>

<p>A destructor is trivial if:</p>

<ul>
<li>it isn&#39;t user provided</li>
<li>it isn&#39;t virtual (nor is the base class destructor virtual)</li>
<li>every direct base and class-type member has a trivial destructor</li>
</ul>

<p>A destructor is implicitly-declared if there is no user-defined destructor provided.</p>

<p>An implicitly-declared destructor is deleted if:</p>

<ul>
<li>there&#39;s a direct base or member with a deleted or inaccessible destructor</li>
<li>there&#39;s an implicitly-declared virtual destructor and a deleted or inaccessible <code>operator delete()</code></li>
</ul>

<p>An implicitly-declared destructor is implicitly-defined if it&#39;s not deleted or trivial. An implicitly-defined destructor simply has an empty body.</p>

<p>If one deletes <code>this</code>, then <code>this</code> and every pointer to the object becomes invalid, and no member function may be called.</p>
<h2 id="copy-constructors">
<span class="hash">#</span>
<a href="#copy-constructors" class="header-link">Copy Constructors</a>
</h2>
<p>A copy constructor is one consisting of a single parameter that is a reference to the same type of the constructor:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></figure>
<p>Copy constructors are <em>synthesized</em> if none are defined. Synthesized copy constructors perform member-wise copies of the argument. Members of class type are copied using their respective copy constructors and members of built-in type---including arrays---are copied directly.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">A</span><span class="o">::</span><span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">toCopy</span><span class="p">)</span> <span class="o">:</span>
  <span class="n">firstMember</span><span class="p">(</span><span class="n">toCopy</span><span class="p">.</span><span class="n">firstMember</span><span class="p">),</span>
  <span class="n">secondMember</span><span class="p">(</span><span class="n">toCopy</span><span class="p">.</span><span class="n">secondMember</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></figure>
<p><em>Copy initialization</em> occurs when:</p>

<ul>
<li>assigning with the <code>=</code> assignment operator to a new object</li>
<li>passing the object as an argument to parameter of non-reference type. <strong>note</strong> that this is why the parameter to the copy constructor has to be a reference type, or infinite recursion would occur</li>
<li>returning by value</li>
<li>placing in a brace initializer</li>
</ul>

<p>The compiler can perform <a href="http://en.wikipedia.org/wiki/Copy_elision">copy elision</a> to avoid unnecessary copies, short of using actual move semantics. Multiple copy elisions can be chained. Copy elision may occur when:</p>

<ul>
<li><em>Named Return Value Optimization</em> (NRVO): a class type is returned by-value and is the same type as function return type and isn&#39;t a function parameter object. It is constructed directly into the function return value.</li>
<li>A non-reference, nameless temporary that would be moved/copied into an object of same type, is instead constructed directly into the storage of the object, known as <em>Return Value Optimization</em> (RVO) when in a <code>return</code> context.</li>
</ul>

<p>It is unportable to rely on the side-effects of copy/move constructors and destructors because some compilers don&#39;t perform copy elision in every situation where it is allowed, such as in debug mode.</p>

<p>Even if copy elision isn&#39;t performed, the return statement will attempt to use the move constructor to initialize the by-value return object, only copying if that fails.</p>

<p>A copy-constructor is implicitly-declared if there are no user-defined copy-constructors or the user forced it via <code>default</code>. The type of the copy constructor is either:</p>

<ul>
<li><code>T::T(const T&amp;)</code> if all direct bases and members have copy-constructors with <code>const</code>-reference or <code>const</code>-volatile</li>
<li><code>T::T(T&amp;)</code> otherwise</li>
</ul>

<p>An implicitly-declared copy-constructor is deleted if there exists:</p>

<ul>
<li>a direct base or member with a deleted or inaccessible copy-constructor</li>
<li>a direct base with a deleted or inaccessible destructor</li>
<li>a user-defined move-constructor or move-assignment operator</li>
<li>an rvalue-reference member</li>
</ul>

<p>An implicitly-declared copy-constructor is implicitly-defined if it&#39;s not deleted or trivial. The effect of an implicitly-defined copy-constructor is equivalent to a full member-wise copy of the bases and members using direct-initialization.</p>

<p>A copy-constructor is trivial if it performs a bytewise copy of the object and:</p>

<ul>
<li>it is not user-provided</li>
<li>there are no virtual bases or virtual member functions</li>
<li>every base and member has a trivial copy-constructor</li>
<li>there are no <code>volatile</code> members</li>
</ul>
<h2 id="copy-assignment-operators">
<span class="hash">#</span>
<a href="#copy-assignment-operators" class="header-link">Copy-Assignment Operators</a>
</h2>
<p>Assignment operators control how objects of its class are assigned. They generally should return a reference to the left-hand object.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">A</span><span class="o">&amp;</span> <span class="n">A</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">firstMember</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">firstMember</span><span class="p">;</span>
    <span class="n">secondMember</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">secondMember</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>Copy-assignment operators are <em>synthesized</em> if none are define. Synthesized copy-assignment operators perform member-wise assignment before returning a reference to the left-hand object.</p>

<p><em>Copy-assignment</em> occurs when an existing object is assigned a new value from another existing object.</p>

<p>A copy-assignment operator is trivial if it creates an object copy as if by <code>std::memmove</code>, and:</p>

<ul>
<li>isn&#39;t user-provided</li>
<li>there are no virtual bases or virtual member functions</li>
<li>every direct base and class-type member has a trivial copy-assignment operator</li>
</ul>

<p>A copy-assignment operator is implicitly-declared if there are no user-defined copy-assignment operators or the user forced it via <code>default</code>. The type of an implicitly-declared copy-assignment operator is:</p>

<ul>
<li><code>T&amp; T::operator=(const T&amp;)</code> if each base and member has a copy-assignment operator with a parameter type of one of the following: <code>B</code>, <code>const B&amp;</code>, <code>const volatile B&amp;</code></li>
<li><code>T&amp; T::operator=(T&amp;)</code> otherwise</li>
</ul>

<p>An implicitly-declared copy-assignment operator is deleted if:</p>

<ul>
<li>user-declared move constructor or move-assignment operator</li>
<li>there&#39;s a non-class type <code>const</code> member</li>
<li>there&#39;s a reference member</li>
<li>there&#39;s a member or direct base with a deleted or inaccessible copy-assignment operator</li>
</ul>

<p>An implicitly-declared copy-assignment operator is implicitly-defined if it&#39;s not deleted or trivial. The effect of an implicitly-defined copy-assignment operator is simply to perform a member-wise copy-assignment of the bases and members.</p>
<h2 id="move-constructors">
<span class="hash">#</span>
<a href="#move-constructors" class="header-link">Move Constructors</a>
</h2>
<p>Because rvalue-references serve as a sort of &quot;tag&quot; on an object that&#39;s about to be destroyed, functions can overload implementations specifically for such objects. In effect, a move constructor is used when overload resolution selects the move constructor---which is considered a converting constructor---because the argument is an rvalue expression.</p>

<p>An example of this would be a move constructor:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">A</span><span class="o">::</span><span class="n">A</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span><span class="n">moveFrom</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span>
  <span class="n">firstMember</span><span class="p">(</span><span class="n">moveFrom</span><span class="p">.</span><span class="n">firstMember</span><span class="p">),</span>
  <span class="n">secondMember</span><span class="p">(</span><span class="n">moveFrom</span><span class="p">.</span><span class="n">secondMember</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">moveFrom</span><span class="p">.</span><span class="n">firstMember</span> <span class="o">=</span> <span class="n">moveFrom</span><span class="p">.</span><span class="n">secondMember</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></figure>
<p>It&#39;s important to leave the moved-from object in a destructible state.</p>

<p>A move-constructor is implicitly-declared if there are no user-defined move-constructors and there are no user-declared:</p>

<ul>
<li>copy-constructors</li>
<li>copy-assignment operators</li>
<li>move-assignment operators</li>
<li>destructors</li>
</ul>

<p>An implicitly-declared move-constructor is deleted if there&#39;s:</p>

<ul>
<li>a direct base or member with a deleted or inaccessible move-constructor</li>
<li>a direct base with a deleted or inaccessible destructor</li>
</ul>

<p>A move-constructor is trivial if it performs a simple copy, same as a trivial copy constructor, and it is:</p>

<ul>
<li>not user-provided</li>
<li>there are no virtual bases or virtual member functions</li>
<li>every direct base and member has a trivial move-constructor</li>
<li>there are no <code>volatile</code> members</li>
</ul>

<p>An implicitly-declared move-constructor is implicitly-defined if it&#39;s not deleted or trivial. The effect of an implicitly-defined move-constructor is to perform a full member-wise move of object bases and members.</p>
<h2 id="move-assignment-operator">
<span class="hash">#</span>
<a href="#move-assignment-operator" class="header-link">Move-Assignment Operator</a>
</h2>
<p>This is similar to the move constructor:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">A</span><span class="o">&amp;</span> <span class="n">A</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">firstMember</span><span class="p">;</span>
    <span class="n">firstMember</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">firstMember</span><span class="p">;</span>
    <span class="n">rhs</span><span class="p">.</span><span class="n">firstMember</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>An interesting thing to note is that the move-assignment operator can be defined in terms of the copy-assignment operator if a move constructor is defined:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">B</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span> <span class="n">other</span><span class="p">.</span><span class="n">B</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">A</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swap</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></figure>
<p>In this case, if an rvalue-reference is used with the assignment operator, then the <code>rhs</code> variable is created using the move-constructor which simply allows <code>rhs</code> to steal the <code>B</code> pointer from the rvalue. Once inside the assignment operator function body, the current instance steals the <code>B</code> pointer from the <code>rhs</code> copy. The <code>rhs</code> copy is automatically destroyed when it goes out of scope.</p>

<p>A move-assignment operator is implicitly-declared if there are no user-defined move-assignment operators or user-forced move-assignment operator via <code>default</code>. Also, there are no user-declared:</p>

<ul>
<li>copy constructors</li>
<li>move constructors</li>
<li>copy-assignment operators</li>
<li>destructors</li>
</ul>

<p>An implicitly-declared move-assignment operator is deleted if:</p>

<ul>
<li>there is a <code>const</code> or reference member</li>
<li>there is a base or member with a <code>delete</code>d or inaccessible move-assignment operator</li>
</ul>

<p>A move-assignment operator is trivial if it performs a simple copy, same as the trivial copy constructor, and:</p>

<ul>
<li>it isn&#39;t user-provided</li>
<li>there are no virtual bases or virtual member functions</li>
<li>every direct base and class-type member has a trivial move-assignment operator</li>
</ul>

<p>An implicitly-declared move-assignment operator is implicitly-defined if it&#39;s neither deleted nor trivial. In this case, the implicitly-defined move-assignment operator simply performs a full member-wise move-assignment of direct bases and members.</p>
<h3 id="synthesis">
<span class="hash">#</span>
<a href="#synthesis" class="header-link">Synthesis</a>
</h3>
<p>Unlike the copy operations that are <em>always</em> synthesized if they&#39;re not otherwise defined or deleted, the compiler <em>only</em> synthesizes move operations if the class doesn&#39;t define any copy operations and if every non-static data member is moveable. Moveable members include built-in types and those that define a move operation.</p>

<p>If a class defines move operations, the respective copy operation will be defined as deleted and must be defined explicitly.</p>

<p>If a default implementation is explicitly requested with the <code>default</code> directive, but the compiler can&#39;t define one due to the following reasons, then it will be defined as <code>deleted</code>:</p>

<ul>
<li>the class has a member that defines its own copy constructor but not a move constructor <em>or</em> if the class has a member that doesn&#39;t define its own copy operations <em>and</em> for which the compiler is unable to synthesize a move constructor. The same applies for move-assignment.</li>
<li>the class has a member whose respective move operation is deleted or inaccessible</li>
<li>the destructor is deleted or inaccessible</li>
<li>the class has a <code>const</code> or reference member</li>
</ul>
<h2 id="conversions">
<span class="hash">#</span>
<a href="#conversions" class="header-link">Conversions</a>
</h2>
<!--
TODO
perhaps create a parent Conversions section and under it
put the converting constructor and conversion operators sections
also merge the implicit conversions section
-->

<p>The sequence order of implicit conversions is:</p>

<ol>
<li>0 or 1 standard conversion sequence</li>
<li>0 or 1 user-defined conversion</li>
<li>0 or 1 standard conversion sequence</li>
</ol>

<p>The sequence of a standard conversion is:</p>

<ol>
<li>0 or 1 lvalue transformation</li>
<li>0 or 1 numeric promotion or conversion</li>
<li>0 or 1 function pointer conversion</li>
<li>0 or 1 qualification adjustment</li>
</ol>

<p>A user-defined conversion consists of:</p>

<ol>
<li>0 or 1 non-explicit, single-argument constructor or non-explicit conversion function call</li>
</ol>

<p>An <em>explicit</em> <code>bool</code> conversion operator can be used in an implicit conversion sequence when it&#39;s used in the context of:</p>

<ul>
<li><code>if</code>, <code>while</code>, <code>for</code> conditions</li>
<li>logical operators <code>!</code>, <code>&amp;&amp;</code>, <code>||</code></li>
<li>ternary operator <code>:?</code></li>
<li><code>static_assert</code></li>
<li><code>noexcept</code></li>
</ul>

<p>An expression <code>E</code> is implicitly convertible to <code>T</code> when an object of <code>T</code> can be copy-initialized with expression <code>E</code>.</p>

<p>The conversion ranks of primitive types are as follows. Note that the unsigned counterparts have equal rank:</p>

<ol>
<li><code>bool</code></li>
<li><code>char</code></li>
<li><code>short</code></li>
<li><code>int</code></li>
<li><code>long</code></li>
<li><code>long long</code></li>
</ol>

<p>Arithmetic conversions produce a common type by:</p>

<ul>
<li>if either operand is a scope <code>enum</code>, other must be same type</li>
<li>if either operand is <code>long double</code>, other to <code>long double</code></li>
<li>if either operand is <code>double</code>, other to <code>double</code></li>
<li>if either operand is <code>float</code>, other to <code>float</code></li>
<li>if operand has integer type (<code>bool</code>, <code>char</code>, unscoped <code>enum</code> promoted to):

<ul>
<li>if both are signed or unsigned: operand with lesser conversion rank converted to operand with greater conversion rank</li>
<li>unsigned operand conversion rank ≤ signed operand conversion rank: signed operand converted to unsigned operand type</li>
<li>if signed operand&#39;s type can represent all values of unsigned operand: unsigned operand converted to signed operand&#39;s type</li>
<li>else: both operands are converted to unsigned counterpart of signed operand&#39;s type</li>
</ul></li>
</ul>
<h3 id="converting-constructors">
<span class="hash">#</span>
<a href="#converting-constructors" class="header-link">Converting Constructors</a>
</h3>
<p>Converting constructors allow for the implicit conversion <em>from</em> other types to the class type. Only one such implicit conversion is possible; it isn&#39;t possible to chain multiple such conversions. Examples of converting constructors are implicitly-declared or user-defined, non-explicit copy and move constructors.</p>

<p>To prevent a converting constructor from being used to perform an implicit conversion, the function can be marked <code>explicit</code>, in which case the constructor is <em>no longer</em> considered a converting constructor.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">explicit</span> <span class="nf">A</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">)</span> <span class="o">:</span> <span class="n">internal</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></figure>
<p>Explicit conversion functions are only considered when performing <a href="#direct-initialization">direct-initialization</a>, whereas converting constructors are considered during <a href="#copy-initialization">copy-initialization</a> as part of the user-defined conversion sequence.</p>

<p>Explicit conversion functions can be used via an explicit <code>static_cast</code> or with direct-initialization.</p>
<h3 id="conversion-operators">
<span class="hash">#</span>
<a href="#conversion-operators" class="header-link">Conversion Operators</a>
</h3>
<p>Whereas <a href="#converting-constructors">converting constructors</a> provide a way of converting another type to the class type, conversion operators provide a way of converting the class type to another type. They are defined using the <code>operator</code> keyword followed by the type it converts to.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">operator</span> <span class="kt">bool</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">B</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></figure>
<p>However, creating a <code>bool</code> conversion operator can cause unexpected results such as in the following:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
</code></pre></figure>
<p>The above code is legal even though <code>&lt;&lt;</code> isn&#39;t defined for <code>cin</code> which is of type <code>istream</code>. The reason it&#39;s legal is that <code>cin</code> gets converted to <code>bool</code>, which then gets promoted to an <code>int</code>, after which the operation becomes a simple left-shift operation.</p>

<p>For this reason, conversion operators can be defined as explicit. A conversion operator that is defined as explicit won&#39;t be performed implicitly and instead it must be performed explicitly through the use of <code>static_cast</code>. The only exception to this is when the expression would be used for boolean logic.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">B</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></figure><h3 id="conversion-ambiguity">
<span class="hash">#</span>
<a href="#conversion-ambiguity" class="header-link">Conversion Ambiguity</a>
</h3>
<p>It&#39;s pretty easy to get into a situation where it becomes ambiguous as to how a type is being converted.</p>

<p>In general:</p>

<ul>
<li>don&#39;t define mutually converting classes</li>
<li>avoid conversions to built-in arithmetic types. If this is necessary, then:

<ul>
<li>don&#39;t define overloaded versions of operators that take arithmetic types since the conversion will handle it</li>
<li>don&#39;t define a conversion for more than one arithmetic type</li>
</ul></li>
</ul>

<p>However, it&#39;s probably best to try to completely avoid conversion functions with the exception of explicit conversions to <code>bool</code> and others that are very obvious.</p>
<h4 id="mutual-conversions">
<span class="hash">#</span>
<a href="#mutual-conversions" class="header-link">Mutual Conversions</a>
</h4>
<p>One way is to create a converting constructor to a type that itself defines a conversion operator to the original type.</p>

<p>For example, given:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">B</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span>
  <span class="k">operator</span> <span class="n">A</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></figure>
<p>Both <code>A</code> and <code>B</code> define mutual conversions. <code>A</code> defines a converting constructor that converts <code>B</code> to <code>A</code>, and <code>B</code> itself defines a conversion operator that converts from <code>B</code> to <code>A</code>. Therefore, the last line in the following code is ambiguous:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">A</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">B</span> <span class="n">b</span><span class="p">;</span>
<span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</code></pre></figure>
<p>Because the conversion operation is ambiguous to the compiler, an error is emitted. Instead, it would have to be explicitly qualified:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">A</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="k">operator</span> <span class="n">A</span><span class="p">());</span> <span class="c1">// use B&#39;s converting operator</span>
<span class="n">A</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>           <span class="c1">// use A&#39;s converting constructor</span>
</code></pre></figure>
<p>To avoid ambiguity, one should not define classes with mutual conversions.</p>
<h4 id="redundant-built-in-conversions">
<span class="hash">#</span>
<a href="#redundant-built-in-conversions" class="header-link">Redundant Built-In Conversions</a>
</h4>
<p>Another way is to define multiple conversions to or from types that themselves are related by conversions.</p>

<p>For example, given:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">A</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
  <span class="k">operator</span> <span class="nf">int</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">operator</span> <span class="nf">double</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></figure>
<p>Due to implicit integer promotion, the two conversions to and from <code>int</code> and <code>double</code> become ambiguous to the compiler:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span><span class="p">);</span>
<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="n">f2</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>    <span class="c1">// operator int () or operator double ()</span>

<span class="kt">long</span> <span class="n">lg</span><span class="p">;</span>
<span class="n">A</span> <span class="nf">a2</span><span class="p">(</span><span class="n">lg</span><span class="p">);</span> <span class="c1">// A(int) or A(double)</span>
</code></pre></figure>
<p>The calls above are ambiguous because <code>long -&gt; double</code> and <code>long -&gt; int</code> both have the same rank in terms of integral promotion. If instead the parameter had been of type <code>short</code> then the promotion of <code>short -&gt; int</code> would have had a higher rank than <code>short -&gt; double</code> and so that conversion would have been chosen by the compiler.</p>

<p>For this reason, one should not define more than one conversion to or from an arithmetic type.</p>
<h2 id="delete">
<span class="hash">#</span>
<a href="#delete" class="header-link">Delete</a>
</h2>
<p>Functions can be specified as <strong>deleted</strong> which prevents the compiler from generating code for them. This can be helpful for preventing copying of a specific type:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">NoCopy</span> <span class="p">{</span>
  <span class="n">NoCopy</span><span class="p">(</span><span class="k">const</span> <span class="n">NoCopy</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">NoCopy</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NoCopy</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></figure>
<p>The compiler sometimes defines copy-control members, which it would have otherwise synthesized, as <strong>deleted</strong> for the following reasons:</p>

<ul>
<li><strong>destructor</strong>: if a member has a deleted or inaccessible destructor, e.g. <code>private</code></li>
<li><strong>copy constructor</strong>: if a member has a deleted or inaccessible copy constructor <em>or</em> if a member has a deleted or inaccessible destructor</li>
<li><strong>copy-assignment operator</strong>: if a member has a deleted or inaccessible copy-assignment operator <em>or</em> if the class has a <code>const</code> or reference member</li>
<li><strong>default constructor</strong>: if a member has a deleted or inaccessible destructor <em>or</em> has a reference member without a default member initializer <em>or</em> has a <code>const</code> member whose type has no explicit default constructor and the member has no default member initializer</li>
</ul>

<p>Any function can be marked <code>delete</code>, not just special member functions. This can be used to prevent certain inadvertent conversions from taking place, since overload resolution will automatically select it and the compiler will emit an error since it&#39;s deleted:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">bool</span> <span class="nf">isLucky</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">);</span>      <span class="c1">// arg _must_ be int</span>
<span class="kt">bool</span> <span class="nf">isLucky</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>   <span class="c1">// not char</span>
<span class="kt">bool</span> <span class="nf">isLucky</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>   <span class="c1">// not bool</span>
<span class="kt">bool</span> <span class="nf">isLucky</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// not float or double</span>

<span class="n">isLucky</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">)</span>  <span class="c1">// error: call to deleted function</span>
<span class="n">isLucky</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="c1">// same</span>
<span class="n">isLucky</span><span class="p">(</span><span class="mf">3.5f</span><span class="p">)</span> <span class="c1">// same</span>
</code></pre></figure>
<p><code>delete</code> can also be used to prevent certain template instantiations. This is accomplished by specializing the instantiation and deleting it.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// shouldn&#39;t be instantiated for use with</span>
<span class="c1">// void* or char*</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">processPointer</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">void</span> <span class="n">processPointer</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">void</span> <span class="n">processPointer</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</code></pre></figure><h2 id="swapping">
<span class="hash">#</span>
<a href="#swapping" class="header-link">Swapping</a>
</h2>
<p>Classes that allocate resources might want to define a <code>swap</code> inline friend function that simply swaps pointers around. This is useful for classes that allocate resources, and can be re-used in copy and move operations.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">SomeType</span> <span class="o">*</span><span class="n">B</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="n">A</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
  <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">B</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">B</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p>It&#39;s <em>very</em> important to recognize that the <code>swap</code> function used isn&#39;t explicitly qualified to be from the <code>std</code> namespace. Instead, the <code>swap</code> function from the <code>std</code> namespace is brought into the scope for purposes of name resolution.</p>

<p><strong>Not</strong> explicitly qualifying the function allows a type-specific <code>swap</code> function to be used in the event that one is defined, which would be much more efficient than using the <code>std</code> function which simply creates a temporary swap value.</p>

<p>One use of the <code>swap</code> function is to implement the assignment operator:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">A</span><span class="o">&amp;</span> <span class="n">A</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">A</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>It&#39;s important to note that this implementation passes the right-hand side by value and not by reference. This is done so that after the type internals are swapped, the right-hand side&#39;s copy&#39;s destructor is run and the resources are freed. This handles self-assignment gracefully.</p>
<h2 id="inheritance">
<span class="hash">#</span>
<a href="#inheritance" class="header-link">Inheritance</a>
</h2>
<p>Constructors, copy and move operations, and assignment operations all have to handle initializing not only their members but also those of the base class. This is usually accomplished by delegating that work to the equivalent operation from the base class.</p>

<p><em>However</em>, a destructor is always only in charge of destroying only its own members. The base class destructor is implicitly invoked after the completion of the derived class destructor.</p>

<p><em>Name lookup</em> is affected by inheritance and virtual functions. Given a call <code>p-&gt;mem()</code> or <code>p.mem()</code>:</p>

<ol>
<li>determine the static type of <code>p</code></li>
<li>look for <code>mem</code> in the class that corresponds to the static type of <code>p</code>. If it&#39;s not found, continue the lookup up the inheritance hierarchy. Error if not found.</li>
<li>perform normal type checking (&sect; 6.1 p. 203) to see if the call is legal</li>
<li>if it&#39;s legal, generate code depending on whether the call is virtual:

<ol>
<li><strong>virtual</strong>: if the call is made through a reference or pointer, then generate code to determine at run-time which version to run based on the dynamic type of <code>p</code></li>
<li><strong>otherwise</strong>: if the call isn&#39;t virtual or made through a reference or pointer, then generate a normal function call</li>
</ol></li>
</ol>

<p>Inheritance can be prevented by a class using the <code>final</code> directive:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">A</span> <span class="k">final</span> <span class="p">{};</span>
</code></pre></figure>
<p>This directive can also be used on specific member functions:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">Perform</span><span class="p">()</span> <span class="k">final</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></figure><h3 id="virtual-functions">
<span class="hash">#</span>
<a href="#virtual-functions" class="header-link">Virtual Functions</a>
</h3>
<p>An <em>abstract base class</em> is one that contains a pure abstract method, which is one that <em>must</em> be implemented by children.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">T</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></figure>
<p>Sometimes a class needs to be abstract but there are no other functions available to declare as pure virtual. In this case, the destructor may be explicitly defined as pure virtual. However, it would need also require a definition, since all base class destructors are always called when a derived class is destroyed.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">T</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">T</span><span class="o">::~</span><span class="n">T</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></figure>
<p>A <em>polymorphic class</em> is one that declares or inherits at least one virtual function.</p>

<p>Function templates <em>cannot</em> be declared <code>virtual</code>.</p>

<p>Virtual functions can be bypassed by using qualified name lookup:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">Derived</span> <span class="n">derived</span><span class="p">;</span>
<span class="n">Base</span> <span class="o">&amp;</span><span class="n">base</span> <span class="o">=</span> <span class="n">derived</span><span class="p">;</span>

<span class="c1">// call Base::func not Derived::func</span>
<span class="n">br</span><span class="p">.</span><span class="n">Base</span><span class="o">::</span><span class="n">func</span><span class="p">();</span>
</code></pre></figure>
<p>Note that virtual functions can&#39;t use return type deduction.</p>

<p>A function with the same name but different parameter list as a base class virtual function does <em>not</em> override the base virtual function of the same name. Instead it shadows it during unqualified name lookup, unless it&#39;s called through a pointer or reference of the base type.</p>

<p>An overriding function can differ in its return type <em>only if</em>:</p>

<ul>
<li>both types are single-level pointers or references to classes</li>
<li>the base virtual function&#39;s return type is a direct or indirect base class of the override&#39;s return type</li>
<li>the override&#39;s return type is equally or less cv-qualified than the base return type</li>
</ul>

<p>Virtual destructors are <em>automatically</em> overridden in derived classes.</p>

<p>When a virtual function is called directly or indirectly in a constructor or destructor---including the construction or destruction of members---and the object to which the call applies is the object being constructed or destroyed, the function that is effectively called is the final overriding function in the constructor or destructor&#39;s class, that is, dynamic dispatch doesn&#39;t propagate down the inheritance hierarchy as usual. The more-derived classes don&#39;t exist yet during construction or destruction.</p>

<p>In a class with multiple bases, construction of one subobject restricts polymorphism to its class and its bases.</p>

<p>In a class with multiple bases, during the construction of a base subobject, obtaining a pointer or reference to a separate base subobject and calling a virtual function on it is undefined behavior. In practice, the virtual call is attempted using the current branch&#39;s class virtual table.</p>

<p>The choice of which virtual method to call is often made via <em>virtual tables</em>. A virtual table is constructed for each class containing or overriding virtual methods. Each class is given a virtual table pointer as a hidden member which points to that class&#39; virtual table. Each virtual table entry contains the address of the appropriate, potentially-overriding implementation of the virtual method for that class. All type-compatible classes have virtual tables with the same layout, this enables a base class pointer to execute overridden methods.</p>

<p>A virtual method invocation on the class&#39; first method can effectively look like this, given that <code>d</code> is the class:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">d</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))(</span><span class="n">d</span><span class="p">)</span>
</code></pre></figure>
<ol>
<li><p><code>addr = (*d)[0]</code></p>

<p>Dereference the virtual table pointer to access the table, then get the address of the first method within it.</p></li>
<li><p><code>(*addr)(d)</code></p>

<p>Invoke the method, passing the correct value of <code>this</code> as the first parameter.</p></li>
</ol>
<h3 id="constructors">
<span class="hash">#</span>
<a href="#constructors" class="header-link">Constructors</a>
</h3>
<p>Constructors of derived classes can&#39;t directly initialize base-class members. Instead, initialization is delegated to the base-class constructor:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">B</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ltr</span><span class="p">)</span> <span class="o">:</span>
  <span class="n">A</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">num</span><span class="p">),</span> <span class="n">ltr_</span><span class="p">(</span><span class="n">ltr</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></figure>
<p>If the base-class is not initialized in this manner, then the base-class is default initialized.</p>
<h3 id="inherited-constructors">
<span class="hash">#</span>
<a href="#inherited-constructors" class="header-link">Inherited Constructors</a>
</h3>
<p>It&#39;s possible to &quot;inherit&quot; constructors from the base class:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="nl">B</span> <span class="p">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">A</span><span class="o">::</span><span class="n">A</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></figure>
<p>The <code>using</code> directive causes <code>B</code> to &quot;inherit&quot; <em>each</em> of the constructors from <code>A</code> except:</p>

<ol>
<li>the default, copy, and move constructors</li>
<li>those which have the same parameter lists as one of the constructors already defined in the derived class</li>
</ol>

<p>Despite the first exception above, the inherited constructors aren&#39;t considered to be &quot;user defined&quot; and so the compiler can still synthesize the default, copy, and move constructors if allowed.</p>

<p>The inherited constructors have the exact same properties as defined in the base class, including accessibility, <code>explicit</code>, and <code>constexpr</code>.</p>
<h3 id="copy-and-move-operations">
<span class="hash">#</span>
<a href="#copy-and-move-operations" class="header-link">Copy and Move Operations</a>
</h3>
<p>If a derived class defines a copy or move operation, then it is responsible for copy or moving the entire object including base-class members. This is accomplished similar to what a regular does by delegating the work to the equivalent constructor in the base class.</p>
<h3 id="copy-assignment-operator">
<span class="hash">#</span>
<a href="#copy-assignment-operator" class="header-link">Copy-Assignment Operator</a>
</h3>
<p>As with the constructor and copy/move operations, the copy-assignment operator can delegate its work to the copy-assignment operator of the base class:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">B</span><span class="o">&amp;</span> <span class="n">B</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// delegate to base copy</span>
  <span class="n">A</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>

  <span class="c1">// assign members of derived class</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure><h3 id="destructors">
<span class="hash">#</span>
<a href="#destructors" class="header-link">Destructors</a>
</h3>
<p>Base classes that intend to be derived from should define their constructors as <code>virtual</code>, so that correct destructor is run through dynamic dispatch based on the dynamic type of the object being destroyed, instead of the static type. Otherwise destroying a polymorphic class with no virtual destructor is undefined behavior.</p>

<p>This has an implication with move semantics. If a destructor is defined, even as <code>default</code>, then no move operations are synthesized for that class. This issue percolates throughout the inheritance hierarchy, since classes don&#39;t synthesize operations that the base class doesn&#39;t define.</p>

<p>For this reason, the base class usually explicitly defines---even if as <code>default</code>---all of the operations it requires. First the virtual destructor for the aforementioned reasons, then move operations for the aforementioned reasons, and then the copy operations since they would otherwise not be synthesized since the move operations are explicitly defined.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Widget</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="n">Base</span><span class="p">(</span><span class="n">Base</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">Base</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Base</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="n">Base</span><span class="p">(</span><span class="k">const</span> <span class="n">Base</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">Base</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Base</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></figure><h2 id="operator-overloading">
<span class="hash">#</span>
<a href="#operator-overloading" class="header-link">Operator Overloading</a>
</h2>
<p>Overloaded operators can be called in a function notation syntax.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;A&quot;</span><span class="p">;</span>

<span class="n">str</span><span class="p">.</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">);</span>        <span class="c1">// str += &quot;B&quot;</span>
<span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span> <span class="c1">// std::cout &lt;&lt; str;</span>
</code></pre></figure>
<p>A <em>function object</em> is one that overloads the function call operator <code>operator()</code>.</p>

<p>In order to distinguish pre-increment from post-increment operators, the post-increment operator overloads take a dummy integer parameter.</p>

<p>The canonical pre-increment operator implementation increments and returns a reference to the newly incremented value.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">X</span> <span class="p">{</span>
  <span class="n">X</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></figure>
<p>The canonical post-increment operator implementation copies the original value and increments the actual value, then returns the copy of the previous value. Often the actual increment can be delegated to the pre-increment operator.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">X</span> <span class="p">{</span>
  <span class="n">X</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">X</span> <span class="n">tmp</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>     <span class="c1">// copy</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// increment</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>       <span class="c1">// return original value</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></figure>
<p>This makes it obvious what the effect of <code>*it++</code> is. First it copies <code>it</code>, then increments the original, then dereferences the copy of <code>it</code>.</p>

<p>Instead of dealing with the complexity of overloading the subscript operator to enable multidimensional array access, since it would entail returning intermediary window/view objects, it is common to overload <code>operator()</code> to return a reference to the correct value, e.g. <code>matrix(i, j, k) = x</code>.</p>
<h2 id="size-of-every-object">
<span class="hash">#</span>
<a href="#size-of-every-object" class="header-link">Size of Every Object</a>
</h2>
<p>The size of every object must be at least 1 byte in order to ensure that each object gets a distinct address. However, the <em>empty base optimization</em> allows for empty base class subobjects to be zero-sized, since their address can be derived from the 1 byte allocated for the container class.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">Base</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">Derived</span> <span class="p">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="p">};</span>

<span class="n">assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Base</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Derived</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</code></pre></figure>
<p>Notice that the size of <code>Derived</code> is just the size of its data member <code>i</code>, and not the size of <code>i</code> <em>plus</em> the size of <code>Base</code>.</p>

<p>If one of the empty base classes is also the type or base of the type of the first member of the derived class, the empty base optimization <em>cannot</em> occur, since the two base subobjects of the same type are required to have different addresses within the object representation of the derived class, since they are separate objects.</p>
<h1 id="namespaces">
<span class="hash">#</span>
<a href="#namespaces" class="header-link">Namespaces</a>
</h1>
<p>C++17 allows specifying namespace paths in a condensed form:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// pre-C++17</span>
<span class="k">namespace</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">namespace</span> <span class="n">B</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">C</span> <span class="p">{</span>
      <span class="err">…</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// C++17</span>
<span class="k">namespace</span> <span class="n">A</span><span class="o">::</span><span class="n">B</span><span class="o">::</span><span class="n">C</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></figure>
<p>Inline namespaces treat their members as members of their enclosing namespaces, in a transitive manner.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kr">inline</span> <span class="k">namespace</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>

<span class="c1">// std::literals and its member namesapces are inline</span>
<span class="c1">// makes visible:</span>
<span class="c1">// - std::literals::string_literals::operator&quot;&quot;s</span>
<span class="c1">// - std::literals::chrono_literals::operator&quot;&quot;s</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span>
</code></pre></figure>
<p>Anonymous namespaces (aka unnamed namespaces) are treated as a namespace with a unique name followed by a <code>using</code> directive so that its members are accessible from the enclosing namespace. Any name declared within has internal linkage.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">namespace</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">namespace</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// A::(unique)::i</span>
  <span class="c1">// implicit `using namespace (unique);`</span>

  <span class="n">i</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// OK: A::(unique)::i++</span>
<span class="p">}</span>

<span class="n">A</span><span class="o">::</span><span class="n">i</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// OK: A::(unique)::i++</span>
</code></pre></figure>
<p>A <code>using</code>-declaration brings a namespace member into the current scope. Extensions of the namespace made after the point of declaration aren&#39;t visible.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</code></pre></figure>
<p>A <code>using</code>-declaration can be used in a class definition to introduce a base class member (either a variable or function) in the derived class, with possibly a <em>different</em> accessibility specifier. In effect this allows for more fine-grained tuning of the inherited members&#39; accessibility. Note that this <em>does not</em> apply to <a href="#inherited-constructors">inherited constructors</a>.</p>

<p>When a member function is introduced, all functions with that name are introduced, not just a particular overload. The derived class functions of the same prototype shadow or override the base class functions.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">B</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{}</span>
  <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">B</span><span class="o">::</span><span class="n">m</span><span class="p">;</span>  <span class="c1">// D::m is now public</span>
  <span class="k">using</span> <span class="n">B</span><span class="o">::</span><span class="n">f</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>  <span class="c1">// D::f() overrides B::f()</span>

  <span class="k">using</span> <span class="n">B</span><span class="o">::</span><span class="n">g</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// D::g(int) hides B::g(char)</span>
<span class="p">}</span>
</code></pre></figure>
<p>A <code>using</code>-declaration makes visible <em>all members</em> of a namespace as if they were declared in the nearest enclosing scope which contains <em>both</em> the <code>using</code>-directive <em>and</em> the namespace, i.e. the lowest common ancestor namespace of the <code>using</code>-directive and the namespace specified in the directive.</p>

<p>Its effect is transitive, so that nominating a namespace that itself contains <code>using</code>-directives acts as if those directives were done within the enclosing namespace.</p>

<p>Extensions of the namespace made after the point of nomination are visible, unlike with <code>using</code>-declarations.</p>

<p>A namespace alias can be used to define alternate names for a namespace.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">namespace</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">namespace</span> <span class="n">B</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">C</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">ABC</span> <span class="o">=</span> <span class="n">A</span><span class="o">::</span><span class="n">B</span><span class="o">::</span><span class="n">C</span><span class="p">;</span>

<span class="n">assert</span><span class="p">(</span><span class="n">ABC</span><span class="o">::</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></figure><h1 id="raw-strings">
<span class="hash">#</span>
<a href="#raw-strings" class="header-link">Raw Strings</a>
</h1>
<p>There are raw string literals. They can contain an optional prefix to disambiguate from the contents.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">R&quot;(the raw string)&quot;</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">R</span><span class="s">&quot;delim(</span>
<span class="n">escape</span> <span class="n">codes</span> <span class="err">\</span><span class="n">n</span> <span class="n">parenthesis</span><span class="p">)</span>
<span class="p">)</span><span class="n">delim</span><span class="s">&quot;;</span>
</code></pre></figure><h1 id="unicode-strings">
<span class="hash">#</span>
<a href="#unicode-strings" class="header-link">Unicode Strings</a>
</h1>
<p>String literal prefixes can be used to specify the string&#39;s encoding and underlying character type.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Prefix</th>
<th style="text-align: left">Type</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>u8</code></td>
<td style="text-align: left"><code>const char[]</code></td>
</tr>
<tr>
<td style="text-align: left"><code>u</code></td>
<td style="text-align: left"><code>const char16_t[]</code></td>
</tr>
<tr>
<td style="text-align: left"><code>U</code></td>
<td style="text-align: left"><code>const char32_t[]</code></td>
</tr>
<tr>
<td style="text-align: left"><code>L</code></td>
<td style="text-align: left"><code>const wchar_t[]</code></td>
</tr>
</tbody>
</table>
<h1 id="static-assertions">
<span class="hash">#</span>
<a href="#static-assertions" class="header-link">Static Assertions</a>
</h1>
<p><code>static_assert</code> is a compile-time assertion. It takes a <code>constexpr</code> that is contextually convertible to <code>bool</code>. An optional string can be displayed if the assertion fails.</p>
<h1 id="attributes">
<span class="hash">#</span>
<a href="#attributes" class="header-link">Attributes</a>
</h1>
<p>Attribute specifiers are a standardization of syntax used for implementation-defined language extensions.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="p">[[</span><span class="n">probably</span><span class="p">(</span><span class="nb">true</span><span class="p">)]]</span> <span class="k">if</span> <span class="p">(</span><span class="n">blah</span><span class="p">)</span>

<span class="p">[[</span><span class="n">omp</span><span class="o">::</span><span class="n">parallel</span><span class="p">()]]</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="err">…</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></figure>
<p>The <code>[[noreturn]]</code> attribute specifies that a function does not return <sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup>, as such it only applies to functions.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="p">[[</span> <span class="n">noreturn</span> <span class="p">]]</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="s">&quot;error&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p>The <code>[[deprecated]]</code> attribute can mark a name or entity as deprecated, with an optional reason via <code>[[deprecated(&quot;reason&quot;]]</code>.</p>

<p>Invalid escape sequences in string literals can be avoided by separating the string literals:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\xfff</span><span class="s">&quot;</span><span class="p">;</span>    <span class="c1">// error</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\xff</span><span class="s">&quot;</span> <span class="s">&quot;f&quot;</span><span class="p">;</span> <span class="c1">// ok</span>
</code></pre></figure>
<p>The <code>alignas</code> specifier can be used to specify the number of bytes between successive addresses at which objects of a given type can be allocated. It can be applied to a type, variable, or member declaration.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="nf">alignas</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="n">sse_t</span> <span class="p">{</span>
  <span class="kt">float</span> <span class="n">sse_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">alignas</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="kt">char</span> <span class="n">cache_line</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
</code></pre></figure>
<p>Class bit fields can be used to specify that a member has a specific size. Unnamed bit fields correspond to unused padding, and more specifically an unnamed bit field of size zero is used to finish the padding so that the next bit field begins at the beginning of its allocation unit.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// total 2 bytes</span>
<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="c1">// byte 1</span>
  <span class="kt">uint8_t</span> <span class="nl">b1</span> <span class="p">:</span> <span class="mi">3</span><span class="p">;</span>
  <span class="nl">uint8_t</span>    <span class="p">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// pad remaining 5 bits</span>

  <span class="c1">// byte 2</span>
  <span class="kt">uint8_t</span> <span class="nl">b2</span> <span class="p">:</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// new byte</span>
  <span class="kt">uint8_t</span> <span class="nl">b3</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></figure><h1 id="source-translation">
<span class="hash">#</span>
<a href="#source-translation" class="header-link">Source Translation</a>
</h1>
<p>The source translation phases of C++ are:</p>

<ol>
<li>source bytes mapped to basic source character set or universal character name \u or \U escaped if not possible</li>
<li>lines ending in backslashes are joined to their next line</li>
<li>source decomposed into comments, whitespace, and preprocessing tokens: header names, identifiers, numbers, character and string literals, operators and punctuators.
each comment is replaced by one space character</li>
<li>preprocessor executed, recursively applying steps 1-4 for each <code>#include</code>
all preprocessor directives removed by the end of this step</li>
<li>convert character and string literals from source character set to execution character set, e.g. UTF-8</li>
<li>adjacent string literals are concatenated</li>
<li>compilation: translation of tokens into translation unit</li>
<li>examine each translation unit to determine required template instantiations, producing instantiation units</li>
<li>translation units, instantiation units, and library components needed to satisfy external references are collected into a program image</li>
</ol>

<p>The relationship between header and source files is that a header should only contain the interface (e.g. class definition). This enables other translation units (source files) to &quot;lightly&quot; include just the header file, knowing that the definition of specific methods will be provided at link-time. On the other hand, the source file includes its associated header at the top and defines its implementation.</p>
<h1 id="volatile">
<span class="hash">#</span>
<a href="#volatile" class="header-link">volatile</a>
</h1>
<p>The <code>volatile</code> keyword can be used to specify that the memory backing a variable may be modified &quot;externally,&quot; such as due to memory-mapped I/O, and it signals to the compiler that it should not perform any optimizations on the variable that may for example elide certain operations.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">volatile</span> <span class="kt">int</span> <span class="n">temp_sensor_reading</span><span class="p">;</span>

<span class="c1">// don&#39;t elide redundant assignments</span>
<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">temp_sensor_reading</span><span class="p">;</span>
<span class="n">process</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>

<span class="n">temp</span> <span class="o">=</span> <span class="n">temp_sensor_reading</span><span class="p">;</span>
<span class="n">process</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
</code></pre></figure><h1 id="performance">
<span class="hash">#</span>
<a href="#performance" class="header-link">Performance</a>
</h1>
<p>As a rule of thumb, different operations can be ranked in terms of their speed <sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup>:</p>

<ol>
<li>comparisons</li>
<li>integer add, subtract, bit operations, shift</li>
<li>floating point add, subtract</li>
<li>indexed array access</li>
<li>integer multiplication</li>
<li>floating point multiplication</li>
<li>floating point division, remainder</li>
<li>integer division, remainder</li>
</ol>
<h1 id="duff39s-device">
<span class="hash">#</span>
<a href="#duff39s-device" class="header-link">Duff&#39;s Device</a>
</h1>
<p>Duff&#39;s Device can be used as a method of loop unrolling. It aims to decrease the number of branches. Instead of performing a check on each iteration, it breaks the iteration into chunks. The key is that it starts by jumping to the middle of the loop to process the non-divisible remainder, then continues the loop for each chunk.</p>

<p>For example, to copy 8-byte chunks to destination:</p>

<ol>
<li>compute number of 8-byte chunks in source memory</li>
<li>create a do-while loop that copies 8-byte chunks per iteration</li>
<li>wrap the loop in a switch statement that switches on the non-divisible remainder</li>
<li>label each individual byte copy statement such that jumping to that label copies that many bytes via fall-through</li>
<li>continue looping for the remaining 8-byte chunks</li>
</ol>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">uint8_t</span> <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">count</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>

<span class="k">switch</span> <span class="p">(</span><span class="n">remainder</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">do</span> <span class="p">{</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="o">++</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">7</span><span class="o">:</span>      <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="o">++</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">6</span><span class="o">:</span>      <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="o">++</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">5</span><span class="o">:</span>      <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="o">++</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">4</span><span class="o">:</span>      <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="o">++</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">3</span><span class="o">:</span>      <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="o">++</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">2</span><span class="o">:</span>      <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="o">++</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>      <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">chunks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p>A <code>switch</code>-based coroutine creates <code>static</code> local variables to hold the coroutine state. A switch statement is used as a jump table to go to the correct behavior for the current state. The disadvantage is that the use of <code>static</code> variables means that the function is not re-entrant or thread-safe. A workaround would be to store the state in an extra argument.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">int</span> <span class="nf">yield_numbers</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">LABEL0</span><span class="p">;</span>
   <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">LABEL1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nl">LABEL0</span><span class="p">:</span> <span class="cm">/* start of function */</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* come back to LABEL1 */</span>
   <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
   <span class="nl">LABEL1</span><span class="p">:;</span> <span class="cm">/* resume control after the return */</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure><h1 id="user-defined-literals">
<span class="hash">#</span>
<a href="#user-defined-literals" class="header-link">User-Defined Literals</a>
</h1>
<p>User-defined literals can easily be created:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">MyType</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">_mytype</span><span class="p">(</span><span class="kt">int</span> <span class="n">literal</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">MyType</span><span class="p">(</span><span class="n">literal</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MyType</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">7</span><span class="n">_mytype</span><span class="p">;</span>

<span class="n">Thing</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">_thing</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">return</span> <span class="n">Thing</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Thing</span> <span class="n">thing</span> <span class="o">=</span> <span class="s">&quot;test&quot;</span><span class="n">_thing</span><span class="p">;</span>

<span class="n">Temp</span> <span class="k">operator</span><span class="s">&quot;&quot;</span> <span class="n">_deg</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">deg</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">return</span> <span class="n">Temp</span><span class="p">(</span><span class="n">deg</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Temp</span> <span class="n">temp</span> <span class="o">=</span> <span class="mf">3.14</span><span class="n">_deg</span><span class="p">;</span>
</code></pre></figure><h1 id="unions">
<span class="hash">#</span>
<a href="#unions" class="header-link">Unions</a>
</h1>
<p>Unions can have member functions.</p>

<p>By default, special member functions are deleted by default, though they can be defined explicitly.</p>

<p>A maximum of one member may have a default member initializer.</p>

<p>A union&#39;s default member access is public.</p>

<p>A union&#39;s size is as big as necessary to hold the largest member.</p>

<p>If a union member has a user-defined constructor and destructor, switching to another member requires its explicit destruction and placement new of the new member.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">union</span> <span class="n">S</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
  <span class="o">~</span><span class="n">S</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="n">S</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;test&quot;</span><span class="p">};</span>
<span class="n">s</span><span class="p">.</span><span class="n">str</span><span class="p">.</span><span class="o">~</span><span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">();</span>   <span class="c1">// explicit destruction</span>
<span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">.</span><span class="n">vec</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// explicit placement new</span>
<span class="n">s</span><span class="p">.</span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">s</span><span class="p">.</span><span class="n">vec</span><span class="p">.</span><span class="o">~</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></figure>
<p>Anonymous unions can&#39;t have:</p>

<ul>
<li>member functions</li>
<li>static data members</li>
<li>non-public members</li>
</ul>

<p>The members of anonymous unions are injected into the enclosing scope, and only the maximum of their sizes is allocated for them all.</p>

<p>A union can&#39;t:</p>

<ul>
<li>have base classes</li>
<li>have reference members</li>
<li>have virtual functions</li>
<li>be used as a base class</li>
</ul>

<p>A union-like class is any class with at least one anonymous union as a member. All of the anonymous union members are called its variant members.</p>
<h1 id="linkage">
<span class="hash">#</span>
<a href="#linkage" class="header-link">Linkage</a>
</h1>
<p>A name with <em>internal linkage</em> can only be referred to from all scopes in the <em>current</em> translation unit. Items with internal linkage include:</p>

<ul>
<li><code>static</code> variables, functions, function templates</li>
<li><code>const</code> and <code>constexpr</code> variables that aren&#39;t declared <code>extern</code></li>
<li>members of an anonymous union</li>
<li>names declared in unnamed namespaces</li>
</ul>

<p>A name with <em>no linkage</em> can only be referred to from the scope it is in. Items with no linkage include:</p>

<ul>
<li>variables that aren&#39;t declared <code>extern</code></li>
<li>local classes and their member functions</li>
<li>other names declared at block scope</li>
</ul>

<p>A name with <em>external linkage</em> can be referred to from scopes in <em>other</em> translation units. Items with external linkage include:</p>

<ul>
<li><code>namespace</code>-scope non-<code>const</code> variables not declared <code>static</code></li>
<li>functions not declared <code>static</code></li>
<li>any variables declared <code>extern</code></li>
<li>enumerations and enumerators</li>
<li>names of classes, their member functions, <code>static</code> members, nested classes and enumerations, functions first introduced with friend declarations inside class bodies</li>
<li>names of function templates not declared <code>static</code></li>
</ul>
<h1 id="elaborated-type-specifier">
<span class="hash">#</span>
<a href="#elaborated-type-specifier" class="header-link">Elaborated Type Specifier</a>
</h1>
<p>The <em>elaborated type specifier</em> syntax is used to disambiguate a type name from a non-type declaration. It works with <code>class</code>, <code>struct</code>, <code>union</code>, and <code>enum</code>. If the type isn&#39;t found, it&#39;s created as a <em>forward declaration</em>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">T</span> <span class="p">{};</span>
<span class="kt">int</span> <span class="n">T</span><span class="p">;</span>

<span class="c1">// disambiguate the class/type from the integer</span>
<span class="k">class</span> <span class="nc">T</span> <span class="n">t</span><span class="p">;</span>
</code></pre></figure><h1 id="standard-template-library">
<span class="hash">#</span>
<a href="#standard-template-library" class="header-link">Standard Template Library</a>
</h1><h2 id="initializer-lists">
<span class="hash">#</span>
<a href="#initializer-lists" class="header-link">Initializer Lists</a>
</h2>
<p>The <code>std::initializer_list</code> type is a lightweight proxy object wrapping an array of objects of type <code>const T</code>. For this reason, it&#39;s normal and expected to pass it around by-value, since it&#39;s already essentially a pointer to the underlying array.</p>
<h2 id="integral_constant">
<span class="hash">#</span>
<a href="#integral_constant" class="header-link">integral_constant</a>
</h2>
<p>The <code>std::integral_constant&lt;T, T v&gt;</code> type from <code>type_traits</code> takes an integral type and a constant value for it. Two typedefs for these exist which are <code>true_type</code> (i.e. <code>std::integral_constant&lt;bool, true&gt;</code>) and <code>false_type</code>. That can be used to refine the selection of a function overload.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// integrals</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo_impl</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">,</span> <span class="n">true_type</span><span class="p">);</span>

<span class="c1">// floats</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo_impl</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">,</span> <span class="n">false_type</span><span class="p">);</span>

<span class="c1">// Use is_integral to select the appropriate overload.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">foo_impl</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></figure><h2 id="array">
<span class="hash">#</span>
<a href="#array" class="header-link">Array</a>
</h2>
<p>The <code>std::array&lt;N, T&gt;</code> type is a wrapper around regular <code>T[N]</code> arrays. It provides typical STL collection functionality such as iterators and copy and assignment operators. It has no user-provided constructors, no base classes, no virtual member functions, no default member initializers, and only contains a regular public array. This means that <code>std::array</code> is an aggregate type, which allows it to be initialized like a regular array, via aggregate-initialization:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
</code></pre></figure><h2 id="pairs">
<span class="hash">#</span>
<a href="#pairs" class="header-link">Pairs</a>
</h2>
<p>An <code>std::pair</code> is essentially a tuple with two components, accessible via members <code>first</code> and <code>second</code>. It is used to denote, for example, key-value pairs in maps.</p>

<p>Pairs can be constructed using list-initialization when the type can be inferred or explicitly with the helper free-function <code>std:make_pair</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">auto</span> <span class="n">keyval</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="s">&quot;test&quot;</span><span class="p">);</span>
</code></pre></figure>
<p>When emplacing a new key-value pair into a map, it can become ambiguous as to which parameters correspond to which constructor: either the key&#39;s or the value&#39;s.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&gt;</span> <span class="n">map</span><span class="p">;</span>

<span class="c1">// &quot;key&quot; should be the parameter for the string constructor</span>
<span class="c1">// 3.4, 7.8 should be the parameters for the complex constructor</span>
<span class="n">map</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="s">&quot;key&quot;</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">,</span> <span class="mf">7.8</span><span class="p">);</span>
</code></pre></figure>
<p>To disambiguate these situations, there is <code>std::piecewise_construct</code> which can forward the respective pair components as a tuple:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">map</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
            <span class="c1">// used to construct the first pair component</span>
            <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="s">&quot;key&quot;</span><span class="p">),</span>
            <span class="c1">// used to construct the second pair component</span>
            <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="mf">3.4</span><span class="p">,</span> <span class="mf">7.8</span><span class="p">));</span>
</code></pre></figure><h2 id="tuples">
<span class="hash">#</span>
<a href="#tuples" class="header-link">Tuples</a>
</h2>
<p>The <code>std::tuple</code> type is similar to tuples in other languages. <code>get&lt;index&gt;(tuple)</code> retrieves the value at a given index. Tuples can easily be created with the <code>make_tuple</code> function.</p>

<p>Note that tuples cannot be copy-list-initialized because the corresponding constructor is marked explicit in order to prevent a single value from being implicitly converted to a tuple.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">wrong</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">};</span> <span class="c1">// error</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">correct</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">};</span>  <span class="c1">// ok</span>
</code></pre></figure>
<p>As in other languages, tuples can be &quot;unpacked&quot; into multiple values using the <code>tie</code> function:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">tie</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ignore</span><span class="p">,</span> <span class="n">letter</span><span class="p">)</span> <span class="o">=</span> <span class="n">make_tuple</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">4.23</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>std::tie</code> function works by essentially creating an ephemeral tuple of references and copy-assigning the source tuple to the ephemeral tuple, causing those values to be set via reference.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">source</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;test&quot;</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">first</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">second</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">first</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">second</span><span class="p">))</span> <span class="o">=</span> <span class="n">source</span><span class="p">;</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="n">second</span><span class="p">);</span>
</code></pre></figure>
<p>Tuples implement comparison operators to perform lexicographical comparisons, this makes it possible to use <code>tie</code> to perform lexicographical comparisons of multiple fields:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">Record</span> <span class="p">{</span>
 <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">floor</span><span class="p">;</span>
 <span class="kt">double</span> <span class="n">weight</span><span class="p">;</span>

 <span class="c1">// First compare names to each other, and if equal, then floor, finally weight.</span>
 <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Record</span><span class="o">&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">Record</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">l</span><span class="p">.</span><span class="n">floor</span><span class="p">,</span> <span class="n">l</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span>
       <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">floor</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
 <span class="p">}</span>
<span class="p">};</span>
</code></pre></figure>
<p>If a class defines a constructor that takes an <code>std::initializer_list</code> then that constructor takes precedence when using initializer list construction. Initializer lists cause an error if a construction would narrow a type.</p>
<h2 id="unordered-containers">
<span class="hash">#</span>
<a href="#unordered-containers" class="header-link">Unordered Containers</a>
</h2>
<p>Custom hashers and key-equality functions can be used on a given unordered container.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="n">hash_func</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="n">equality</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span>
              <span class="k">decltype</span><span class="p">(</span><span class="n">hash_func</span><span class="p">),</span>
              <span class="k">decltype</span><span class="p">(</span><span class="n">equality</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">(</span><span class="n">S</span><span class="p">{</span><span class="mi">10</span><span class="p">},</span> <span class="n">hash_func</span><span class="p">,</span> <span class="n">equality</span><span class="p">);</span>
</code></pre></figure>
<p>Note that mismatching the type of the pairs can lead to inefficiency. For example, if the <code>const</code>-qualifier of the key type is missing, it can lead to a temporary being created and then converted to the appropriate type:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="nl">pair</span> <span class="p">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></figure>
<p>This can result in the following on each iteration:</p>

<ol>
<li>create temporary of type of <code>pair</code></li>
<li>convert <code>m</code> pair to the type of the temporary (i.e. sans key <code>const</code>)</li>
<li>bind <code>pair</code> to that temporary</li>
<li>destroy the temporary</li>
</ol>

<p>This is contrary to what the user may expect when iterating by reference.</p>

<p>To avoid possibly introducing these type mismatches and consequent performance penalties, it&#39;s safer and easier to just use <code>auto</code> type deduction:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">pair</span> <span class="p">:</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
</code></pre></figure><h2 id="bitsets">
<span class="hash">#</span>
<a href="#bitsets" class="header-link">Bitsets</a>
</h2>
<p>Bitsets can be instantiated from an integer source or a string. They are parameterized by their capacity, i.e. they are not dynamic: their capacity must be stated up-front. For a dynamic bitset there exists an <code>std::vector&lt;bool&gt;</code> specialization.</p>

<p>The indexing operator <code>operator[]</code> is overloaded to test a bit, and there is also a method <code>test</code> to do the same.</p>

<p>There are <code>all</code>, <code>any</code>, and <code>none</code> methods, as well as <code>count</code> to see how many bits are set.</p>

<p>Bits can be turned on (set) via the index <code>operator[]</code> or via the <code>set</code> method, which can set all bits if no parameters are given, a specific bit, or can set a specific bit to an explicit value. The <code>reset</code> method does the opposite, turning off bits. The <code>flip</code> method negates bits.</p>
<h2 id="strings">
<span class="hash">#</span>
<a href="#strings" class="header-link">Strings</a>
</h2>
<p>A constructor overload exists for creating a string consisting of a certain number of a single character.</p>

<p>Arbitrary strings or characters can be inserted anywhere into the string via the <code>insert</code> method, likewise they can be removed with <code>erase</code>.</p>

<p>Strings can be appended to via <code>push_back</code> (there&#39;s also <code>pop_back</code>) or <code>append</code> and <code>operator+=</code>, but an <code>std::stringstream</code> is preferred if there&#39;s going to be many append calls.</p>

<p>The <code>substr</code> function takes a starting position and a <em>count</em>, not one-past last, but a <em>count</em>, and returns the substring denoted by the range [begin, begin + count].</p>

<p>The <code>replace</code> function can replace a given range in the string with another string.</p>

<p>The <code>find</code> method searches for the occurrence of a needle in the string, optionally starting from a given position, and returns the starting position of the first match, or <code>std::string::npos</code> if there was none.</p>

<p>There is also <code>rfind</code> which does the same but starting from the right of the string.</p>

<p>The <code>find_first_of</code> method is like the algorithm of the same name: it looks for the first occurrence of one of the characters in the input string. There is also <code>find_first_not_of</code>, as well as <code>find_last_of</code> and <code>find_last_not_of</code> which search from right-to-left.</p>
<h2 id="numeric-limits">
<span class="hash">#</span>
<a href="#numeric-limits" class="header-link">Numeric Limits</a>
</h2>
<p>The <code>limits</code> header contains numeric limits, such as <code>std::numeric_limits&lt;int&gt;::max()</code> for the largest representable number with the <code>int</code> type.</p>
<h2 id="smart-pointers">
<span class="hash">#</span>
<a href="#smart-pointers" class="header-link">Smart Pointers</a>
</h2>
<p>Both <code>unique_ptr</code> and <code>shared_ptr</code> are explicit (or contextually, i.e. in an if-condition) convertible operators to <code>bool</code>, denoting whether the managed pointer is <code>nullptr</code> or not.</p>
<h3 id="unique_ptr">
<span class="hash">#</span>
<a href="#unique_ptr" class="header-link">unique_ptr</a>
</h3>
<p>A <code>unique_ptr</code> can relinquish ownership of the managed object with the <code>release</code> method.</p>

<p>One <code>unique_ptr</code> can transfer ownership to another <code>unique_ptr</code> via move construction or assignment.</p>
<h3 id="shared_ptr">
<span class="hash">#</span>
<a href="#shared_ptr" class="header-link">shared_ptr</a>
</h3>
<p>Each <code>shared_ptr</code> has an associated <em>control block</em> which consists of:</p>

<ul>
<li>managed object or a pointer to it</li>
<li>reference count</li>
<li>weak reference count</li>
<li>type-erased deleter</li>
<li>type-erased allocator</li>
</ul>

<p>Depending on the way a <code>shared_ptr</code> is constructed, there can be a potential for memory leaks. Imaging the following code:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">processWidget</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">),</span> <span class="n">dangerous</span><span class="p">());</span>
</code></pre></figure>
<p>The compiler can generate the above code as:</p>

<ol>
<li>allocate <code>Widget</code></li>
<li>call <code>dangerous</code></li>
<li>construct <code>shared_ptr</code> from <code>Widget</code></li>
</ol>

<p>This can be a problem if the call to <code>dangerous</code> in step 2 throws an exception, because the <code>shared_ptr</code> didn&#39;t have a chance to take ownership of the <code>Widget</code>. If it had taken ownership, the exception would&#39;ve destroyed the <code>shared_ptr</code> which also would&#39;ve deallocated <code>Widget</code>. Otherwise the memory leaks.</p>

<p>For this reason, it&#39;s preferable to use <code>std::make_shared</code> to construct <code>shared_ptr</code>s. It&#39;s also faster because it is usually able to perform a single allocation for both the managed object and the <code>shared_ptr</code>&#39;s control block, whereas when the managed object is explicitly allocated, the <code>shared_ptr</code> has no choice but to perform another allocation for the control block.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">processWidget</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">dangerous</span><span class="p">());</span>
</code></pre></figure>
<p>This way, the compiler now has two things that it may rearrange:</p>

<ul>
<li>call <code>make_shared</code></li>
<li>call <code>dangerous</code></li>
</ul>

<p>Regardless of their arrangement, there is no possibility for memory leaks.</p>

<p>However, the use of <code>std::make_shared</code> prevents specifying a custom deleter. For that, the regular constructor is necessary:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">c_type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new_c_type</span><span class="p">(),</span> <span class="n">free_c_type</span><span class="p">);</span>
</code></pre></figure>
<p>A <code>shared_ptr</code> can change the object it manages by calling its <code>reset</code> method with a pointer to the new object to manage. If the <code>shared_ptr</code> was the last owner of the previously managed object, its deleter is called.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">thing</span><span class="p">;</span>
<span class="n">thing</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;other&quot;</span><span class="p">));</span>
</code></pre></figure>
<p>The raw pointer that a <code>shared_ptr</code> manages can be accessed without relinquishing ownership via the <code>get</code> method.</p>

<p>The &quot;alias constructor&quot; of <code>shared_ptr</code> is one that accepts a raw pointer to manage and whose lifetime is tied to another <code>shared_ptr</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">struct</span> <span class="n">X</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="n">px</span><span class="p">(</span><span class="k">new</span> <span class="n">X</span><span class="p">);</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="n">pi</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">px</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">);</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">px</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">);</span>
</code></pre></figure>
<p>There are casting functions equivalent to <code>static_cast</code> et al which operate on <code>shared_ptr</code>:</p>

<ul>
<li><code>static_pointer_cast</code></li>
<li><code>dynamic_pointer_cast</code></li>
<li><code>const_pointer_cast</code></li>
</ul>

<p>Sometimes it&#39;s necessary to be able to create a type which should be able to give <code>shared_ptr</code>s of itself (i.e. of its <code>this</code> pointer) to other types.</p>

<p>For example, this can be useful or even necessary when creating a tree where the nodes have pointers to their parents. If the children are wrapped in <code>shared_ptr</code>, then the parent pointers must also be <code>shared_ptr</code> so that all paths from which the pointers may be referenced go through a <code>shared_ptr</code>. However, this poses a problem because it would entail giving a child a copy of the parent&#39;s <code>this</code> pointer for it to store in its <code>shared_ptr</code> of its parent. What&#39;s really needed is a <code>shared_ptr</code> of the <code>this</code> pointer.</p>

<p>This can be achieved by having the class derive from <code>std::enable_shared_from_this&lt;T&gt;</code>, where <code>T</code> is the type in question. This inherits a method <code>shared_from_this</code> which returns a <code>shared_ptr</code> of the <code>this</code> pointer.</p>

<p>However, something has to have created a <code>shared_ptr</code> of the <code>this</code> pointer, i.e. of the class. For this reason, there is usually a factory method which constructs <code>shared_ptr</code>s of the class.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">class</span> <span class="nc">Widget</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></figure>
<p>To prevent reference-cycles, the <code>std::weak_ptr</code> represents a pointer that can share but not own a resource. In order to be used, it must first attempt to elevate itself to a <code>shared_ptr</code> via the <code>lock</code> method.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Thing</span><span class="o">&gt;</span> <span class="n">shared</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Thing</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Thing</span><span class="o">&gt;</span> <span class="n">weak</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Thing</span><span class="o">&gt;</span> <span class="n">locked</span> <span class="o">=</span> <span class="n">weak</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="p">{</span>
  <span class="c1">// object still exists</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// object no longer exists</span>
<span class="p">}</span>
</code></pre></figure><h2 id="callables">
<span class="hash">#</span>
<a href="#callables" class="header-link">Callables</a>
</h2>
<p>The type <code>std::function</code> can store a type-erased pointer to any callable: function, lambda, bind expression, function object, pointer to member function, pointer to data member.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">print_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">display_int</span> <span class="o">=</span> <span class="n">print_int</span><span class="p">;</span>

<span class="n">print_int</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
</code></pre></figure>
<p>If the callable is a member function, then the target object must be explicitly passed when invoked.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">const</span> <span class="n">Class</span> <span class="n">obj</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span> <span class="n">Class</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">print_num</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Class</span><span class="o">::</span><span class="n">show_num</span><span class="p">;</span>

<span class="n">print_num</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>std::bind</code> function can wrap a function with certain parameters pre-bound. Parameters that aren&#39;t intended to be bound must pass-through using a placeholder in <code>std::placeholders</code>. It&#39;s much easier and less error-prone to use lambdas. For example, arguments to the <code>bind</code> call are copied or moved unless explicitly placed in a reference wrapper such as <code>std::ref</code> or <code>std::cref</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// func(8, 4, 2) == 8</span>

<span class="c1">// pre-bind first and second parameter to 0 and 1</span>
<span class="k">auto</span> <span class="n">reverse_params</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_3</span><span class="p">);</span>

<span class="c1">// func(8, 4, 2) == -2</span>
</code></pre></figure>
<p>The <code>functional</code> header contains a variety of function objects for primitive operations, such as <code>std::plus&lt;T&gt;</code> which is a function object for <code>operator+(T a, T b)</code>.</p>

<p>There are also <code>std::not1</code> and <code>std::not2</code> functions which negate the result of a unary or binary predicate, respectively.</p>
<h2 id="iterators">
<span class="hash">#</span>
<a href="#iterators" class="header-link">Iterators</a>
</h2>
<p>The free-functions <code>std::begin</code> and <code>std::end</code> are specialized to return the respective iterators for different types. For example, usually one would just use the methods of the same name on actual collection objects. However, regular arrays don&#39;t have methods, and so these free-functions have specializations to do the correct thing for arrays.</p>

<p>Additionally, if the parameters are const-qualified, they return constant iterators, like the equivalent <code>cbegin</code> and <code>cend</code> methods.</p>

<p>The <code>distance</code> function can be used to get the number of elements between first and last.</p>

<p>The <code>next</code> and <code>prev</code> function returns a new iterator that is advanced forward or backward respectively by a given number of steps, or a single step by default.</p>

<p>The <code>advance</code> function is similar but it modifies the passed iterator, and it can take a signed integer so that a negative step steps backward.</p>

<p>The functions <code>std::back_inserter</code> and <code>std::front_inserter</code> take a collection and return iterator adapters whose assignment operator automatically calls <code>push_back</code> or <code>push_front</code> on the collection.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">expect</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">fill_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expect</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</code></pre></figure>
<p>Function <code>std::inserter</code> is a generalization of the above functions. It takes a collection and an iterator position. Assigning to the iterator (dereferenced or not) calls the corresponding <code>insert</code> method at that position.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">expect</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">fill_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">inserter</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">())),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expect</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>std::make_reverse_iterator</code> function returns an iterator adapter that reverses the direction of the iterator. However, with C++14 and above it&#39;s simpler to call the <code>rbegin</code> and <code>rend</code> methods.</p>

<p>The <code>std::make_move_iterator</code> function returns an iterator adapter that overloads its deference operator to convert the returned value into an rvalue, allowing the underlying value to be moved from. Note that there is also an algorithm <code>std::move</code> that can be used.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">{</span><span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="s">&quot;two&quot;</span><span class="p">,</span> <span class="s">&quot;three&quot;</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()),</span>
                           <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s_expect</span><span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v_expect</span><span class="p">{</span><span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="s">&quot;two&quot;</span><span class="p">,</span> <span class="s">&quot;three&quot;</span><span class="p">};</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">s_expect</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">v_expect</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>std::ostream_iterator</code> and <code>std::istream_iterator</code> iterator types are iterators which write to an <code>ostream</code> or read from an <code>istream</code>, respectively. These can be used, for example, to read a sequence of delimited numbers from standard input, or write a sequence of numbers to standard output. In the case of <code>std::istream_iterator</code>, the end-point iterator can be constructed by passing no parameters.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// Read the input stream into a vector.</span>
<span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">input</span><span class="p">(</span><span class="s">&quot;1 2 3 4 5&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">,</span> <span class="n">v_expect</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span>
  <span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">),</span>
  <span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span>
  <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="p">);</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">v_expect</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

<span class="c1">// Write the vector to an output stream (could be std::cout)</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">output</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
          <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">));</span>

<span class="c1">// Note trailing space.</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="s">&quot;1 2 3 4 5 &quot;</span><span class="p">,</span> <span class="n">output</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
</code></pre></figure><h2 id="collection-exception-safety">
<span class="hash">#</span>
<a href="#collection-exception-safety" class="header-link">Collection Exception-Safety</a>
</h2>
<p>Most functions and collections which are able to perform moves only do so if the moves are <code>noexcept</code>, otherwise copies are performed.</p>
<h2 id="algorithms">
<span class="hash">#</span>
<a href="#algorithms" class="header-link">Algorithms</a>
</h2>
<p>There are a couple of conventions that STL algorithms follow:</p>

<ul>
<li><p>most algorithms take at least one iterator range specifying the range of operation, where the range is exclusive on its end-point, i.e. [begin, end).</p>

<p>Some algorithms take two ranges, and sometimes the end-point of the second can be omitted, which automatically assumes the same distance as the first range.</p></li>
<li><p>algorithms whose names end in <code>_n</code> take a beginning iterator position and a count of elements to affect from that point onward, instead of the regular [begin, end) iterator range.</p></li>
<li><p>algorithms whose names end in <code>_if</code> take a predicate instead of a value to compare against.</p></li>
<li><p>algorithms whose names end in <code>_until</code> return an iterator to one-past the last &quot;qualifying&quot; element. For example, <code>is_sorted_until</code> returns one-past the last sorted element.</p></li>
<li><p>algorithms whose names end in <code>_backward</code> perform their operation from right-to-left. For example,  <code>copy_backward</code> copies the last source element to the last destination iterator position, then the penultimate, etc. <em>Don&#39;t</em> confuse this with the operation being performed in reverse. The elements are still in the same order; they were simply copied from right-to-left.</p></li>
<li><p>algorithms whose names contain <code>_copy</code> perform their operation to elements as they are being copied into another range. Conversely, their counterparts which <em>don&#39;t</em> have <code>_copy</code> in their name operate in-place, modifying the elements of the range.</p></li>
<li><p>algorithms that take a comparison function expect a function which returns <code>true</code> if the first parameter is <em>less</em> than the second, and <code>false</code> otherwise. Comparison functions must not modify the parameters.</p>

<p>Equality can be checked with such a comparison function by ensuring that it doesn&#39;t yield true for either one with respect to the other, i.e. a and b are equal if <code>!cmp(a, b) &amp;&amp; !cmp(b, a)</code>, e.g. if <code>!(a &lt; b) &amp;&amp; !(b &lt; a)</code>.</p></li>
<li><p>algorithms that concern &quot;order&quot; or &quot;equality&quot; accept an optional comparison function</p></li>
<li><p>algorithms usually return one-past the last element that was operated on.</p></li>
</ul>

<p>The <code>exchange</code> function replaces the value of an object with that of another and returns the old value.</p>

<p>The <code>swap</code> function swaps two parameters with each other. It&#39;s also overloaded for arrays. It&#39;s important to note that it should usually be called in an unqualified manner. That is, use a using-declaration to bring the <code>std::swap</code> definitions into scope, but call it as <code>swap</code> and not <code>std::swap</code>. This enables additional, perhaps more specialized overloads of <code>swap</code> to be used when appropriate.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">Function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure><h3 id="testing">
<span class="hash">#</span>
<a href="#testing" class="header-link">Testing</a>
</h3>
<p>The <code>all_of</code>, <code>any_of</code>, and <code>none_of</code> functions specify whether the elements of a given iterator range satisfy the given predicate for all, any, or none of the elements respectively.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>

<span class="kt">bool</span> <span class="n">all_even</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">});</span>

<span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">all_even</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>equal</code> function checks if two iterator ranges are equivalent by equality or predicate.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;radar&quot;</span><span class="p">;</span>

<span class="c1">// Compare forward range to backward range</span>
<span class="kt">bool</span> <span class="n">is_palindrome</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                                <span class="n">s</span><span class="p">.</span><span class="n">rbegin</span><span class="p">());</span>

<span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">is_palindrome</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>lexicographical_compare</code> function checks to see if the first range is lexicographically less than the second range.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="n">b</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">lexicographical_compare</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                             <span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="c1">// a &lt; b = true</span>
</code></pre></figure>
<p>The <code>includes</code> function checks if every element of the second sorted range is found within the first sorted range, reads as &quot;first range includes second.&quot;</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span> <span class="n">b</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>

<span class="c1">// true</span>
<span class="n">std</span><span class="o">::</span><span class="n">includes</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="c1">// true</span>
<span class="n">std</span><span class="o">::</span><span class="n">includes</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</code></pre></figure><h3 id="searching">
<span class="hash">#</span>
<a href="#searching" class="header-link">Searching</a>
</h3>
<p>The <code>mismatch</code> function takes two iterator ranges and finds and returns the first mismatching positions as determined by equality or a given predicate.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>

<span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">mismatch</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;*</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">*</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="p">));</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">*</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">second</span><span class="p">));</span>
</code></pre></figure>
<p>The <code>find</code> function gets the iterator position of the first element equal to the given value, whereas the <code>find_if</code> and <code>find_if_not</code> functions find the first element that does or does not satisfy the given predicate, respectively.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="k">auto</span> <span class="n">two_position</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">even_position</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                                  <span class="p">[](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                                    <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
                                  <span class="p">});</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;*</span><span class="n">two_position</span><span class="p">);</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;*</span><span class="n">even_position</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>find_end</code> function gets the iterator position of beginning of the last occurrence of the subsequence denoted by the second iterator range within the sequence denoted by the first iterator range.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">needle</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_end</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">seq</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">seq</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">&amp;*</span><span class="n">pos</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>find_first_of</code> function gets the iterator position of the first element found that&#39;s one of the elements in the second range.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">els</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>

<span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_first_of</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">els</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">els</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;*</span><span class="n">pos</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>adjacent_find</code> method finds the position of the first two consecutive elements that are equal to each other or both satisfy a predicate.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>

<span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">adjacent_find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">&amp;*</span><span class="n">pos</span><span class="p">);</span>

<span class="c1">// If it&#39;s sorted, each pair should satisfy std::less&lt;int&gt;()(left, right)</span>
<span class="c1">// Conversely, if any pair satisfies std::greater&lt;int&gt;(left, right), then</span>
<span class="c1">// that is the first pair of elements that is unsorted.</span>
<span class="k">auto</span> <span class="n">unsorted</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">adjacent_find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="o">&amp;*</span><span class="n">pos</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>search</code> function finds the second range within the first range using equality or a given predicate.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;one two three&quot;</span><span class="p">;</span>
<span class="n">string</span> <span class="n">needle</span> <span class="o">=</span> <span class="s">&quot;two&quot;</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">search</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">needle</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">needle</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">&amp;*</span><span class="n">pos</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>search_n</code> function finds the a sequence of <code>n</code> elements of <code>value</code>, e.g. three 4&#39;s, within the first range using equality or a given predicate.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>

<span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">search_n</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;*</span><span class="n">pos</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>max_element</code> and <code>min_element</code> find the position of the largest or smallest element in the range, respectively. A comparison function can be passed.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>

<span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min_element</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>minmax_element</code> function simultaneously finds the smallest and largest element in the range.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>

<span class="k">auto</span> <span class="n">min_max</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">min_max</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="o">*</span><span class="n">min_max</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
</code></pre></figure>
<p>There is also a <code>minmax</code> function which operates on two operands or an initializer list. This can be used to simultaneously find the lesser and greater of two numbers, such as for randomly setting some bounds:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">srand</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
                                         <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</code></pre></figure>
<p>The <code>nth_element</code> function selects the <script type="math/tex">n^\text {th}</script> element from the sorted order of the range, i.e. the <script type="math/tex">n^\text {th}</script>-order statistic. A comparison function can be specified.</p>

<p>This is like Quicksort&#39;s partitioning, so the range is modified so that the element pointed to by <code>nth</code> becomes the <code>nth</code> element of the sorted order of the range. All elements to the left of the iterator are less than or equal to that element and all elements to the right of the iterator are greater than that element.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">mid</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="c1">// median is v[mid] = 5</span>

<span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="c1">// max is v.back()</span>
</code></pre></figure>
<p>The <code>lower_bound</code> function returns an iterator to the first element in the partially or fully sorted range that is greater than or equal to the value or comparison function. There is also an <code>upper_bound</code> function.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>

<span class="k">auto</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>

<span class="c1">// lower = idx 3</span>
</code></pre></figure>
<p>The <code>equal_range</code> function returns an iterator range (pair) of the sub-range of elements in the input range that contains values equivalent to the provided value based on an optional comparison function.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>

<span class="k">auto</span> <span class="n">range</span> <span class="o">=</span> <span class="n">equal_range</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>

<span class="kt">bool</span> <span class="n">all_twos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">second</span><span class="p">,</span>
                            <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span> <span class="p">});</span>

<span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">all_twos</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>binary_search</code> function does a membership check by performing a binary search for the value in the partially or fully sorted range using an optional comparison function.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>

<span class="kt">bool</span> <span class="n">found_four</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">binary_search</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
</code></pre></figure><h3 id="reducing">
<span class="hash">#</span>
<a href="#reducing" class="header-link">Reducing</a>
</h3>
<p>The <code>count</code> function counts all elements in the range which equals a given value, whereas <code>count_if</code> counts those which satisfy a given predicate.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="kt">int</span> <span class="n">twos</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">odds</span> <span class="o">=</span> <span class="n">count_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                    <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">twos</span><span class="p">);</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">odds</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>accumulate</code> function reduces the elements in the range given an initial value and an optional binary function which produces the reduction of two elements. By default, the binary function is addition, so <code>accumulate</code> produces the sum of the elements.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>

<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// sum = 15</span>

<span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="p">[](</span><span class="kt">int</span> <span class="n">prod</span><span class="p">,</span> <span class="kt">int</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
                                <span class="k">return</span> <span class="n">prod</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>
                              <span class="p">});</span>
<span class="c1">// product = 120</span>

<span class="c1">// can also be</span>
<span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">multiplies</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
</code></pre></figure>
<p>The <code>inner_product</code> function computes the sum of the pair-wise products of the elements of the two ranges, which is the <em>dot product</em>. Custom sum and product functions can be provided, in which case the &quot;product&quot; function is applied in a pair-wise manner to the elements of the two ranges, and the &quot;sum&quot; function is applied to those results.</p>

<p>This is like an <code>transform</code>/<code>for_each</code> of pair-wise elements with the &quot;product&quot; function and an <code>accumulate</code> of those results with the &quot;sum&quot; function.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>

<span class="kt">int</span> <span class="n">dot_product</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">inner_product</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// dot_product = 21</span>
</code></pre></figure>
<p>The <code>adjacent_difference</code> function computes the difference of each element in the range and its predecessor, writing each element into the output iterator. Since the first element doesn&#39;t have a predecessor, the predecessor is treated as 0.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>

<span class="c1">// v = {2, 2, 2, 2};</span>
<span class="n">std</span><span class="o">::</span><span class="n">adjacent_difference</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

<span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>

<span class="c1">// v = {1, 1, 2, 3}</span>
<span class="p">.</span><span class="n">adjacent_difference</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">});</span>
</code></pre></figure>
<p>The <code>partial_sum</code> function successively computes the sums of increasing sub-ranges of the input range and copies each sum into the output iterator. A custom sum function can be provided. Specifically, the result is such that:</p>

<p><script type="math/tex; mode=display"> \text {dest}[i] = \sum_0^i \text {src}[i] </script></p>

<p>This can be useful for example to compute the <a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem">maximal sub-array</a>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dest</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">partial_sum</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">dest</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dest</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;sum of sub-range [0, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;] = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">dest</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// dest = {2, 4, 6, 8}</span>
</code></pre></figure>
<p>The <code>transform</code> function applies a given unary function to each element in the array, or a given binary function to each pair of elements in two ranges, and writes each result to the output iterator. The given function must not modify the elements or invalidate iterators.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="o">::</span><span class="n">toupper</span><span class="p">);</span>

<span class="c1">// s = &quot;HELLO&quot;</span>
</code></pre></figure><h3 id="mutating">
<span class="hash">#</span>
<a href="#mutating" class="header-link">Mutating</a>
</h3>
<p>The <code>for_each</code> function applies a function to each element in the range, potentially mutating the element. It returns the provided function object, allowing for the accumulation of a result.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">expect</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="o">++</span><span class="n">n</span><span class="p">;</span> <span class="p">});</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expect</span><span class="p">,</span> <span class="n">vec</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>iota</code> function can be used to fill a range with sequentially incremented values, starting with the given value.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

<span class="n">EXPECT_EQ</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">v</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>swap_ranges</code> function swaps elements from the first range with the corresponding elements of the second range, and returns one-past the last swapped element of the <em>second</em> range.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>

<span class="c1">// Swap the first two elements of v with first two elements of l</span>
<span class="n">std</span><span class="o">::</span><span class="n">swap_ranges</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

<span class="n">EXPECT_EQ</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">v</span><span class="p">);</span>
<span class="n">EXPECT_EQ</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span> <span class="n">l</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>fill</code> function sets every element in the range to a given value. There is also <code>fill_n</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">7</span><span class="p">);</span>

<span class="n">EXPECT_E1</span><span class="p">({</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span> <span class="n">v</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>generate</code> function assigns each element in the range the value generated by the provided function, which takes no arguments. There is also <code>generate_n</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">n</span><span class="p">]()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span><span class="o">++</span><span class="p">;</span> <span class="p">});</span>

<span class="n">EXPECT_EQ</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">v</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>replace</code> function replaces the elements in the range that match the given value or satisfy the predicate (with <code>replace_if</code>) with another value. There&#39;s also <code>replace_copy</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="c1">// Replace even numbers with 0.</span>
<span class="n">std</span><span class="o">::</span><span class="n">replace_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">},</span>
                <span class="mi">0</span><span class="p">);</span>

<span class="n">EXPECT_EQ</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">v</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>reverse</code> function reverses the order of the elements in the range. There&#39;s also <code>reverse_copy</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">EXPECT_EQ</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="n">v</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>rotate</code> function rotates all elements in the range to the left such that the middle parameter becomes the first element in the range. Note that this function breaks convention in that there is a parameter (the &quot;new-left&quot;) in between the [begin, end) iterator pair parameters. As per convention, <code>rotate_copy</code> does the same but copies the result into another range.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>

<span class="c1">// Rotate v to the left so that the 3 (v[2]) become the first element.</span>
<span class="n">std</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">EXPECT_EQ</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="n">v</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>random_shuffle</code> function shuffles all elements in the range given a random number generator.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
<span class="n">mt19937</span> <span class="nf">g</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>

<span class="n">std</span><span class="o">::</span><span class="n">shuffle</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">g</span><span class="p">);</span>

<span class="c1">// e.g. v = {3, 1, 2}</span>
</code></pre></figure>
<p>The <code>unique</code> function removes all <em>consecutive duplicates</em> (and thus expects a sorted input) from the range, returning one-past the new logical end of the range. Consecutive duplicates are checked by equality or a given predicate. There is also <code>unique_copy</code>.</p>

<p>Note that the elements are <em>not</em> physically removed from the container, so this call is usually followed by a call to the <code>erase</code> method of the collection with the iterator returned by <code>unique</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>

<span class="k">auto</span> <span class="n">last</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="c1">// v = {1, 2, 3, 4, x, x, x} where x = indeterminate</span>

<span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">EXPECT_EQ</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="n">v</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>remove</code> function rearranges the elements of the range so that those equal to a given value or satisfying a given predicate are moved to the end of the range, allowing them to easily be erased from their container. There&#39;s also <code>remove_copy</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>

<span class="k">auto</span> <span class="n">new_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

<span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">new_end</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</code></pre></figure>
<p>The <code>iter_swap</code> function simply swaps the elements pointed to by the iterators.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="c1">// Swap the 1 and the 3</span>
<span class="n">std</span><span class="o">::</span><span class="n">iter_swap</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

<span class="n">EXPECT_EQ</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="n">v</span><span class="p">);</span>

<span class="c1">// Can also explicitly just dereference iterators and call std::swap</span>
<span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="o">*</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
</code></pre></figure><h3 id="sorting">
<span class="hash">#</span>
<a href="#sorting" class="header-link">Sorting</a>
</h3>
<p>The <code>is_sorted</code> function checks if the range is sorted in ascending order or given a comparison function.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="kt">bool</span> <span class="n">sorted</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_sorted</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
</code></pre></figure>
<p>The <code>is_sorted_until</code> function returns one-past the last sorted element, i.e. the first element that is not sorted.</p>

<p>The <code>sort</code> function sorts the range in ascending order or based on a given comparison function. The <code>stable_sort</code> variant preserves the relative order of equal elements.</p>

<p>The <code>partial_sort</code> function rearranges the elements of the range so that the [begin, middle) contains the elements of the sorted order of the entire array, i.e. the first (middle - begin) smallest elements. There is also <code>partial_sort_copy</code> which only copies enough elements that fit in the destination.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">partial_sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="c1">// v = {0, 1, 2, 7, 8, 6, 5, 9, 4, 3}</span>
<span class="c1">//      |-----|</span>
<span class="c1">//      sorted</span>
</code></pre></figure>
<p>The <code>merge</code> function merges two sorted ranges together into a destination.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span> <span class="n">b</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dest</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">merge</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
           <span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
           <span class="n">dest</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

<span class="c1">// dest = {1, 2, 3, 4, 5, 6}</span>
</code></pre></figure>
<p>The <code>inplace_merge</code> function is an in-place variant of the <code>merge</code> function, merging two sorted ranges denoted by [begin, middle) and [middle, end) into a single sorted range, in-place.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">inplace_merge</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="c1">// v = {1, 2, 3, 4, 5, 6}</span>
</code></pre></figure><h3 id="partitioning">
<span class="hash">#</span>
<a href="#partitioning" class="header-link">Partitioning</a>
</h3>
<p>The <code>is_partitioned</code> function checks if all elements in the range are partitioned based on the given predicate, so that all elements that satisfy the predicate come before all of those that don&#39;t.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

<span class="kt">bool</span> <span class="n">is_parted</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_partitioned</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                                     <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span> <span class="p">});</span>
</code></pre></figure>
<p>The <code>partition</code> function partitions the elements of a range so that all elements that satisfy the predicate come before all of those that don&#39;t. There is also <code>partition_copy</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">partition_func</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span>

<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">partition</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">partition_func</span><span class="p">);</span>

<span class="kt">bool</span> <span class="n">is_parted</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_partitioned</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                                     <span class="n">partition_func</span><span class="p">;</span>
</code></pre></figure>
<p>The <code>stable_partition</code> function is a stable version of the <code>partition</code> function, so that the relative order of equal elements is preserved.</p>

<p>The <code>partition_point</code> function returns one-past the end of the first partition, i.e. the first element that doesn&#39;t satisfy the predicate.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">partition_point</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                                <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
</code></pre></figure><h3 id="transferring">
<span class="hash">#</span>
<a href="#transferring" class="header-link">Transferring</a>
</h3>
<p>The <code>copy</code> function copies elements from the given range into the range beginning at a given iterator position. The <code>copy_if</code> does the same only if the element satisfies a given predicate. There&#39;s also <code>copy_n</code> and <code>copy_backward</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">odds</span><span class="p">,</span> <span class="n">odds_expect</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">copy_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">odds</span><span class="p">),</span>
             <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>

<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">odds_expect</span><span class="p">,</span> <span class="n">odds</span><span class="p">);</span>
</code></pre></figure>
<p>Note that with <code>copy_backward</code> the elements are <em>not</em> copied in reverse, that is, the order of the elements is preserved. Instead, this function copies starting from the right end, which is why the end iterator is provided.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">source</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">destination</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">copy_backward</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">source</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">destination</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">EXPECT_EQ</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">destination</span><span class="p">);</span>
</code></pre></figure>
<p>The <code>move</code> function moves elements from the range into the range beginning with the third parameter. There&#39;s also <code>move_backward</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">ths</span><span class="p">;</span>
<span class="n">ths</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="n">ths</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">dest</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="c1">// Could just dest = move(ths) in this case, but w/e</span>
<span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ths</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ths</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">dest</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</code></pre></figure><h3 id="sets">
<span class="hash">#</span>
<a href="#sets" class="header-link">Sets</a>
</h3>
<p>The <code>set_difference</code> function performs a set difference operation on the two ranges and outputs the result into the destination iterator.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">difference</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">set_difference</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                    <span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                    <span class="n">difference</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

<span class="c1">// difference = {1, 3, 5};</span>
</code></pre></figure>
<p>There is also <code>set_intersection</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intersection</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">set_intersection</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                      <span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                      <span class="n">intersection</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

<span class="c1">// intersection = {1, 2, 3, 4, 5, 6};</span>
</code></pre></figure>
<p>There is also <code>set_union</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">union</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">set_union</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
               <span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
               <span class="k">union</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

<span class="c1">// union = {1, 2, 3, 4, 5};</span>
</code></pre></figure>
<p>The <code>set_symmetric_difference</code> function computes the set of elements that are in either of the sets but <em>not</em> in both (not in their intersection).</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">symmetric_difference</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">set_union</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
               <span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
               <span class="n">symmetric_difference</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

<span class="c1">// symmetric_difference = {1, 2, 4};</span>
<span class="c1">// not 3 because it&#39;s in both</span>
</code></pre></figure><h3 id="heaps">
<span class="hash">#</span>
<a href="#heaps" class="header-link">Heaps</a>
</h3>
<p>The <code>make_heap</code> function constructs a max-heap from the elements in the range, i.e. it&#39;s a &quot;heapify&quot; operation. A heap with a different order can be created using an optional comparison function, for example with <code>std::greater&lt;in&gt;()</code> a min-heap can be created.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">make_heap</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="c1">// v = {9, 5, 4, 1, 1, 3}</span>
</code></pre></figure>
<p>The <code>push_heap</code> function is used to <em>logically push</em> the last element in the range onto the logical heap. This means that the element must already be present in the range, added for example via something like <code>push_back</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">make_heap</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="c1">// physically push</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="c1">// v = {9, 5, 4, 1, 1, 3, 6}</span>

<span class="c1">// logically push</span>
<span class="n">std</span><span class="o">::</span><span class="n">push_heap</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="c1">// v = {9, 5, 6, 1, 1, 3, 4}</span>
</code></pre></figure>
<p>The <code>pop_heap</code> function is used to <em>logically pop</em> the top element from the heap by swapping the top element of the logical heap with the last element in the heap, then re-heapifying to preserve heap-order. If an optional comparison function was used with <code>make_heap</code> or <code>push_heap</code>, it should also be used here.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">make_heap</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="kt">int</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>

<span class="c1">// logically remove</span>
<span class="n">std</span><span class="o">::</span><span class="n">pop_heap</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="c1">// physically remove</span>
<span class="n">v</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="c1">// actually remove</span>
</code></pre></figure>
<p>The <code>sort_heap</code> function essentially performs a heap sort, that is, it sorts the elements into the heap in ascending order or given a comparison function, destroying the logical heap.</p>

<p>The <code>is_heap</code> function checks to see if the range is in heap-order given some optional comparison function. There is an <code>is_heap_until</code> function which returns one-past the last heap-ordered element.</p>
<h3 id="permutations">
<span class="hash">#</span>
<a href="#permutations" class="header-link">Permutations</a>
</h3>
<p>The <code>is_permutation</code> function checks to see if the first range is a permutation of the second range.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span> <span class="n">b</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">is_permutation</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                    <span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="c1">// true</span>
</code></pre></figure>
<p>The <code>next_permutation</code> function rearranges the elements of the range into the lexicographically-next permutation and returns true. If a next permutation doesn&#39;t exist, it wraps around and produces the first permutation (i.e sorted order) and returns false. There is also <code>prev_permutation</code> which does the opposite.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;aba&quot;</span><span class="p">;</span>

<span class="c1">// produce first permutation</span>
<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="k">do</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">next_permutation</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>

<span class="c1">// aab, aba, baa</span>
</code></pre></figure><h2 id="random">
<span class="hash">#</span>
<a href="#random" class="header-link">Random</a>
</h2>
<p>Random engines are a stateful source of randomness, and random distributions use a random engine to generate random numbers distributed over a range.</p>

<p>The <code>shuffle</code> method can be used to shuffle a range based on a given random number generator.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">engine</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">shuffle</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">engine</span><span class="p">);</span>
</code></pre></figure>
<p>Random numbers can be generated with, for example, <code>uniform_int_distribution</code>. The constructor takes the inclusive bounds.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">engine</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">distribution</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">distribution</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></figure><h2 id="concurrency">
<span class="hash">#</span>
<a href="#concurrency" class="header-link">Concurrency</a>
</h2>
<p>Threads are represented by <code>std::thread&lt;F, Args...&gt;</code> and they run on a separate thread. These can be instantiated with a lambda:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kr">thread</span> <span class="nf">print</span><span class="p">([]()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;other thread&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></figure>
<p>Threads can be <code>join</code>ed and <code>detach</code>ed.</p>

<p>The <code>std::mutex</code> type represents a mutex, which can be <code>lock</code>ed and <code>unlock</code>ed.</p>

<p>An <code>std::lock_guard</code> is a type that provides RAII ownership of an <code>std::mutex</code>, so that the lock is automatically unlocked when the <code>lock_guard</code> is destroyed.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">global_mutex</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">global_mutex</span><span class="p">);</span>

  <span class="c1">// unlocked here</span>
<span class="p">}</span>
</code></pre></figure>
<p>An <code>std::unique_lock</code> is similar except that it may not necessarily be associated with a mutex, and locking and unlocking can be done explicitly, essentially it simply guarantees that if the mutex is locked when the <code>unique_lock</code> is destroyed, it unlocks it.</p>

<p>Ownership of the associated lock can be <code>release</code>ed.</p>

<p>The <code>std::lock</code> function can lock an arbitrary number of locks (passed as parameters) in such a way that deadlocks are avoided. If an exception occurs, all so-far locked mutexes are unlocked.</p>

<p>An <code>std::condition_variable</code> represents a condition variable which can be used to notify others of being ready via <code>notify_one</code> and <code>notify_all</code>, and others to wait on the condition variable via <code>wait</code>. One of the overloads of <code>wait</code> can accept a lambda which is used to test the condition, in order to guard against spurious wake-ups, in which case the wait is repeated.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>

<span class="kt">bool</span> <span class="n">ready</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">// thread 1 runs first</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

<span class="c1">// notify waiting threads</span>
<span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>

<span class="c1">// thread 2 runs after, and waits on the condition variable</span>
<span class="c1">// to guard against spurious wake-ups, a lambda is run to ensure</span>
<span class="c1">// that the actual condition holds. if it doesn&#39;t, it waits again</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ready</span><span class="p">;</span> <span class="p">});</span>
</code></pre></figure>
<p>An <code>std::promise&lt;T&gt;</code> is the push/write-end of the promise-future communication channel. It can be used to store a value that is later acquired asynchronously via an <code>std::future</code> created by the promise via <code>get_future</code>. A promise is made ready by writing a value to it via <code>set_value</code>.</p>

<p>A value can be obtained from the future via <code>get</code>, which blocks until a result is received, then returns that value. There&#39;s also <code>wait</code> that simply waits until the value is received, but doesn&#39;t actually retrieve it.</p>

<p>The <code>std::async</code> function wraps a function and calls it asynchronously, possibly on another thread, and returns a future representing the result.</p>

<p>The <code>std::packaged_task&lt;R(Args...)&gt;</code> type is similar in that it wraps any callable so that it can be invoked asynchronously and its return value obtained via a future. It does this by overloading the call operator so that when the function returns, its value is written to a promise.</p>

<p>The future is obtained via <code>get_future</code>. The <code>packaged_task</code> can then be run on a separate thread, for example.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
 <span class="k">else</span> <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fib</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>

<span class="kr">thread</span> <span class="nf">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="mi">40</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></figure>
<p>Atomic types are represented by <code>std::atomic&lt;T&gt;</code> and they can be either integral types or pointers. Their constructor takes their initial value.</p>

<p>Atomic replacement of the value is done via <code>store</code>, and atomic reading can be done with <code>load</code>, which is also aliased to a conversion operator for the underlying type.</p>

<p>The <code>exchange</code> method atomically exchanges the current value with another, and returns the old value.</p>

<p>Similarly, there are <code>fetch_</code> methods such as <code>fetch_add</code> which atomically adds an operand to the atomic variable and returns the original value. The increment and decrement operators are also overloaded to perform atomic increments and decrements.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Taken from <a href="http://stackoverflow.com/a/613132/101090">this great StackOverflow answer</a>.&nbsp;<a href="#fnref1" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

<li id="fn2">
<p>This reminds me of Higher-Kinded Types&nbsp;<a href="#fnref2" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

<li id="fn3">
<p>This seems similar to a diverging function in Rust which returns <code>-&gt; !</code>.&nbsp;<a href="#fnref3" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

<li id="fn4">
<p><a href="https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920">Three Optimization Tips for C++</a>&nbsp;<a href="#fnref4" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

</ol>
</div>
</div>
  <div class="meta">
    <div class="meta-component"><i class="fa fa-calendar fa-fw"></i> September 10, 2013</div>
    <div class="meta-component"><i class="fa fa-code-fork fa-fw"></i> <a href="https://github.com/blaenk/site/commits/master/input/notes/cpp.markdown">History</a><span class="hash">, <a href="https://github.com/blaenk/site/commit/e5cef8c" title="transcribe notes, rearrange TOC sections">e5cef8c</a></span></div>
    <div class="meta-component"><i class="fa fa-pencil fa-fw"></i> <a href="..">Notes</a></div>
  </div>
</article>



    
    <footer id="footer">
  <div id="social">
    <a href="https://github.com/blaenk" title="github"><i class="fa fa-github-alt"></i></a>
    &middot;
    <a href="http://stackoverflow.com/users/101090/jorge-israel-pena" title="stackoverflow"><i class="fa fa-stack-overflow"></i></a>
    &middot;
    <a href="https://twitter.com/blaenk" title="twitter"><i class="fa fa-twitter"></i></a>
    &middot;
    <a href="mailto:jorge.israel.p@gmail.com" title="email"><i class="fa fa-envelope"></i></a>
    &middot;
    <a href="/rss.xml" title="feed"><i class="fa fa-rss-square"></i></a>
  </div>
  <!-- <div id="credit">
    Designed by <a href="http://www.blaenkdenum.com">Jorge Israel Peña</a>
  </div> -->
</footer>


<!-- this should instead be something like connectWS("{{{path}}}") -->


<script type="text/javascript">
  jQuery(function (){
    var ws = new WebSocket('ws://' + window.location.hostname + ':9160/notes/cpp.markdown');

    ws.onmessage = function (e) {
      var content = jQuery('article .entry-content');
      content.html(e.data);

      window.refresh();

      MathJax.Hub.Queue(["Typeset", MathJax.Hub, jQuery('article .entry-content')[0]]);

      if (window.jumpDown)
        window.scrollDown();
    };
  });
</script>




<!-- google analytics -->
<script async="true" type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37339861-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

<!--MathJax CDN-->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    messageStyle: "none"
  });

  MathJax.Hub.Register.MessageHook('End Process', function() {
    jQuery('#MathJax_Font_Test').empty();
    jQuery('.MathJax_Display').parent().addClass('mathjax');
  });
</script>

  </div>
</body>
</html>
