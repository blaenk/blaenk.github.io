<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Computer Architecture - Blaenk Denum</title>
  <meta name="author" content="Jorge Israel Peña">
  <meta name="description" content="AKA Blaenk Denum">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="/favicon.png" rel="shortcut icon">
  <link href='http://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Merriweather:900italic,900,700italic,400italic,700,400,300italic,300' rel='stylesheet' type='text/css'>
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='/css/screen.css' rel='stylesheet' type='text/css' />
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured"></script>
  <script src="https://rawgit.com/ekalinin/typogr.js/master/typogr.min.js"></script>
  <script src='/js/blaenk.js' type='text/javascript'></script>
</head>
<body>
  <div class="page-wrapper">
    <header id="header">
  <div id="stamp">
    <h1 id="name">
      <a href="/">
        <span class="emboldened">Jorge</span>.Israel.<span class="emboldened">Peña</span>
      </a>
    </h1>
    <h4 id="pseudonym">
      AKA <span class="emboldened">Blaenk</span>.Denum
    </h4>
  </div>
  <nav id="main-nav">
    <ul class="main">
      <li><a href="/about/">About</a></li>
      <li><a href="/notes/">Notes</a></li>
      <li><a href="/work/">Work</a></li>
      <li><a href="/lately/">Lately</a></li>
      <li><a id="search_btn">Search</a></li>
    </ul>
  </nav>
  <nav id="mobile-nav">
    <div class="menu">
      <a class="button">Menu</a>
      <div class="container">
        <ul class="main">
          <li><a href="/about/">About</a></li>
          <li><a href="/notes/">Notes</a></li>
          <li><a href="/work/">Work</a></li>
          <li><a href="/lately/">Lately</a></li>
        </ul>
      </div>
    </div>
    <div class="search">
      <a class="button"></a>
      <div class="container">
        <form action="http://google.com/search" method="get">
          <input type="text" name="q" results="0">
          <input type="hidden" name="q" value="site:blaenkdenum.com">
        </form>
      </div>
    </div>
  </nav>
</header>
<form class="desk_search" action="http://google.com/search" method="get">
  <input id="search" type="text" name="q" results="0" placeholder="Search" autocomplete="off" spellcheck="false">
  <input type="hidden" name="q" value="site:blaenkdenum.com">
</form>

    
        <article class="post">
  <h2 class="title"><a href="/notes/computer-architecture"><span>Computer Architecture</span></a></h2>
  <div class="entry-content"><nav id="toc">
<h3>Contents</h3><ol>
<li>
<a href="#metrics">Metrics</a>
</li>
<li>
<a href="#pipelining">Pipelining</a>
<ol>
<li>
<a href="#dependencies">Dependencies</a>
</li>
</ol>
</li>
<li>
<a href="#branch-prediction">Branch Prediction</a>
</li>
<li>
<a href="#predication">Predication</a>
</li>
<li>
<a href="#out-of-order-execution">Out-of-Order Execution</a>
<ol>
<li>
<a href="#reorder-buffer">Reorder Buffer</a>
</li>
<li>
<a href="#load-store-queue">Load-Store Queue</a>
</li>
</ol>
</li>
<li>
<a href="#caches">Caches</a>
<ol>
<li>
<a href="#direct-mapped-cache">Direct-Mapped Cache</a>
</li>
<li>
<a href="#set-associative-cache">Set-Associative Cache</a>
</li>
<li>
<a href="#fully-associative-cache">Fully-Associative Cache</a>
</li>
<li>
<a href="#cache-replacement">Cache Replacement</a>
<ol>
<li>
<a href="#least-recently-used">Least Recently Used</a>
</li>
<li>
<a href="#not-most-recently-used">Not Most Recently Used</a>
</li>
<li>
<a href="#pseudo-least-recently-used">Pseudo-Least Recently Used</a>
</li>
</ol>
</li>
<li>
<a href="#cache-write-policies">Cache Write Policies</a>
</li>
<li>
<a href="#cache-misses">Cache Misses</a>
</li>
<li>
<a href="#prefetching">Prefetching</a>
</li>
<li>
<a href="#non-blocking-caches">Non-Blocking Caches</a>
</li>
</ol>
</li>
<li>
<a href="#virtual-memory">Virtual Memory</a>
</li>
<li>
<a href="#loop-interchange">Loop Interchange</a>
</li>
<li>
<a href="#memory">Memory</a>
</li>
<li>
<a href="#hard-disks">Hard Disks</a>
<ol>
<li>
<a href="#fault-tolerance">Fault Tolerance</a>
</li>
<li>
<a href="#redundant-array-of-independent-disks">Redundant Array of Independent Disks</a>
<ol>
<li>
<a href="#raid-0">RAID 0</a>
</li>
<li>
<a href="#raid-1">RAID 1</a>
</li>
<li>
<a href="#raid-4">RAID 4</a>
</li>
<li>
<a href="#raid-5">RAID 5</a>
</li>
<li>
<a href="#raid-6">RAID 6</a>
</li>
</ol>
</li>
</ol>
</li>
<li>
<a href="#cache-coherence">Cache Coherence</a>
<ol>
<li>
<a href="#msi-coherence">MSI Coherence</a>
</li>
<li>
<a href="#mosi-coherence">MOSI Coherence</a>
</li>
<li>
<a href="#mesimoesi-coherence">MESI/MOESI Coherence</a>
</li>
<li>
<a href="#directory-based-coherence">Directory-based Coherence</a>
</li>
</ol>
</li>
<li>
<a href="#synchronization">Synchronization</a>
</li>
<li>
<a href="#memory-consistency">Memory Consistency</a>
</li>
</ol>
</nav>
<h1 id="metrics">
<span class="hash">#</span>
<a href="#metrics" class="header-link">Metrics</a>
</h1>
<p>Moore&#39;s Law states that every 18-24 months we get twice the number of transistors onto the same chip area. Essentially, processor speed doubles, energy/operation halves, and memory capacity doubles. The <em>memory wall</em> thus refers to the fact that latency only improves by 1.1x every 2 years, whereas CPU performance and memory capacity double every two years.</p>

<p>Dynamic power is consumed when there is activity on the circuit, whereas static power is consumed when the system is powered on but idle. The active power is:</p>

<p><script type="math/tex; mode=display"> P = \frac 1 2 C \cdot V^2 \cdot f \cdot \alpha </script></p>

<p>where <script type="math/tex">C</script> is the capacitance (proportional to chip area), <script type="math/tex">V</script> is the power supply voltage, <script type="math/tex">f</script> is the frequency, and <script type="math/tex">\alpha</script> is the activity factor (e.g. what percent of the processor transistors are actually active).</p>

<p>The fabrication yield can be computed as:</p>

<p><script type="math/tex; mode=display"> \text {yield} = \frac {\text {working chips}} {\text {chips on wafer}} </script></p>

<p>The two different ways in which the benefits of Moore&#39;s Law can be reaped are lower cost: a smaller chip that does the same thing as the larger, previous generation chip, or increased speed for the same cost: new chip with the same area that is faster and more capable for the same cost as the previous generation chip.</p>

<p>The Iron Law for measuring CPU time is computed as:</p>

<p><script type="math/tex; mode=display">
\begin{align*}
\text {CPU Time} &= \frac {\text {instructions}} {\text {program}} \cdot \frac {\text {cycles}} {\text {instructions}} \cdot \frac {\text {seconds}} {\text {cycles}}\\
&= \frac {\text {seconds}} {\text {program}}
\end{align*}
</script></p>

<p>Amdahl&#39;s Law measures the speedup when only a fraction of the program was enhanced. The enhanced fraction refers to a percentage of the original execution time that is affected by the enhancement. The implication of Amdahl&#39;s Law is to focus on optimizing the common case.</p>

<p><script type="math/tex; mode=display"> \text {speedup} = \frac {1} {(1 - \text {enhanced fraction}) + \frac {\text {enhanced fraction}} {\text {enhanced speedup}}} </script></p>

<p>Lhadma&#39;s Law cautions that in pursuit of optimizing the common case, the uncommon case shouldn&#39;t be slowed down too much.</p>

<p>Diminishing returns with respect to Amdahl&#39;s Law refers to the fact that continuing to optimize a specific part of the execution eventually provides less and less gains in speedup, because the optimized portion grows smaller and smaller, accounting for less and less of execution time. Intuitively, it can be considered that the &quot;low hanging fruit&quot; of optimizations will be gone after a while, making it harder to optimize. The practical implication of this is that after optimizing a portion of the execution, one must re-evaluate which portion is now dominant.</p>
<h1 id="pipelining">
<span class="hash">#</span>
<a href="#pipelining" class="header-link">Pipelining</a>
</h1>
<p>Pipeline stalls can happen due to data dependencies. For example, an instruction reads a register but another instruction farther down the pipeline is set to write to that register. The read instruction would obtain an outdated value if it weren&#39;t stalled until after the write completed.</p>

<p>Pipeline flushes may be necessary due to jump instructions. By the time the pipeline recognizes that it&#39;s a jump instruction, the instructions that follow it are already inside the pipeline behind the jump instruction&#39;s stage. Since those instructions which follow the jump instruction aren&#39;t actually going to be executed, they need to be flushed out of the pipeline.</p>

<p>The longer a pipeline is, the higher the cost of branch misprediction, because it means that more instructions will have been loaded into the pipeline which need to be flushed.</p>
<h2 id="dependencies">
<span class="hash">#</span>
<a href="#dependencies" class="header-link">Dependencies</a>
</h2>
<p>A <em>control dependency</em> is when an instruction depends on a branch, such that the pipeline cannot know whether to load those instructions until it determines the result of the branch. These can be eliminated with branch prediction.</p>

<p>A <em>data dependency</em> is when an instruction depends on data computed by a previous instruction.</p>

<p>A <em>read-after-write data dependency</em> (RAW) is when an instruction has a data dependency because it tries to <em>read</em> a value after it was <em>written</em> by a previous instruction. Instructions with RAW dependencies must stall. Forwarding isn&#39;t possible for RAW dependencies because it would imply time travel, i.e. sending the written value to the read that occurred in the past.</p>

<p>A <em>write-after-write data dependency</em> (WAW) is when the order of the writes must be preserved. For example, if adding two registers and storing the result in register A, then subtracting two registers and storing the result in register A, the final value of register A should be the subtraction result.</p>

<p>A <em>write-after-read data dependency</em> (WAR) is when a write must occur until after a register was read by a previous instruction.</p>

<p>Read-after-write dependencies are also known as <em>true dependencies</em> because the read truly depends on the write having occurred. True dependencies can be mitigated by out-of-order execution.</p>

<p>Write-after-read and write-after-write dependencies are also known as <em>false dependencies</em>, or <em>name dependencies</em>, because the only reason that the dependency exists is because the same register is being used for two different results. For example, in write-after-write, two different instructions may write to the same register.</p>

<p><em>Register renaming</em> is a way to eliminate false/name dependencies. It establishes two kinds of registers. <em>Architectural registers</em> are ones that the programmer/compiler uses, and <em>physical registers</em> are the actual locations the values go to. Register renaming rewrites the program to use physical registers, and uses a <em>Register Allocation Table</em> (RAT) to map architectural registers to physical registers.</p>

<p>The RAT begins with some predefined architecture-to-physical register mappings. Each instruction&#39;s architecture register operands are rewritten to physical registers based on those mappings. Every time an instruction writes to an architectural register, that target architectural register is rewritten into a new/different physical register, and the entry for that architectural register is updated in the RAT.</p>

<p>A <em>structural dependency</em> comes about when there isn&#39;t enough hardware to perform an operation in the same cycle. For example, if the current instruction requires an adder but all adders are currently being used, it has to wait.</p>

<p>A <em>pipeline hazard</em> is when a dependency results in incorrect execution. It&#39;s important to note that a dependency in a pipeline doesn&#39;t automatically result in a pipeline hazard.</p>

<p>In order to resolve hazards caused by control dependencies, it&#39;s necessary to flush the dependent instructions.</p>

<p>In order to resolve hazards caused by data dependencies, it&#39;s necessary to either stall the dependent instructions or forward the correct values to them.</p>

<p>The reason that instructions are loaded into a pipeline before even knowing if a branch will take place is that in the event that the branch is not taken, no stalls are necessary.</p>
<h1 id="branch-prediction">
<span class="hash">#</span>
<a href="#branch-prediction" class="header-link">Branch Prediction</a>
</h1>
<p>The only basis on which a branch predictor may predict is the current instruction&#39;s address, i.e. the program counter (PC). In particular, the branch predictor must determine if the current PC is a taken branch, and if so, what the target PC is.</p>

<p>Given the choice between always predicting that a branch isn&#39;t taken, and refusing to predict at all by waiting until the branch predicate is computed, it&#39;s much better to always predict that the branch isn&#39;t taken. This way, in the worst case, it will not be any more costly than waiting until the predicate is computed, and in the best case it will be significantly faster.</p>

<p>The <em>predict not-taken</em> branch predictor works by always predicting that the branch is taken, which is accomplished by simply implementing the PC as usual.</p>

<p>Since a branch predictor can only base its decision on the instruction PC, without knowing if the current instruction even is a branch (since the instruction hasn&#39;t been decoded), whether it&#39;s taken, or its offset, the way that a branch predictor can improve its predictions is by remembering the previous results for that same PC.</p>

<p>A <em>branch table buffer</em> (BTB) is a table that maps the current PC to the predicted target PC. If it was a misprediction, the target PC is updated for that current PC. In order to keep the BTB small and the lookup fast, the table is indexed by some of the least significant bits of the PC, since those are more likely to differ from one instruction to the next.</p>

<p>A <em>branch history table</em> (BHT) is a table that maps the current PC to whether the branch was taken (1) or not (0).</p>

<p>The BTB works by indexing into the BHT to determine if the branch is taken. If the branch is taken, index into the BTB to determine the target PC. Otherwise if the branch isn&#39;t taken, simply increment the PC as usual. On a misprediction, the BTB and BHT are both updated. If it mispredicted that the branch was taken and it wasn&#39;t, only the BHT is updated to reflect that the branch isn&#39;t taken.</p>

<p>When indexing the BTB and BHT, the least significant bits are used <em>except</em> for the first few bits that represent the instruction alignment boundaries, because those bits will always be zero. For example, on a 32-bit architecture the instructions are word aligned, which means that all instructions are on 4-byte boundaries, which also means that all instruction addresses are divisible by 4, which means that all instruction addresses end in 00.</p>

<p>The <em>2-Bit Predictor</em> (2BP) (aka <em>2-Bit Counter</em> (2BC)) works by maintaining a counter that counts from 0 (0b00, not taken) to 3 (0b11, taken). If the counter is 1 (0b01) or 2 (0b10), the prediction remains the same as the previous, unless it&#39;s a misprediction. The first bit can be interpreted as a <em>prediction bit</em>, specifying whether the branch is taken or not. The second bit can be interpreted as a <em>hysteresis</em> (conviction) bit, specifying how &quot;sure&quot; it is of the prediction bit&#39;s value.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Counter</th>
<th style="text-align: left">Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">0b00</td>
<td style="text-align: left">strong not-taken</td>
</tr>
<tr>
<td style="text-align: left">0b01</td>
<td style="text-align: left">weak not-taken</td>
</tr>
<tr>
<td style="text-align: left">0b10</td>
<td style="text-align: left">weak taken</td>
</tr>
<tr>
<td style="text-align: left">0b11</td>
<td style="text-align: left">strong taken</td>
</tr>
</tbody>
</table>

<p>The advantage of the 2-Bit Predictor is that a single anomaly will not completely change the prediction. For example, given a small loop, finishing the loop will cause a misprediction, but it won&#39;t change the prediction value to not-taken because the majority of the time it <em>is</em> taken. Instead, it would only change if the misprediction happens again.</p>

<p>The preferred state of a 2-Bit Predictor is one of the weak states, 2 or 3, since there&#39;s a one-time misprediction cost in the worst case. If it started on a strong state, such as 0 or 4, then there would need to be two mispredictions to update the prediction.</p>

<p><img src="http://i.imgur.com/ibzq3pF.png" class="center" /></p>

<p>The pathological case of initializing a 2-Bit Predictor with a weak state is that if it alternates between taking a branch and not taking the branch, then each misprediction will only flip between the weak states, causing a misprediction <em>every time</em>. If it had started on a strong state, it would only move to a weak state on a misprediction, which would mean that the prediction would be correct half of the time.</p>

<p>More generally, every branch predictor has a sequence where it will mispredict 100% of the time.</p>

<p>A <em>history-based predictor</em> works by keeping track of the last <script type="math/tex">N</script> branch outcomes to determine the next one.</p>

<p>A 1-Bit History BHT works by storing the branch outcome bit along with two 2-Bit Counters. On any given prediction, the current branch outcome bit is used to determine which 2-Bit Counter to use for the prediction. On a misprediction, the outcome bit is updated to reflect the outcome. Regardless of the outcome, the chosen 2-Bit Counter is updated based on that outcome.</p>

<p><img src="http://i.imgur.com/gP7Fnjh.png" class="center" /></p>

<p>An entry in the BHT of a 2-Bit History Predictor contains 2 bits of history and 4 x 2-Bit Counters (one for each history configuration).</p>

<p>An N-Bit History Predictor must store for each entry in the BHT, <script type="math/tex">N</script> history bits and <script type="math/tex">2^N</script> 2-Bit Counters, one for each configuration. The 2-Bit Counter that is used for any particular prediction is determined by the history bits.</p>

<p>An N-Bit History Predictor can accurately predict all branch prediction patterns of length <script type="math/tex">\le N + 1</script>. An N-Bit History Predictor requires, per entry;</p>

<p><script type="math/tex; mode=display">N + \text{2-bit counter} \cdot 2^N \text{ history permutations}</script></p>

<p>The <em>PShare Predictor</em> works by storing a private history for each branch and sharing 2-Bit Counters. The history bits are stored in a <em>Pattern History Table</em> (PHT). Each entry is XORed with the PC bits to index into the BHT to obtain the shared 2-Bit Counters. When the 2-Bit Counter is updated, the new history is mapped to this updated counter.</p>

<p><img src="http://i.imgur.com/TNz1iDw.png" class="center" /></p>

<p>The <em>GShare Predictor</em> works similarly to the PShare Predictor, except that there is a global history. This is useful for <em>correlated branches</em>. For example, the following branches are correlated in the sense that if one branch is taken, the other is not:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">if</span> <span class="p">(</span><span class="n">shape</span> <span class="o">==</span> <span class="n">square</span><span class="p">)</span>
  <span class="c1">// ...</span>

<span class="k">if</span> <span class="p">(</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">square</span><span class="p">)</span>
  <span class="c1">// ...</span>
</code></pre></figure>
<p>The <em>Tournament Predictor</em> works by leveraging multiple predictors, such as GShare and PShare, and using a <em>Meta-Predictor Table</em>, which stores entries specifying which of the other predictors is more likely to be correct.</p>

<p>The <em>Hierarchical Predictor</em> works similarly to the Tournament Predictor, except that where the Tournament Predictor uses two good predictors and pays a considerable cost for each, a Hierarchical Predictor uses one &quot;good&quot; predictor and one &quot;OK&quot; predictor.</p>

<p>Whereas in a Tournament Predictor both branches are updated on each branch outcome, in a Hierarchical Predictor, the &quot;OK&quot; predictor is updated on each branch outcome, but the &quot;good&quot; predictor is only updated if the &quot;OK&quot; predictor was not correct.</p>

<p>A real-world Hierarchical Predictor in the Pentium M processors works by maintaining a hierarchy of predictors: 2-Bit Counters, Local, and Global predictors. If the 2-Bit Counter mispredicts, that entry is added to the Local predictor, and likewise Local to Global. The Local and Global predictors maintain a tag array indicating whether or not that PC is covered by that predictor.</p>

<p>A <em>Return Address Stack</em> (RAS) predictor is for predicting the target of a function return. A BTB alone would always remember the previous call&#39;s return, which may not be the same call and so would be incorrect. An RAS predictor works by maintaining a stack. On each function call, the return address is pushed. On each function return, the stack is popped. An RAS predictor is necessary aside/separate from the regular program call stack because it&#39;s necessary for fast predictions. When the RAS predictor stack is full, pushes wrap around. Like branch prediction, a RAS predictor needs to be usable even before the instruction is determined to be a return instruction (<code>RET</code>), which is accomplished by using a simple predictor or pre-decoding the instruction.</p>
<h1 id="predication">
<span class="hash">#</span>
<a href="#predication" class="header-link">Predication</a>
</h1>
<p><em>Branch Predication</em> refers to executing the instructions on both directions/sides of a branch, so that only half of the work is wasted and discarded. This is primarily useful when it ends up being much faster than the branch misprediction overhead.</p>

<p><em>if-conversion</em> works by removing an <code>if</code> condition where both branches are similar, so that instead the work of both branches is done and the correct result is chosen based on the original condition.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// BEFORE</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">cond</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure><figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// AFTER</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="n">y1</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">?</span> <span class="nl">x1</span> <span class="p">:</span> <span class="n">x2</span><span class="p">;</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">?</span> <span class="nl">y1</span> <span class="p">:</span> <span class="n">y2</span><span class="p">;</span>
</code></pre></figure>
<p>During an if-conversion, the result of the correct branch must be chosen, but doing it by using a branch would defeat the purpose of the if-conversion:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">x</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">?</span> <span class="nl">x1</span> <span class="p">:</span> <span class="n">x2</span><span class="p">;</span>
</code></pre></figure>
<p>Instead a conditional move instruction can be used. A <em>conditional move instruction</em> performs a move <em>only if</em> the condition is true. On x86, this refers to the <code>cmovz</code>, <code>cmovnz</code>, <code>cmovgt</code>, etc. family of functions.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-nasm"><span class="nf">r3</span> <span class="err">=</span> <span class="nv">cond</span>
<span class="nf">r1</span> <span class="err">=</span> <span class="nv">x1</span>
<span class="nf">r2</span> <span class="err">=</span> <span class="nv">x2</span>
<span class="nf">movn</span> <span class="nv">x</span><span class="p">,</span> <span class="nv">r1</span><span class="p">,</span> <span class="nv">r3</span> <span class="c1">;; use r1 if cond is != 0 (true)</span>
<span class="nf">movz</span> <span class="nv">x</span><span class="p">,</span> <span class="nv">r2</span><span class="p">,</span> <span class="nv">r3</span> <span class="c1">;; use r2 if cond is == 0 (false)</span>
</code></pre></figure>
<p><em>Full branch predication</em> refers to adding condition bits to <em>every</em> instruction which specifies whether the instruction actually carries out its operation. Some instructions are used to establish the predicates and the subsequent instructions can be predicated with them so that they only carry out their operation if that predicate holds.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-nasm"><span class="c1">; if r1 == 0 { p1 = 1, p2 = 0 } else { p1 = 0, p2 = 1 }</span>
<span class="nf">mp.eqz</span> <span class="nv">p1</span><span class="p">,</span> <span class="nv">p2</span><span class="p">,</span> <span class="nv">r1</span>
<span class="err">(</span><span class="nf">p2</span><span class="p">)</span> <span class="nv">add1</span> <span class="nv">r2</span><span class="p">,</span> <span class="nv">r2</span><span class="p">,</span> <span class="mi">1</span> <span class="c1">;; only add if p2 == 1</span>
<span class="err">(</span><span class="nf">p1</span><span class="p">)</span> <span class="nv">add1</span> <span class="nv">r3</span><span class="p">,</span> <span class="nv">r3</span><span class="p">,</span> <span class="mi">1</span> <span class="c1">;; only add if p1 == 1</span>
</code></pre></figure>
<p><em>Instruction Level Parallelism</em> (ILP) refers to what the <em>Instructions Per Cycle</em> (IPC) would be on an ideal processor which can execute an entire instruction in 1 cycle, and can execute any number of instructions in the same cycle <em>while obeying</em> true dependencies. ILP is a property of the program, <em>not</em> the processor, since ILP concerns an <em>ideal</em> processor which doesn&#39;t exist.</p>

<p>The ILP of a program is determined by renaming registers and &quot;executing&quot; through the code. For example, given:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-nasm"><span class="nf">add</span> <span class="nv">p10</span><span class="p">,</span> <span class="nv">p2</span><span class="p">,</span> <span class="nv">p3</span>
<span class="nf">xor</span> <span class="nv">p6</span><span class="p">,</span> <span class="nv">p7</span><span class="p">,</span> <span class="nv">p8</span>
<span class="nf">mul</span> <span class="nv">p5</span><span class="p">,</span> <span class="nv">p8</span><span class="p">,</span> <span class="nv">p9</span>
<span class="nf">add</span> <span class="nv">p4</span><span class="p">,</span> <span class="nv">p8</span><span class="p">,</span> <span class="nv">p9</span>
<span class="nf">sub</span> <span class="nv">p11</span><span class="p">,</span> <span class="nv">p10</span><span class="p">,</span> <span class="nv">p5</span> <span class="c1">;; true dep on: add&#39;s p10 and mul&#39;s p5</span>
</code></pre></figure>
<p>The ILP of the above program is:</p>

<p><script type="math/tex; mode=display"> \frac {\text {5 instructions}} {\text {2 cycles}} = 2.5 \text { ILP} </script></p>

<p>2 cycles are necessary because the first 4 instructions can be done in the same cycle in the ideal processor defined by ILP, but the final instruction would occur in the next cycle due to the true dependencies present in the code.</p>

<p>When determining ILP, structural dependencies are not considered since they concern hardware limitations, but ILP presupposes an ideal processor, that is, every instruction that can possibly execute in the same cycle <em>will</em> execute in the same cycle without having to wait on some resource (e.g. all adders are being used).</p>

<p>When determining ILP, control dependencies are not considered since ILP assumes a perfect, same-cycle branch prediction, so that branches still execute but have no impact on delaying further instructions.</p>

<p>ILP is constrained by the issue-width and the order of execution. If narrow-issue and in-order, ILP is limited by narrow-issue. If wide-issue and in-order, ILP is limited by in-order because it prevents saturation of the issue-width. If wide-issue and out-of-order, ILP is maximized because out-of-order can continue to find instructions to saturate the wide-issue, regardless of their order.</p>
<h1 id="out-of-order-execution">
<span class="hash">#</span>
<a href="#out-of-order-execution" class="header-link">Out-of-Order Execution</a>
</h1>
<p>Tomasulo&#39;s Algorithm is an instruction scheduling algorithm for out-of-order execution. It determines which instructions have inputs ready so that they could begin in the next cycle, whereas the rest still have to wait for their inputs to be produced. This also includes register renaming.</p>

<p>As instructions are fetched from the instruction queue they are placed in a <em>reservation station</em>, where they wait for their parameters to become ready. Existing registers are placed into the instructions that depend on them in the reservation station.</p>

<p>When an instruction&#39;s result is computed, it is broadcast on a bus and ends up in the register file for the appropriate destination register, and/or in a reservation station&#39;s instruction&#39;s operands if needed.</p>

<p>Data resulting from a load (from memory) has an output to broadcast on the bus (sent to the register file or dependent reservation stations). Store (in memory) operations have an input from the load data and computed value bus, so that storing data from registers into memory can be accomplished as soon as the register values become available.</p>

<p>When an instruction is <em>issued</em> it means that it&#39;s taken off of the instruction queue and sent to the store unit and reservation station.</p>

<p>When an instruction in a reservation station becomes ready, it is <em>dispatched</em>, which means it is sent to the compute unit.</p>

<p>When an instruction has computed its result and is ready to be broadcast, it performs a <em>write result</em> or <em>broadcast</em>. In particular, the reservation station producing the result as well as the result itself is broadcast.</p>

<p>On each cycle, different instructions will be in any one of the following phases:</p>

<ul>
<li><strong>issue</strong>: fetch instruction from instruction queue, determine dependencies from RAT</li>
<li><strong>capture</strong>: update dependencies with latest results</li>
<li><strong>dispatch</strong>: send instruction for execution</li>
<li><strong>write result (broadcast)</strong>: send result to reservation stations, write to register file, update RAT</li>
</ul>

<p>During the <em>issue phase</em>, the next instruction in program order (so that register renaming works correctly) is taken from the instruction queue. Then the input registers are identified and their source determined---whether already in the register file or produced by an instruction that hasn&#39;t yet finished executing---by looking in the RAT. Then a free reservation station of the correct kind (adder, multiplier, etc.) is found. If all reservation stations are taken, nothing is issued this cycle. The instruction is placed into the free reservation station. The instruction&#39;s destination register is tagged so that the result is placed there and future instructions that require the register know which instruction produces it.</p>

<p>The <em>Register Alias Table</em> (RAT) is used so that fetched instructions can identify the reservation stations that they depend on, and so that they can specify that all future instructions that require its destination register should wait for its reservation station (i.e. wait for it to complete). If an entry is empty, it signals to other instructions that they should simply read the value from the actual physical register in the register file because the result has already been computed.</p>

<p>During the <em>dispatch phase</em>, the reservation station of the just-completed instruction is freed. All reservation stations that depend on the just-completed instruction&#39;s result have the result inserted in the corresponding operand(s). Those instructions that become ready are dispatched to the execution unit. If more than one instruction is ready, we choose the instruction to dispatch based on some policy, such as oldest first, random, or most-dependencies first (difficult to implement/costly).</p>

<p>During the <em>write result</em> (broadcast) phase, the reservation station&#39;s tag and result are broadcast on the bus. The result is written to the register file by indexing the RAT with the tag to determine the actual register. The RAT is updated so that the entry that contained the tag is cleared, which signals that the register file should be read instead. Finally, the reservation station with that tag is freed.</p>

<p>When more than one instruction finishes in the same cycle and they need to be broadcast, some heuristic is used to quickly determine which one goes first. Usually a priority is given that is inversely proportional to the speed of the unit. For example, if the multiplier is slower than the divide, the multiplier is given a higher priority. This is because they will have been executing for a longer time, so it&#39;s more likely that they have more dependencies on them by now.</p>

<p>A stale result can occur because another instruction clobbered/overwrote the same entry in the RAT. If a stale result is broadcast, the reservation station is updated with the result as usual. However, the RAT is not updated because no further instructions will ever use that result. This is because for the result to be stale, it means that another instruction overwrote its entry in the RAT, and that only occurred because there is a newer instruction that is producing the value for that same register.</p>

<p>In Tomasulo&#39;s Algorithm, loads and stores occur in-order.</p>
<h2 id="reorder-buffer">
<span class="hash">#</span>
<a href="#reorder-buffer" class="header-link">Reorder Buffer</a>
</h2>
<p>Exceptions are a problem in Tomasulo&#39;s Algorithm because after returning from the exception handler to the excepting instruction, the instructions that follow might have already executed out-of-order. This may clobber/corrupt the operands of the excepting instruction, which would result in an incorrect result on resumption.</p>

<p>Branch mispredictions are a problem in Tomasulo&#39;s Algorithm because out-of-order execution can execute instructions following a branch instruction even if there ended up being a misprediction, in which case those instructions shouldn&#39;t have executed.</p>

<p>A <em>phantom exception</em> is an exception that triggered despite a branch misprediction, in which case the excepting instruction should never have executed to begin with.</p>

<p>To ensure proper out-of-order execution, values should be deposited to registers in-order. This way, if it turns out that an instruction shouldn&#39;t have executed (i.e. due to exceptions or branch mispredictions), the instruction&#39;s destination register will not have been overwritten.</p>

<p>A <em>reorder buffer</em> (ROB) is a buffer that remembers the program order and keeps the result of instructions until they are safe to write. A typical entry contains the value produced by the instruction, a done bit specifying whether the value has been set, and the register to write to.</p>

<p>Two pointers into a reorder buffer (ROB) are maintained. The <em>commit pointer</em> points to the next instruction to be completed, and the <em>issue pointer</em> points to where new instructions should be written. The commit pointer trails after the issue pointer, and both wrap around when needed.</p>

<p>A ROB entry is allocated for a new instruction when the new instruction is issued, same as when a reservation station is acquired for the instruction.</p>

<p>When using an ROB, the RAT should point to the ROB entry instead of the register.</p>

<p>During the <em>commit phase</em> of Tomasulo&#39;s Algorithm with an ROB, for all instructions from the commit pointer onward that have results ready, the result is written into the target register and the RAT is updated to point to that target register.</p>

<p>On a branch misprediction in Tomasulo&#39;s Algorithm with an ROB, the branch&#39;s entry in the ROB is marked as a misprediction and the issue pointer is moved to the same location as the commit pointer, as if aborting those instructions. Each RAT entry is made to point to the corresponding register instead of the ROB, the reservation stations are freed, and the ALUs are emptied without broadcasting the results.</p>

<p>On an exception in Tomasulo&#39;s Algorithm with an ROB, the exception is treated as any other result and the actual handling of the exception is delayed until the excepting instruction commits.</p>

<p>When committing an instruction&#39;s result, the result is written to the corresponding register, regardless of what the RAT says. However, if the corresponding RAT entry points to the ROB entry, then the RAT entry must be cleared so that further instructions consult the register file instead of the ROB.</p>

<p>A <em>unified reservation station</em> is one where, instead of having separate reservation stations for different execution units (add, mul, etc.) there is one big one to maximize utilization. However, the dispatch and broadcast logic complexity increases.</p>

<p>A <em>superscalar processor</em> is one that simultaneously fetches, decodes, issues, dispatches, broadcasts, and commits more than one instruction per cycle each.</p>

<p>CPU manufacturer terminology differs from issue, dispatch, and commit:</p>

<ul>
<li>issue: issue, allocate, dispatch</li>
<li>dispatch: dispatch, execute, issue</li>
<li>commit: commit, complete, retire, graduate</li>
</ul>

<p>The instruction execution process is:</p>

<ol>
<li>fetch</li>
<li>decode</li>
<li>issue</li>
<li>execute</li>
<li>write result (broadcast)</li>
<li>commit</li>
</ol>

<p>Steps 1-3 (fetch, decode, issue) are done in-order to ensure that discovered dependencies respect the original program order. Steps 4-5 (execute, broadcast) are done out-of-order to enable execution in the order of the data dependencies. Step 6 (commit) is done in-order to give the appearance that instructions are executed in-order.</p>

<p>In a Tomasulo-like scheduling policy, memory writes occur at the commit phase, to ensure that the instruction really will be executed.</p>
<h2 id="load-store-queue">
<span class="hash">#</span>
<a href="#load-store-queue" class="header-link">Load-Store Queue</a>
</h2>
<p>A <em>Load-Store Queue</em> (LSQ) is used to supply values from previous stores to future loads. Each entry contains a load/store bit, memory address, value to be stored in memory or value that was loaded from memory, and a completion bit. Load and store instructions get LSQ entries instead of a reservation station.</p>

<p>When an load entry is added to a Load-Store Queue, the LSQ is checked to see if any previous store entry in the queue matches that address. If so, a store-to-load forwarding is performed to copy the value from that entry without ever having gone to memory.</p>

<p>If a new load entry causes a check of previous store entries for an address match, but one of those store entries hasn&#39;t computed its address yet, then the load goes ahead as if no store entry matched, i.e. it access memory. If the store entry&#39;s address is eventually computed to be the same as the future load, the load will have read a stale value, since it was meant to have read the data written by the store. For this reason, when stores compute their addresses they check subsequent loads to see if they match the address, in which case they are re-triggered.</p>

<p>As soon as a load instruction receives data, it is broadcast to dependent instructions in reservation stations.</p>

<p>Data from a store instruction is sent to memory during the commit phase.</p>

<p>A load/store instruction is committed by freeing the ROB and LSQ entries for it. For stores, the data is also send to memory.</p>

<p>Load/store instructions are executed in address computation and value production, and a store instruction in particular can do those in any order.</p>

<p><em>Tree height reduction</em> is a way for the compiler to help with ILP by exploiting associativity in order to break up larger computations into smaller independent computations, thereby reducing overall dependencies, hence reducing the dependency tree height.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-nasm"><span class="c1">;; input</span>
<span class="nf">r8</span> <span class="err">=</span> <span class="nv">r2</span> <span class="o">+</span> <span class="nv">r3</span> <span class="o">+</span> <span class="nv">r4</span> <span class="o">+</span> <span class="nv">r5</span>
</code></pre></figure><figure class="codeblock">
<pre>
<code class="highlight language-nasm"><span class="c1">;; before</span>
<span class="nf">add</span> <span class="nv">r8</span><span class="p">,</span> <span class="nv">r2</span><span class="p">,</span> <span class="nv">r3</span>
<span class="nf">add</span> <span class="nv">r8</span><span class="p">,</span> <span class="nv">r8</span><span class="p">,</span> <span class="nv">r4</span>
<span class="nf">add</span> <span class="nv">r8</span><span class="p">,</span> <span class="nv">r8</span><span class="p">,</span> <span class="nv">r5</span>
<span class="nf">r8</span> <span class="err">=</span> <span class="p">(</span><span class="nv">r2</span> <span class="o">+</span> <span class="nv">r3</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nv">r4</span> <span class="o">+</span> <span class="nv">r5</span><span class="p">)</span>
</code></pre></figure><figure class="codeblock">
<pre>
<code class="highlight language-nasm"><span class="c1">;; after</span>
<span class="nf">add</span> <span class="nv">r8</span><span class="p">,</span> <span class="nv">r2</span><span class="p">,</span> <span class="nv">r3</span>
<span class="nf">add</span> <span class="nv">r7</span><span class="p">,</span> <span class="nv">r4</span><span class="p">,</span> <span class="nv">r5</span>
<span class="nf">add</span> <span class="nv">r8</span><span class="p">,</span> <span class="nv">r8</span><span class="p">,</span> <span class="nv">r7</span>
</code></pre></figure>
<p><em>Instruction scheduling</em> by the compiler aims to reduce stalls by reordering (usually independent) instructions to maximize ILP.</p>

<p><em>Loop unrolling</em> increases the benefits of instruction scheduling because it increases the window/context of the loop contents, which gives access to more instructions that can be reordered via instruction scheduling.</p>

<p>Loop unrolling decreases the number of instructions that are executed, essentially minimizing the branching overhead.</p>

<p><em>Loop unrolling once</em> refers to modifying a loop so that it does <em>one</em> extra iteration&#39;s-worth of work per iteration, i.e. 2x the normal amount of work. Unrolling twice would mean that that the loop does <em>two</em> extra iteration&#39;s-worth of work per iteration, i.e. 3x the normal amount of work.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span>

<span class="c1">// unrolled once</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>     <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>     <span class="o">+</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<p><em>Function call inlining</em> eliminates call/return overhead and allows for better instruction scheduling because the function&#39;s instructions are inline.</p>

<p>Both loop unrolling and function call inlining increase code size.</p>

<p>A <em>Very Long Instruction Word</em> (VLIW) processor is one that executes one large instruction which does the same work as <script type="math/tex">N</script> &quot;normal&quot; instructions. Examples include Itanium and DSP processors. The advantages are that the compiler does the hard work (via instruction scheduling), so the hardware can be simpler and more energy efficient because there is less to do per instruction (no need to detect dependencies), and they work well on loops and &quot;regular&quot; code. The disadvantages are that the latencies of instructions aren&#39;t always the same, and the compiler can&#39;t predict them (e.g. on a cache miss), most applications are irregular with lots of decisions and branches, and finally there is a large increase in code size due to no-op insertion due to dependencies.</p>
<h1 id="caches">
<span class="hash">#</span>
<a href="#caches" class="header-link">Caches</a>
</h1>
<p>The <em>locality principle</em> states that things that will happen soon are likely to be close to things that just happened. <em>Temporal locality</em> means that if a memory address was accessed recently, it&#39;s likely to be accessed again soon. <em>Spatial locality</em> means that if a memory address was accessed recently, an address close to it is likely to be accessed as well.</p>

<p>A cache&#39;s <em>Average Memory Access Time</em> (AMAT) is the access time to memory as seen by the processor. It&#39;s computed as:</p>

<p><script type="math/tex; mode=display"> \text {AMAT} = \text {hit time} + \text {miss rate} * \text {miss penalty} </script></p>

<p>A cache&#39;s <em>miss time</em> is the overall time it takes to have a cache miss. It&#39;s computed as:</p>

<p><script type="math/tex; mode=display"> \text {miss time} = \text {hit time} + \text {miss penalty} </script></p>

<p>A CPU&#39;s Level 1 (L1) cache is the cache that directly services read/write requests from the processor. It&#39;s usually 16-64KB in size, large enough to get about 90% hit rate, and small enough for the hit time to be about 1-3 cycles.</p>

<p>A <em>cache block</em> or <em>line size</em> is how many bytes are stored in each cache entry. The cache block size should be at least as large as the largest single memory access, but large enough to exploit spatial locality, so that more data is brought in on each access. Typically block sizes on L1 caches are not much bigger than 32-128 bytes because it&#39;s a balance between exploiting spatial locality while minimizing the possibility that space goes wasted when programs don&#39;t exhibit spatial locality.</p>

<p>If the cache block size is smaller than the largest single memory access, then each memory access will incur multiple cache look-ups for each single memory access.</p>

<p>If the cache block size is not much larger than the largest single memory access, then spatial locality will not be exploited because the local data will not fit in the entry.</p>

<p>If the cache block size is very large but the program does not exhibit much spatial locality, then the space is wasted since the data is never used.</p>

<p>In caches, blocks start at block-aligned addresses. For example, for 64 B blocks, block 1 would be 0-63, block 2 would be 64-127, and so on.</p>

<p>On a given memory access, the region of memory that is brought into the cache is the region that contains the data and is block-aligned, that is, the same size as the cache block.</p>

<p>A <em>cache line</em> is a slot into which a cache block fits. To differentiate, the cache block is the actual data fetched from memory which is inserted into a slot called a cache line.</p>

<p>The <em>block number</em> is the block that corresponds to the memory address that is being accessed. It&#39;s determined by dividing the memory address by the block size.</p>

<p><script type="math/tex; mode=display"> \text {block number} = \frac {\text {address}} {\text {block size}} </script></p>

<p>The <em>block offset</em> is the offset into a particular block that corresponds to a particular memory address. This is necessary because each block may contain more than one memory address&#39; data. It&#39;s computed as the remainder of the memory address divided by the block size.</p>

<p><script type="math/tex; mode=display"> \text {block offset} = {\text {address }} \bmod {\text { block size}} </script></p>

<p>The number of bits used in a cache block offset is determined by the size capacity in bytes (if byte-addressable) of a cache line, or <script type="math/tex">\log_2 (\text {cache line byte size})</script>.</p>

<p>The block size should be a power of 2 because it simplifies the process of determining the appropriate block for a particular memory address, which is done by dividing by the block size. Dividing by <script type="math/tex">2^k</script> is just a right-shift by <script type="math/tex">k</script> bits, i.e. discarding the lower <script type="math/tex">k</script> bits determines the block number. This is much simpler and faster than dividing by a non-power of 2.</p>

<p><img src="https://i.imgur.com/jX1dCZp.png" class="center" /></p>

<p>For example, given a block size of <script type="math/tex">2^4</script> = 16 bytes and a 32-bit address, the block offset is the least significant (lower) 4 bits and the block number is the most significant 28 bits.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="c1">// address / 2^4</span>
<span class="n">block_number</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>

<span class="c1">// address % 2^4</span>
<span class="n">block_offset</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span> <span class="c1">// i.e. 0b1111</span>
</code></pre></figure>
<p>For a cache to determine if a block is actually in the cache, it keeps a tag for each cache block. The tag of a given address usually consists of at least one bit from the block number component---even the entire block number can be the tag. On a given memory access, the cache checks to see if the tag for that address is present in the cache, in which case the corresponding cache block contains the data.</p>

<p>In order to prevent garbage data from being used after booting a CPU, the cache keeps a valid bit for each cache line which specifies whether the tag and data are valid. Once data is read from memory, the valid bit is enabled. This way, a hit is successful if the address&#39; tag is present <em>and</em> the valid bit is on.</p>

<p>A cache size is typically expressed as how much data it can contain, but it is actually larger due to cache book-keeping overhead such as storing the tag, valid and dirty bits, LRU counters, etc.</p>

<p>A <em>multi-level cache</em> (cache hierarchy) can help to reduce the miss penalty because additional cache levels are still much faster than accessing memory.</p>

<p>The <em>Last Level Cache</em> (LLC) is the cache with no more caches beneath it, so that misses go directly to memory. For example, in a single-level cache, the L1 cache is the LLC.</p>

<p>A cache&#39;s <em>local hit rate</em> is the hit rate that the cache actually observes for accesses to this particular cache, dependent on the hit rate of the caches above it.</p>

<p><script type="math/tex; mode=display"> \text {local hit rate} = \frac {\text {number of hits}} {\text {number of all accesses to this cache}} </script></p>

<p>A cache&#39;s <em>local miss rate</em> is simply the complement of the local hit rate:</p>

<p><script type="math/tex; mode=display"> \text {local miss rate} = 1 - \text {local hit rate} </script></p>

<p>A cache&#39;s <em>global miss rate</em> is the number of misses in this cache divided by all memory accesses that the CPU makes:</p>

<p><script type="math/tex; mode=display"> \text {global miss rate} = \frac {\text {number of misses in this cache}} {\text {number of all memory accesses made by CPU}} </script></p>

<p>A cache&#39;s <em>global hit rate</em> is simply the complement of the global miss rate:</p>

<p><script type="math/tex; mode=display"> \text {global hit rate} = 1 - \text {global miss rate} </script></p>

<p><em>Misses per 1000 Instructions</em> (MPKI) is a metric of how often the cache hits, which tries to capture the behavior of non-L1 caches:</p>

<p><script type="math/tex; mode=display"> \text {MPKI} = \frac {\text {number of misses in this cache}} {1000} </script></p>

<p><em>Cache inclusion</em> means that if a block is in the L1 cache, then it also has to be in the L2 cache.</p>

<p><em>Cache exclusion</em> means that if a block is in the L1 cache, then it cannot also be in the L2 cache.</p>

<p>If cache inclusion nor cache exclusion is enforced, then if a block is in the L1 cache, it may or may not be in the L2 cache. To maintain the <em>inclusion property</em>, each cache line in L2 needs an <em>inclusion bit</em> which is set if the block is also in L1, so that blocks in L2 that are also in L1 are never replaced.</p>

<p>The benefits of enforcing the inclusion property are that it ensures that an L1 write-back is an L2 hit, or that an L1 write-through actually happens in L2 and not in memory, and it also speeds up coherence since only the L2 needs to be probed: if it&#39;s not in L2, it won&#39;t be in L1, so the L1 doesn&#39;t need to be probed.</p>
<h2 id="direct-mapped-cache">
<span class="hash">#</span>
<a href="#direct-mapped-cache" class="header-link">Direct-Mapped Cache</a>
</h2>
<p>A <em>direct-mapped cache</em> is one where, for a given cache block, there is exactly one cache line where it may go.</p>

<p>A direct-mapped cache can be thought of as a special instance of a set-associative cache where there is a set for each cache line, i.e. a 1-way set associative cache. This way the index bits are still used to determine the cache line.</p>

<p>In a direct-mapped cache, a cache block&#39;s cache line is determined by using some <em>index bits</em>, which are taken from above the block offset component. The number of index bits used is determined by the number of lines in the cache, in particular, <script type="math/tex">\log_2 (\text {total lines})</script>. The tag comprises the rest of the bits, essentially identifying which of all possible blocks that can go in that cache line is actually present.</p>

<p><img src="https://i.imgur.com/j3Q5olI.png" class="center" /></p>

<p>The advantage of a direct-mapped cache is that there is only one place to look-up for a block, making it fast, cheap, and energy-efficient. However, since a given block can only go in <em>one</em> place, it increases contention/conflicts for each cache line, which increases the miss rate.</p>

<p>The cache block offset granularity is in bytes (on x86), or the smallest addressable unit of memory.</p>
<h2 id="set-associative-cache">
<span class="hash">#</span>
<a href="#set-associative-cache" class="header-link">Set-Associative Cache</a>
</h2>
<p>A <em>set-associative cache</em> is one where, for a given cache block, there are <script type="math/tex">N</script> cache lines where it may go. Cache lines are grouped into sets. The number of sets there are is equal to the number of cache lines divided by <script type="math/tex">N</script>. A cache is <em>n-way set-associative</em> when a particular block can be in one of <script type="math/tex">N</script> lines within a unique set. That is, each block maps to a unique set, but may choose among the lines within that set.</p>

<p>The number of index bits used in an n-way set-associative cache is <script type="math/tex">\log_2 (\text {number of sets})</script>.</p>

<p>The associativity of a cache refers to how many cache lines are assigned to each set. More cache lines per set means the cache is more associative.</p>
<h2 id="fully-associative-cache">
<span class="hash">#</span>
<a href="#fully-associative-cache" class="header-link">Fully-Associative Cache</a>
</h2>
<p>A <em>fully associative cache</em> is one where any cache block can be in any cache line, so each tag must be checked in order to see if a block is present.</p>

<p>A fully associative cache can be thought of as a special instance of a set-associative cache where there is one set containing all of the cache lines. This means that there are no index bits, because <script type="math/tex">\log_2(\text {number of sets = 1}) = 0</script>.</p>

<p>An address in a fully associative cache doesn&#39;t require an index component because the tag alone identifies the correct line, since any block can go in any line in a fully associative cache.</p>
<h2 id="cache-replacement">
<span class="hash">#</span>
<a href="#cache-replacement" class="header-link">Cache Replacement</a>
</h2>
<p>Cache line replacement is necessary when a set is full or there was a cache miss and we need to put a new block in the set.</p>

<p>Possible cache replacement policies include random, Round-Robin (FIFO), and Least Recently Used (LRU).</p>
<h3 id="least-recently-used">
<span class="hash">#</span>
<a href="#least-recently-used" class="header-link">Least Recently Used</a>
</h3>
<p>LRU is a good policy because it exploits temporal locality. It works by maintaining an LRU counter that is set to a different count for each cache line in the set. A count of 0 is considered to be the Least Recently Used.</p>

<p>When a block needs to be replaced, the least recently used block of count 0 is replaced, its cache line&#39;s LRU counter is set to the max (i.e. marked MRU), and all other LRU counters are decremented.</p>

<p>When an LRU block is re-accessed, its LRU counter is set to the max (i.e. marked MRU) and all other LRU counters are decremented.</p>

<p>When the MRU block is re-accessed, there is no change.</p>

<p>When a block that&#39;s not the LRU or MRU is accessed, its LRU counter is set to the max (i.e. marked MRU) and all other LRU counters with a count <em>greater</em> than the previous count of this block are decremented.</p>

<p>For an n-way set-associative cache, an LRU implementation requires <script type="math/tex">N</script> counters (one for each cache line) of bit size <script type="math/tex">\log_2 (n)</script>, for each set.</p>

<p>A counter-based LRU cache implementation requires all <script type="math/tex">N</script> counters in the set to be updated on each access, <em>even on cache hits</em>.</p>
<h3 id="not-most-recently-used">
<span class="hash">#</span>
<a href="#not-most-recently-used" class="header-link">Not Most Recently Used</a>
</h3>
<p>Not Most Recently Used (NMRU) is an approximation of LRU which works by tracking which block has been used most recently, then picking a random block aside from that one, so that the just-used block isn&#39;t replaced. This entails keeping one MRU pointer per set. For example, in a 2-way set-associative cache, there would be a 1-bit pointer per set to specify which of the two entries in the set is the MRU. In general, a pointer of size <script type="math/tex">\log_2 (N)</script> is required per set.</p>

<p>NMRU is much cheaper than true LRU because each set only requires one pointer to the MRU, compared to true LRU where each entry in each set requires its own counter.</p>

<p>The main disadvantage of NMRU is that it only keeps track of the MRU and chooses any of the other blocks for replacement, which may not be the actual LRU.</p>
<h3 id="pseudo-least-recently-used">
<span class="hash">#</span>
<a href="#pseudo-least-recently-used" class="header-link">Pseudo-Least Recently Used</a>
</h3>
<p>The Pseudo-LRU (PLRU) replacement policy works by keeping one bit per line in each set. All bits are set to 0, and they are then set to 1 whenever their block is accessed. On replacement, any of the blocks with a 0 bit is eligible for replacement. This essentially means that all of the recently accessed blocks will have a 1 bit.</p>

<p>When the final 0 bit block is replaced and its bit is set to 1, all of the other block&#39;s bits (which should be 1, since this is the last 0 bit block) are set to 0.</p>

<p>The performance of PLRU is between true LRU and NMRU. When there&#39;s only one 0 bit block left, it&#39;s essentially like LRU. When there&#39;s only one 1 bit block, it&#39;s essentially NMRU. And when there are more than one but not all 1 bit blocks, it&#39;s in between.</p>
<h2 id="cache-write-policies">
<span class="hash">#</span>
<a href="#cache-write-policies" class="header-link">Cache Write Policies</a>
</h2>
<p>A cache write policy&#39;s allocate policy concerns whether a block that was written to should be brought into the cache.</p>

<p>A <em>write-allocate cache</em> is one where, when a memory block is written to, it&#39;s also brought into the cache.</p>

<p>A <em>no-write-allocate cache</em> is one where, when a memory block is written to, it&#39;s <em>not</em> brought into the cache.</p>

<p>A <em>write-through cache</em> is one where, when a cache block is written to, the memory is updated immediately.</p>

<p>A <em>write-back cache</em> is one where, when a cache block is written to, the memory isn&#39;t updated until that cache block is replaced. A dirty bit is used to determine if the block was modified since it was placed in the cache, which means that memory has to be updated with its data.</p>

<p>Most modern processors are write-back in order to exploit write-locality and eliminate the cost of sending to memory many times. Most modern processors are write-allocate in order to exploit locality between reads and writes, that is, if we write to something, we&#39;re also likely to read it.</p>

<p>Write-allocate and write-back work together because write-allocate will bring data into memory on a write-miss in order to continue to benefit from write-back (writing only to cache block until it is replaced).</p>
<h2 id="cache-misses">
<span class="hash">#</span>
<a href="#cache-misses" class="header-link">Cache Misses</a>
</h2>
<p>The three main causes of cache misses are the &quot;3C&#39;s&quot; (three C&#39;s): <em>compulsory misses</em>, <em>capacity misses</em>, and <em>conflict misses</em>.</p>

<p>A <em>compulsory miss</em> is a miss incurred when the block is accessed for the first time. It&#39;s compulsory because it <em>has</em> to happen in order to bring the block into the cache for the first time. In other words, it would be a miss even if the cache were of infinite size.</p>

<p>A <em>capacity miss</em> is a miss on a block that was previously evicted because of limited cache size.  In other words, it would be a miss even in a fully-associative cache of the same size, that is, even if there had been many lines to choose from.</p>

<p>A <em>conflict miss</em> is one that occurs due to a conflict within a set, because the block was previously replaced due to limited associativity (not enough lines per set). It would <em>not</em> have been a miss in a fully-associative cache of the same size.</p>
<h2 id="prefetching">
<span class="hash">#</span>
<a href="#prefetching" class="header-link">Prefetching</a>
</h2>
<p><em>Prefetching</em> refers to predicting which blocks will be accessed soon and bringing them into the cache ahead of time, before they&#39;re actually accessed. Prefetching could eliminate cache misses, but mispredictions could lead to cache pollution, which leads to other misses because useful data was replaced.</p>

<p><em>Cache pollution</em> refers to bringing unused junk data into the cache, potentially replacing data that was actually being used.</p>

<p><em>Prefetch instructions</em> are instructions which the compiler or programmer can use to request prefetches.</p>

<p>The correct amount of data to prefetch via prefetch instructions is difficult to get right because it&#39;s largely dependent on hardware, and it&#39;s possible to prefetch too little or too much data.</p>

<p>If the amount of data prefetched is too small, it might arrive long after it&#39;s actually needed, negating the purpose of prefetching.</p>

<p>If the amount of data prefetched is too large, the data may be evicted by the time it&#39;s actually needed.</p>

<p>Furthermore, if the CPU gets faster but the memory doesn&#39;t (as is often the case), the time at which the program needs the data will change, necessitating a change in the amount of data to prefetch.</p>

<p><em>Hardware prefetching</em> is prefetching done by the hardware (e.g. CPU or cache), which requires no changes to the program.</p>

<p>A <em>stream buffer prefetcher</em> is a hardware prefetcher that is sequential in nature. It tries to predict if some sequence of blocks following the one that was just accessed might be accessed next, in which case it tries to prefetch several blocks in advanced.</p>

<p>A <em>stride prefetcher</em> is a hardware prefetcher that tries to determine if memory accesses are at a fixed distance from each other, in which case it prefetches data at subsequent fixed distances <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>.</p>

<p>A <em>correlating prefetcher</em> is a hardware prefetcher that tries to detect patterns of memory access sequences, so that when it detects a repeat of a pattern, it prefetches the remaining sequence up to some number. This is good for linked lists which aren&#39;t sequential in memory nor at fixed strides. Traversing the linked list in the same manner another time would yield a prefetch.</p>
<h2 id="non-blocking-caches">
<span class="hash">#</span>
<a href="#non-blocking-caches" class="header-link">Non-Blocking Caches</a>
</h2>
<p>A <em>non-blocking cache</em> is one that doesn&#39;t block until each operation is finished, unlike a <em>blocking cache</em>.</p>

<p>In a non-blocking cache, a <em>hit-under-miss</em> is when the cache can continue to serve the cache hits while the cache is waiting on a miss.</p>

<p>In a non-blocking cache, a <em>miss-under-miss</em> is when multiple requests to memory can be made even while a cache miss is already underway. This is an example of <em>memory-level parallelism</em> and requires memory hardware support.</p>

<p>For a cache to support miss-under-miss functionality, it requires <em>Miss Status Handling Registers</em> (MSHRs), which remember what was requested from memory (i.e. information about ongoing misses).</p>

<p>On a miss, the MSHRs are checked for a match to determine if it&#39;s a new or existing miss. If it&#39;s a new miss, an MSHR is allocated and it remembers which instruction in the processor to wake up. This is called a <em>miss</em>.</p>

<p>If it&#39;s an existing miss which is under way, and the data hasn&#39;t come back yet, the instruction is added to the existing MSHR for that miss. This is called a <em>half-miss</em>.</p>

<p>When the data finally comes back from memory, all instructions in the MSHR are woken up, then the MSHR is released.</p>

<p>The more MSHRs there are, the more memory-level parallelism that can be leveraged because multiple misses can be serviced at the same time.</p>
<h1 id="virtual-memory">
<span class="hash">#</span>
<a href="#virtual-memory" class="header-link">Virtual Memory</a>
</h1>
<p>Virtual memory is split up into virtual pages because it decreases the size of the page table compared to if each byte in virtual memory mapped to a byte in physical memory.</p>

<p>A virtual address can be split up into two components: the virtual page number and the page offset.</p>

<p>The number of bits used for the virtual page number is dependent on the number of entries in the page table:</p>

<p><script type="math/tex; mode=display"> \text {virtual page number bitsize} = \log_2 (\text {page table size}) </script></p>

<p>The remaining bits are used for the page offset.</p>

<p>A flat page table is one where there is a page table entry for every page number, that is, 1 entry per page in the entire virtual address space, even those regions unused by the program. Each entry contains the frame number and the access bits. The size of a flat page table is:</p>

<p><script type="math/tex; mode=display"> \frac {\text {virtual memory}} {\text {page size}} * \text {entry size} </script></p>

<p>The problem with flat page tables is that they take up space even for virtual address space that isn&#39;t being used by a process. Since a page table exists for each process, this can become prohibitively expensive for much larger address spaces.</p>

<p>A multi-level page table is able to save a lot of space by adding levels of indirection and only allocating the regions of virtual address space that are actually used.</p>

<p>A virtual address is broken down into the virtual page number and page offset as usual, but the page number is broken down further into outer and inner indices into the multi-level page table.</p>

<p>Larger page sizes lead to smaller page tables but increased internal fragmentation. Smaller page sizes lead to larger page tables.</p>

<p>On each memory access, the processor needs to:</p>

<ul>
<li>compute the virtual address</li>
<li>compute its page number</li>
<li>compute the physical address of the page table entry, given the current page table address and the virtual page number</li>
<li>read the page table entry</li>
<li>compute the physical address</li>
<li>access the cache (or memory if cache miss)</li>
</ul>

<p>On a multi-level page table, for each level, the processor needs to:</p>

<ul>
<li>compute the physical address of the page table entry, given the current page table address and the virtual page number</li>
<li>read the page table entry</li>
<li>compute the physical address</li>
</ul>

<p>Without a <em>translation look-aside buffer</em> (TLB), virtual-to-physical address translation is expensive because on multi-level page tables, a mere virtual-to-physical address translation incurs multiple memory accesses because the page tables reside in memory. All this before the actual physical address can be read, which itself is yet another memory access.</p>

<p>A TLB is necessary instead of just using the CPU cache for caching translations because the cache is very big and is mostly for data, whereas a single virtual-to-physical address translation covers an entire page-worth of data, so a specialized cache like the TLB can be much smaller. Further, the general CPU cache would cache each intermediate result from a multi-level page table translation, whereas the TLB only needs to store the translation result.</p>

<p>When there&#39;s a TLB miss, the actual translation is made manually using the page tables, and the final result is inserted into the TLB.</p>

<p><em>Software TLB-miss handling</em> is when it is the operating system&#39;s responsibility to handle a TLB miss, including performing the translation manually. This also means that the operating system can use any representation for the page table, since it&#39;s the only one that is using it.</p>

<p><em>Hardware TLB-miss handling</em> is when the processor automatically reads page tables and updates the TLB on a miss. This is much faster than software TLB miss handling, and it requires that the page tables be in a form that the hardware expects.</p>

<p>A TLB is typically fully or highly associative. Since it&#39;s already very small and thus fast, it&#39;s not necessary to make it directly-mapped as that would increase the miss rate.</p>

<p>The TLB size should be large enough to cover more memory than the cache, so that the TLB hits at least as often as the cache. For example, 64-512 entries. If more space is required, making the a single TLB larger would make it slower, so instead a two-level TLB is used, where L1 is small and fast and L2 is slightly slower but much larger, yet still faster than manually performing the translation.</p>

<p>The three main methods of improving cache performance are those that reduce the AMAT: reducing the hit time, miss rate, and miss penalty.</p>

<p>Reducing the hit time of a cache can be accomplished by:</p>

<ul>
<li>reducing the cache size (though bad for miss rate)</li>
<li>reducing the cache associativity (though bad for miss rate)</li>
<li>overlapping cache hits with each other</li>
<li>overlapping cache hits with TLB hits</li>
<li>optimizing lookup for the common case</li>
<li>maintaining replacement state more quickly</li>
</ul>

<p>Cache hits can be overlapped/coalesced by pipelining the cache.</p>

<p>Hit time is affected by the TLB hit latency because the TLB has to be accessed before the cache can be accessed, in order to get the physical address used to search the cache. The overall cache hit latency is the TLB hit latency plus the cache hit latency:</p>

<p><script type="math/tex; mode=display"> \text {overall cache hit latency} = \text {TLB hit latency } + \text { cache hit latency} </script></p>

<p>A <em>Physically Indexed, Physically Tagged</em> (PIPT) cache (aka <em>Physically Accessed Cache</em>, aka <em>Physical Cache</em>) is one that is accessed using a physical address.</p>

<p>A <em>Virtually Accessed cache</em> is one that is accessed using the virtual address. On a cache miss, the TLB is checked for the physical address to bring that data into the cache. Realistically, the TLB still needs to be checked to get the address&#39; permission bits. The advantage is that the hit time is now just the cache hit time, since there&#39;s no need to look-up the TLB first. However, the TLB still has to be accessed to retrieve for example the permission bits, and the cache must be flushed on each context switch since virtual addresses are specific to a single process.</p>

<p>A <em>Virtually Indexed, Physically Tagged</em> cache is one that is indexed by the virtual address&#39; index bits, while the tag bits come from the physical address. The virtual address&#39; tag bits are used to get the frame number from the TLB. The cache block&#39;s tag is then compared to the physical address to determine a hit or miss. The cache and TLB look-ups are done in parallel.</p>

<p>The advantages of a virtually indexed, physically tagged cache are that, since the cache and TLB look-ups are done in parallel, and the TLB is usually small and fast, the total latency is usually just the cache hit time. Unlike a virtually indexed, virtually tagged cache, the cache doesn&#39;t need to be flushed on each context switch because although the cache is indexed by the virtual address&#39; index bits, a hit is determined by the physical address&#39; tag bits. Aliasing is not a problem if the cache is small enough.</p>

<p>The disadvantage of a virtually indexed, physically tagged cache is that aliasing can be a problem, i.e. when multiple virtual addresses map to the same physical address, but they would each get their own separate entries, so a write to one may not be seen by the others. This requires additional handling which might negate the aforementioned performance gains.</p>

<p>Aliasing can be avoided. Since a virtual address&#39; page offset is the same as the physical address&#39; frame offset---since pages and frames are the same size---if the cache&#39;s index bits are taken from the same region as the page offset bits, then aliasing will not occur, because any number of virtual addresses that map to the same physical address will contain the same page offset, after all, it&#39;s the virtual page number that differs, not the offset into the page/frame. This means that any aliased virtual addresses will map to the same cache line.</p>

<p>The cache size must be restricted by the number of page offset bits and the cache block offset bits. Specifically, the number of index bits must be:</p>

<p><script type="math/tex; mode=display"> \text {index bit size} = \text {page offset bits } - \text { cache block offset bits}</script></p>

<p>For example, given a 4 KB page and 32 B cache blocks, there will be a 12-bit page offset since <script type="math/tex">\log_2 (4096) = 12</script> and a 5-bit block offset since <script type="math/tex">\log_2 (32) = 5</script>, resulting in a 7-bit index since 12 - 5 = 7, which amounts to <script type="math/tex">2^7 = 128</script> sets.</p>

<p>The only way to increase the cache size while preventing aliasing in a virtually indexed, physically tagged cache, given that the maximum number of index bits are already being used, is to increase the associativity of the cache. For example, going from a 2-way set-associative cache to a 4-way set-associative cache. However, this increases latency since it introduces more blocks that must be checked for a hit.</p>

<p><em>Way prediction</em> refers to predicting which line is most likely to hit based on the index bits, instead of checking all of the cache lines in the set. If there is a misprediction, then all other lines are checked as usual.</p>
<h1 id="loop-interchange">
<span class="hash">#</span>
<a href="#loop-interchange" class="header-link">Loop Interchange</a>
</h1>
<p><em>Loop interchange</em> is when a compiler modifies a nested loop in order to better exploit spacial locality. This is only possible if the compiler can prove that the rearrangement is equivalent to the original code.</p>

<p>For example, if a loop traverses a 2D array in column-major order (first element of the first row, first element of the second row, etc.), loop interchange would change it to row-major order.</p>

<p>Before:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></figure>
<p>After:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></figure><h1 id="memory">
<span class="hash">#</span>
<a href="#memory" class="header-link">Memory</a>
</h1>
<p><em>Static Random Access Memory</em> (SRAM) is memory that retains its data (hence <em>static</em>) while power is supplied. On the other hand, <em>Dynamic Random Access Memory</em> (DRAM) is memory that will lose the data (hence <em>dynamic</em>) if it&#39;s not refreshed.</p>

<p>SRAM is more expensive than DRAM because it requires several transistors per bit, meaning a lot less data per unit area than DRAM. SRAM is also typically faster than DRAM.</p>

<p>DRAM is cheaper than SRAM because it only requires one transistor per bit, meaning a lot more data per unit area than SRAM. DRAM is also typically slower than SRAM.</p>

<p>Since a DRAM bit&#39;s capacitor slowly leaks through the transistor, it&#39;s necessary to periodically read out the bit and write it back at full voltage.</p>

<p>A <em>destructive read</em> refers to the fact that reading the value drains the capacitor, so the bit loses its value, which means it needs to be written back.</p>
<h1 id="hard-disks">
<span class="hash">#</span>
<a href="#hard-disks" class="header-link">Hard Disks</a>
</h1>
<p>In a hard disk, all platters rotate at the same speed because they&#39;re attached to the same spindle, which moves them all at the same time.</p>

<p>There are surfaces on both sides of each hard disk platter. Data is read from the magnetic surfaces by a magnetic head attached to an arm. Each surface&#39;s head is attached to the head assembly. The head assembly moves the heads in unison, i.e. they&#39;re all in the same position, reading the same track.</p>

<p>A <em>cylinder</em> is the collection of tracks accessible from the current position of each of the heads, as determined by the head assembly.</p>

<p>A <em>track</em> is the circle of data accessible from the current head position. There are many concentric tracks on each platter surface.</p>

<p>Data is stored on a track in individual chunks (or <em>frames</em>) called <em>sectors</em>. At the beginning of the sector is a recognizable bit pattern called a <em>preamble</em> which marks the beginning of the sector, followed by the actual data, and ending with checksums and other metadata. Sectors are the smallest unit of data that can be accessed.</p>

<p>A hard disk finds a particular sector on a track by first moving the head to the track, then reading the track until it finds a sector, which includes the sector&#39;s position and number, so that the head knows how far to skip to get to the target.</p>

<p>Hard disk capacity can be computed as:</p>

<p><script type="math/tex; mode=display"> \text {disk capacity} = \text {# of surfaces } * \text { tracks per surface } * \text { bytes per sector} </script></p>

<p><em>Seek time</em> is the amount of time it takes to move the head assembly to the correct cylinder so that one of the heads is above the track that contains the data.</p>

<p><em>Rotational latency</em> is the amount of time it takes for the start of the target sector to be under the head.</p>

<p>A <em>data read</em> refers to reading until the end of the sector seen by the head. It depends on how fast the disk is spinning, and how many sectors there are per track. For example, if there are 10 sectors on a track, a data read of one sector will be a tenth of the rotation.</p>

<p>The <em>controller time</em> is the time it takes for the disk to complete its overhead, for example verifying the checksum.</p>

<p>The <em>I/O bus time</em> is the time it takes for the data to arrive at memory once it has been read by the disk.</p>
<h2 id="fault-tolerance">
<span class="hash">#</span>
<a href="#fault-tolerance" class="header-link">Fault Tolerance</a>
</h2>
<p>A <em>fault</em> is when something inside the system deviates from specified behavior.</p>

<p>An <em>error</em> is when the actual behavior in the system deviates from the specific behavior.</p>

<p>A <em>failure</em> is when the system deviates from specified behavior.</p>

<p>A <em>latent error</em> is an error that is eventually activated.</p>

<p>An <em>activated fault</em> becomes an <em>effective error</em>.</p>

<p>For example, a function that works fine except for a specific input is an example of a <em>fault</em>, or <em>latent error</em>.</p>

<p>When a function yields an incorrect result for some input and it&#39;s called with that input, that is an example of an error, specifically an <em>effective error</em>, due to an <em>activated fault</em>.</p>

<p>If a scheduling system calls a function that returns an incorrect input for some input, which leads to a scheduling mistake, that is an example of a <em>failure</em>, because the system (the scheduling system) deviated from the system behavior.</p>

<p><em>Dual-mode redundancy</em> is a way to detect errors by comparing the results of 2 modules.</p>

<p><em>Triple-mode redundancy</em> is a way of detecting <em>and recovering</em> from errors by having modules vote on the correct result.</p>

<p><em>Parity</em> is an error detection method which stores an extra bit, where the bit is the XOR of all of the data bits. If one bit flip or an odd number of bit flips occurs, the parity bit will be incorrect and an error would be detected.</p>

<p>Fault tolerance for memory and storage can be accomplished by error detection and correction codes, such as parity.</p>

<p>An <em>Error Correction Code</em> (ECC) is a way of both detecting and correcting data.</p>

<p><em>Single Error Correction, Double Error Correction</em> (SECDED) is an ECC method which can detect and fix one bit flip, or detect (but not fix) two bit flips.</p>
<h2 id="redundant-array-of-independent-disks">
<span class="hash">#</span>
<a href="#redundant-array-of-independent-disks" class="header-link">Redundant Array of Independent Disks</a>
</h2>
<p><em>Redundant Array of Independent Disks</em> (RAID) are a variety of methods of having several disks act as one disk. Each disk still detects errors using error codes.</p>

<p>The goals of RAID are better performance and normal read/write accomplishment despite bad sectors and entire disk failures.</p>
<h3 id="raid-0">
<span class="hash">#</span>
<a href="#raid-0" class="header-link">RAID 0</a>
</h3>
<p>Since each individual disk can only access one track at a time before going to the next one, accessing a sequence of tracks is slowed by having to do them one after another.</p>

<p>RAID 0 &quot;stripes&quot; the data so that track 0 is on one disk, track 1 is on another, track 2 is on another, and so on, so that they could each be accessed simultaneously compared to if they were each on the same disk.</p>

<p>A <em>stripe</em> is a collection of tracks that can be accessed simultaneously across the disk array.</p>

<p>RAID 0 multiplies the data throughput by the number of disks in the array. For example, a three-disk array multiplies throughput by 3.</p>

<p>RAID 0 improves performance but reduces reliability.</p>

<p>RAID 0 degrades reliability since the failure of any one of the disks in the array causes the data to be lost. It has the effect of dividing the <em>Mean Time to Failure</em> (MTTF) by the number of disks in the array.</p>

<p>The storage capacity of a RAID 0 array is the total storage of all disks in the array.</p>
<h3 id="raid-1">
<span class="hash">#</span>
<a href="#raid-1" class="header-link">RAID 1</a>
</h3>
<p>RAID 1 works by mirroring the data so that the same data is written to all disks in the array. Data can then be read from any of the disks in the array.</p>

<p>The write time is essentially the same as having just one disk, since all disks perform the write at the same time.</p>

<p>RAID 1 multiplies the data throughput by the number of disks in the array, since the data to read can be split among all of the disks since they each contain copies.</p>

<p>RAID 1 increases reliability since copies of the data exists on each disk in the array. Error correction also increases because the error can be detected by the disk as usual and fixed by reading from another disk.</p>

<p>The storage capacity of a RAID 1 array is the minimum storage capacity of the disks. For example if they&#39;re all 200 GB but one is 100 GB, then the capacity of the RAID 1 array is 100 GB.</p>
<h3 id="raid-4">
<span class="hash">#</span>
<a href="#raid-4" class="header-link">RAID 4</a>
</h3>
<p>RAID 4 works via <em>block-interleaved parity</em>. Of the <script type="math/tex">N</script> disks, <script type="math/tex">N - 1</script> contain striped data as in RAID 0, while the last disk has parity blocks. The tracks of each stripe are XORed to compute the corresponding parity block. If one disk fails, the remaining disks and the parity block can be XORed to reconstruct the data of the failed disk.</p>

<p>RAID 4 multiplies the data read throughput by <script type="math/tex">N - 1</script>, i.e. ignoring the parity disk.</p>

<p>The data write throughput of RAID 4 is half the throughput of one disk, because it requires two accesses for every write. This is because the parity disk has to be accessed to read the old value and the new value has to be written back.</p>
<h3 id="raid-5">
<span class="hash">#</span>
<a href="#raid-5" class="header-link">RAID 5</a>
</h3>
<p>RAID 5 works by <em>distributed block-interleaved parity</em>. Unlike RAID 4, the parity blocks are spread among all disks. For each stripe, the disk that stores that stripe&#39;s parity is the next disk from the one that did so previously, and all other disks store the stripe of the data.</p>

<p>RAID 5 multiplies data read throughput by the number of disks in the array.</p>

<p>Four accesses are necessary per write, specifically:</p>

<ol>
<li>read data block</li>
<li>read parity</li>
<li>write data block</li>
<li>write parity</li>
</ol>

<p>However, each of those accesses is distributed among all of the disks, so that the write throughput is:</p>

<p><script type="math/tex; mode=display"> \text {write throughput} = \frac N 4 * \text { throughput of 1 disk} </script></p>

<p>RAID 5 has the same reliability as RAID 4: it fails if more than one disk fails, but if only one disk fails, it can be reconstructed from the remaining data.</p>

<p>The storage capacity of a RAID 5 array is:</p>

<p><script type="math/tex; mode=display"> \text {total storage} = \text {total sum } - \text { total parity data} </script></p>

<p>Essentially one disk&#39;s worth of storage is spent on parity.</p>
<h3 id="raid-6">
<span class="hash">#</span>
<a href="#raid-6" class="header-link">RAID 6</a>
</h3>
<p>RAID 6 works similar to RAID 5 but stores two parity blocks per stripe: one parity block and another check-block, so that it can tolerate 2 failed disks. If one disk fails, parity is used to reconstruct it. If two disks fail, equations are solved to reconstruct them.</p>

<p>The advantage of RAID 6 over RAID 5 is that it can handle two disk failures, for when it&#39;s likely that the second disk fails <em>before</em> the first disk is replaced. However, RAID 6 has twice the overhead, and more write overhead, since there are two parity blocks that have to be updated each time, meaning 6 accesses per write versus the 4 of RAID 5.</p>
<h1 id="cache-coherence">
<span class="hash">#</span>
<a href="#cache-coherence" class="header-link">Cache Coherence</a>
</h1>
<p><em>Flynn&#39;s Taxonomy on Parallel Machines</em> is a taxonomy based on the number of instruction streams and the number of data streams.</p>

<table>
<thead>
<tr>
<th style="text-align: left">&nbsp;</th>
<th style="text-align: left">Instruction Streams</th>
<th style="text-align: left">Data Streams</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Single Instruction, Single Data (SISD)</td>
<td style="text-align: left">1</td>
<td style="text-align: left">1</td>
</tr>
<tr>
<td style="text-align: left">Single Instruction, Multiple data (SIMD)</td>
<td style="text-align: left">1</td>
<td style="text-align: left">&gt; 1</td>
</tr>
<tr>
<td style="text-align: left">Multiple Instruction, Single Data (MISD)</td>
<td style="text-align: left">&gt; 1</td>
<td style="text-align: left">1</td>
</tr>
<tr>
<td style="text-align: left">Multiple Instruction, Multiple Data (MIMD)</td>
<td style="text-align: left">&gt; 1</td>
<td style="text-align: left">&gt; 1</td>
</tr>
</tbody>
</table>

<p>A uniform access, aka symmetric multiprocessor, aka centralized shared memory multiprocessor, is one where all cores can access the same main memory with uniform memory access (UMA) time, because the main memory is at the same distance from each core.</p>

<p>The problem with centralized main memory is that there is higher memory bandwidth contention due to misses from all cores, which creates a bottleneck on the cores doing their work.</p>

<p>Distributed memory is when only one core can access a memory slice and the others can&#39;t, so that each core&#39;s access time to each memory slice is non-uniform.</p>

<p>With simultaneous multi-threading (SMT), the processor is able to mix instructions from different threads in the same cycle.</p>

<p>In SMT, if the cached data of two threads don&#39;t have much in common and don&#39;t both fit in the cache at the same time, <em>code thrashing</em> may occur because each thread will keep cache missing and bringing in data, potentially kicking out the other thread&#39;s data, and the other thread may do the same. In this scenario, the performance of SMT can be---and usually is---significantly worse than processing the threads one at a time.</p>

<p>A <em>private cache</em> is a cache that is specific to a core, i.e. a per-core cache.</p>

<p>A shared memory system is <em>incoherent</em> when the same memory location has different values from the perspectives of different cores.</p>

<p>Caches are <em>coherent</em> if:</p>

<ol>
<li>read <script type="math/tex">R</script> from address <script type="math/tex">X</script> on core <script type="math/tex">C_1</script> returns the value written by the most recent write <script type="math/tex">W</script> to <script type="math/tex">X</script> on <script type="math/tex">C_1</script> if no other core has written to <script type="math/tex">X</script> between <script type="math/tex">W</script> and <script type="math/tex">R</script>.</li>
<li>if <script type="math/tex">C_1</script> writes to <script type="math/tex">X</script> and <script type="math/tex">C_2</script> reads after some time, and there are no other writes in-between, <script type="math/tex">C_2</script>&#39;s read returns the value from <script type="math/tex">C_1</script>&#39;s write</li>
<li>writes to the same location are serialized: they must be seen to occur in the same order on all cores</li>
</ol>

<p><em>Write-update coherence</em> is when writes are broadcast to update other caches.</p>

<p><em>Write-invalidate coherence</em> is when writes invalidate other copies.</p>

<p><em>Snooping coherence</em> is when writes are broadcast on a shared bus, so that caches &quot;snoops&quot; on the writes.</p>

<p><em>Directory coherence</em> is when each block is assigned an ordering point in order to maintain a consistent write order.</p>

<p>Write-update coherence can be optimized with respect to the number of memory writes by giving a dirty bit an additional meaning. Caches snoop on the bus for reads as well, and when a read is detected for data that it has modified (i.e. is dirty), it serves that data over the bus, avoiding a slower memory access.</p>

<p>If a previously served dirty block in cache <script type="math/tex">A</script> is modified/dirtied by another cache <script type="math/tex">B</script>, cache <script type="math/tex">B</script>&#39;s write is broadcast over the bus and is picked up by <script type="math/tex">A</script>, but now <script type="math/tex">A</script> unsets the dirty bit, essentially relinquishing ownership of the block to cache <script type="math/tex">B</script>.</p>

<p>Write-update coherence can be optimized with respect to the number of bus writes by adding a share bit to each block, denoting whether the block is shared with other caches (i.e. other caches contain copies of that block).</p>

<p>If cache <script type="math/tex">A</script> has a block and it snoops that another cache <script type="math/tex">B</script> reads or writes to that block, cache <script type="math/tex">A</script> sets the block&#39;s shared bit to 1 and alters the bus so that when <script type="math/tex">B</script> receives the data, it knows that the block is shared and sets its shared bit to 1 as well.</p>

<p>When a write hit occurs, the write is only broadcast over the bus if the shared bit is 1, since that would mean that other caches would need to be aware of that write in order to remain coherent.</p>

<p>Write-invalidate snooping coherence works such that, when cache <script type="math/tex">A</script> reads a block and cache <script type="math/tex">B</script> writes to that block, cache <script type="math/tex">A</script> snoops the read on the bus and invalidates the block by setting its valid bit to 0.</p>

<p>Most modern processors use write-invalidate coherence because it better handles situations where a thread moves to another core. With write-update, the thread&#39;s cache data in the previous core&#39;s cache will continue to be updated even though it&#39;s no longer needed there.</p>

<p>Given a memory access pattern of a burst of writes to one address, write-invalidate is the better cache coherence policy because the first write will invalidate the other copies only once, whereas write-update would send the update over the bus on each write.</p>

<p>Given a memory access pattern of writes to different words in the same block, write-invalidate is the better cache coherence policy because it invalidates all other copies only once on the first write, whereas write-update will send the update over the bus for each word write.</p>

<p>Given a memory access pattern of producer-consumer on separate cores, write-update is the better cache coherence policy because the producer sends updates which enables consumer reads to be cache hits. On the other hand, write-invalidate will cause the producer to invalidate the consumer&#39;s copy each time it writes.</p>

<p>Given the situation of a thread moving from one core to another, write-invalidate is the better cache coherence policy because the old core&#39;s cache blocks will be invalidated only once the first time they&#39;re updated. On the other hand, write-update will continue to update the old core&#39;s cache on each write to the blocks even though they&#39;re no longer being used, until those blocks are replaced.</p>

<p>A <em>coherence miss</em> is a cache miss caused by cache coherence. For example:</p>

<ol>
<li>core 1 reads a block</li>
<li>core 2 writes to the same block</li>
<li>core 1 attempts to read the block again, but it has been invalidated, so it has a cache miss</li>
</ol>

<p>A <em>true sharing coherence miss</em> is when different cores access the same data.</p>

<p>A <em>false sharing coherence miss</em> is when different cores access different data, but within the same block. It occurs because cache coherence operates at the cache block level.</p>

<p>As the number of cores increases, coherence traffic also increases because each core will have invalidations and misses.</p>
<h2 id="msi-coherence">
<span class="hash">#</span>
<a href="#msi-coherence" class="header-link">MSI Coherence</a>
</h2>
<p><em>MSI Coherence</em> is named after the 3 states that it allows a cache block to be in: Modified, Shared, and Invalid.</p>

<p>If a block in <em>shared state</em> is read, it remains in <em>shared state</em>. This is considered a local read.</p>

<p>If a block in <em>modified state</em> is written or read, it remains in <em>modified state</em>, because we can be sure that any other copies have been invalidated. This is considered a local read/write.</p>

<p>A block in <em>modified state</em> has its valid and dirty bits on.</p>

<p>A block in <em>invalid state</em> has a valid bit of 0, so that the value of the dirty bit doesn&#39;t matter.</p>

<p>If a block in <em>invalid state</em> is written to, it transitions to the <em>modified state</em> while putting the write on the bus in order to invalidate all other copies.</p>

<p>If a block is in <em>modified state</em> and it snoops on the bus that another cache wrote to that block, it transitions to the <em>invalid state</em> (i.e. it becomes invalidated). This modified block is also write-back&#39;ed so that the other cache that wrote to the block and thus invalidated this block gets this modified/dirty data.</p>

<p>If a block is in <em>modified state</em> and it snoops on the bus that another cache read that block, it transitions to the <em>shared state</em>, because the block copy is not the only one anymore. This modified block is also write-back&#39;ed so that the other cache that read the block gets this modified/dirty data.</p>

<p>A block in <em>shared state</em> has a valid bit of 1 and dirty bit of 0.</p>

<p>If a processor places a read request of a block that is in the <em>invalid state</em>, the block transitions to the <em>shared state</em>. It also places the read request on the bus so that the data may be served by a block transitioning from the <em>modified state</em> to the <em>shared state</em> if there is any such block, or from memory if not.</p>

<p>If a block is in the <em>shared state</em> and snoops on the bus that another cache wrote to that block, it transitions to the <em>invalid state</em>.</p>

<p>If a block is in the <em>shared state</em> and is written to (local write), then the block transitions to the <em>modified state</em>. It also puts an invalidation on the bus.</p>

<p><img src="https://i.imgur.com/iRjEHE2.png" class="center" /></p>

<p>A <em>cache-to-cache transfer</em> works as follows:</p>

<ol>
<li>core 1 has block <script type="math/tex">B</script> in <em>modified state</em></li>
<li>core 2 puts a read request for <script type="math/tex">B</script> on the bus</li>
<li>core 1 has to provide the data since it contains local modifications not yet available in memory</li>
</ol>

<p>An <em>abort-and-retry cache-to-cache transfer</em> works as follows:</p>

<ol>
<li>core 1 cancels core 2&#39;s request (abort bus signal)</li>
<li>core 1 can do a normal write-back to memory</li>
<li>core 2 retries, getting the data from memory</li>
</ol>

<p>The disadvantage of an abort-and-retry cache-to-cache transfer is that it incurs <em>twice</em> the memory latency: once for the write-back from core 1 and again for the read from core 2.</p>

<p>An <em>intervention cache-to-cache transfer</em> works as follows:</p>

<ol>
<li>core 1 snoops on the bus for the read request</li>
<li>core 1 tells main memory that it will supply that data instead (known as an <em>intervention signal</em>) so that the memory shouldn&#39;t respond</li>
<li>core 1 responds with its local copy of the data</li>
<li>main memory must pick up the data in order to update memory, since otherwise both blocks will be in the shared state (with dirty bit unset)</li>
</ol>

<p>The disadvantage of an intervention cache-to-cache transfer is that it requires more complex hardware.</p>
<h2 id="mosi-coherence">
<span class="hash">#</span>
<a href="#mosi-coherence" class="header-link">MOSI Coherence</a>
</h2>
<p>Memory writes can be avoided on cache-to-cache transfers by introducing an <em>owned state</em> to the MSI coherence state machine, hence <em>MOSI coherence</em>.</p>

<p>Among all shared blocks in the <em>shared state</em>, one of the caches will be the owner, so that for that particular cache, the block is in the <em>owned stated</em>.</p>

<p>When another cache requests/reads the block, the owner can respond in order to avoid a memory read.</p>

<p>When the owner replaces the block, it&#39;s in charge of write-back.</p>

<p>If a block is in the <em>modified state</em> and snoops a read, the data is provided and it transitions to the <em>owned state</em>, instead of transitioning to the <em>shared state</em> as in MSI coherence. The other read blocks do transition to the <em>shared state</em>. Unlike MSI, the data is not write-back&#39;ed.</p>

<p>If a block is in the <em>owned state</em> and snoops a read, it provides the data.</p>

<p>If a block is in the <em>owned state</em> and it&#39;s replaced by the cache, it must be write-back&#39;ed.</p>

<p>With respect to thread-private data, even though the data is thread-private and so will never be shared with another core, it has to go through a sequence of transitions before it converges/arrives at the <em>modified state</em>, specifically:</p>

<ol>
<li>invalid state</li>
<li>cache miss</li>
<li>shared state</li>
<li>invalidated</li>
<li>modified state</li>
</ol>
<h2 id="mesimoesi-coherence">
<span class="hash">#</span>
<a href="#mesimoesi-coherence" class="header-link">MESI/MOESI Coherence</a>
</h2>
<p>MSI and MOSI coherence can be optimized for thread-private data by introducing an <em>exclusive state</em>, hence <em>MESI/MOESI Coherence</em>.</p>

<p>When a block is read and the cache detects that it&#39;s the only copy of that block in all of the caches, it transitions from the <em>invalid state</em> to the <em>exclusive state</em>. It can then transition straight to the modified state on a write.</p>

<p><img src="https://i.imgur.com/vahUw1S.png" class="center" /></p>

<p>If a block is in the <em>exclusive state</em> and it&#39;s written to, it transitions to the <em>modified state</em>.</p>

<p>If a block is in the <em>exclusive state</em> and it snoops a read, then it&#39;s no longer the only copy of that block in all of the caches, so it transitions to the <em>shared state</em>.</p>
<h2 id="directory-based-coherence">
<span class="hash">#</span>
<a href="#directory-based-coherence" class="header-link">Directory-based Coherence</a>
</h2>
<p><em>Directory-based coherence</em> is a coherence policy that recognizes that the bus can be a bottleneck when there is a large number of cores (e.g. 8-16 cores). A <em>directory</em> is a structure that is distributed across all cores so that each core gets a <em>slice</em> of the directory which serves a set of blocks <sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>.</p>

<p>The directory has one entry for each block it serves which tracks which caches have that block. Specifically it contains a dirty bit specifying whether the block is dirty in some cache and 1 bit for each cache denoting that the block is in that cache, i.e. a <a href="https://en.wikipedia.org/wiki/Bitmap_index">bitmap index</a>.</p>

<p>Directory-based coherence essentially works by having an index (the directory) that is address-range-based partitioned among each core. All requests go to the partition (a <em>home slice</em>) that manages a block address. The index entry is itself another index (a bitmap) specifying which caches contain the block (if any) and if the block may be dirty. The entry is updated to reflect any MESI/MOESI state transitions.</p>
<h1 id="synchronization">
<span class="hash">#</span>
<a href="#synchronization" class="header-link">Synchronization</a>
</h1>
<p>An <em>atomic exchange instruction</em> is an instruction that atomically swaps the data in the operands.</p>

<p><em>Load Linked/Store Conditional</em> (LL/SC) instructions are a pair of instructions that work together. The <em>Load Linked</em> (LL) instruction is like any other instruction but it saves the address it loaded into a <em>link register</em>. The <em>Store Conditional</em> (SC) instruction checks if the address of its destination is the same as the one in the link register. If so, it does a normal <em>store</em> and returns 1, otherwise if returns 0. This ensures atomicity by relying on coherence to zero out the link register based on the operand to link load.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-nasm"><span class="nf">LL</span> <span class="nv">r1</span><span class="p">,</span> <span class="nv">lockvar</span>
<span class="nf">SC</span> <span class="nv">r2</span><span class="p">,</span> <span class="nv">lockvar</span>
</code></pre></figure>
<p>Atomic reads/writes in the same instruction are bad for pipelining because it requires multiple memory stages in the pipelining in order to perform both the read and the write instead of just one of those.</p>

<p>Single-variable atomic operations can be implemented in terms of load linked/store conditional (LL/SC) by surrounding the operation with LL/SC, then checking the return value of SC to determine if the operation was not interrupted. If it was, the operation is retried until success. For example, atomic increment:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-nasm"><span class="nl">try:</span>
 <span class="nf">LL</span> <span class="nv">r1</span><span class="p">,</span> <span class="nv">var</span>
 <span class="nf">r1</span><span class="o">++</span>
 <span class="nf">sc</span> <span class="nv">r1</span><span class="p">,</span> <span class="nv">var</span>
 <span class="nf">if</span> <span class="p">(</span><span class="nv">r1</span> <span class="err">==</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">goto</span> <span class="nv">try</span>
</code></pre></figure>
<p>Implementing a spinlock with an unconditional atomic exchange is bad because the cores that are spinning on the lock continuously perform unconditional yet inconsequential writes. The writes generate a lot of coherence traffic on the bus, using up a lot of power and closing down cache misses further on the processor doing the actual work.</p>

<p>A way of improving an atomic exchange implementation of a spinlock is to preced the atomic exchange with another busy loop on the lock variable, so that the exchange is only attempted once the lock variable is observed to be free. This leverages cache hits and cache coherence:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-cpp"><span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">lockvar</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">EXCH</span> <span class="n">r1</span><span class="p">,</span> <span class="n">lockvar</span>
<span class="p">}</span>
</code></pre></figure>
<p>A barrier can be implemented with a counter variable that counts arriving threads and ready flag that is set when all threads have arrived. The ready flag is set to a thread-local value which starts the same and alternates independently each time it enters a new barrier, in order to ensure that the barrier is reusable.</p>

<p><img src="http://i.imgur.com/u1VW97a.png" class="center" /></p>
<h1 id="memory-consistency">
<span class="hash">#</span>
<a href="#memory-consistency" class="header-link">Memory Consistency</a>
</h1>
<p>The order of accesses to the <em>same address</em> is defined by <em>coherence</em>.</p>

<p>The order of accesses to <em>different addresses</em> is defined by <em>memory consistency</em>.</p>

<p><em>Sequential memory consistency</em> means that the accesses from one core are not reordered, but there could be many possible interleavings of accesses from different cores.</p>

<p>A possible implementation of sequential consistency would have to ensure that a core performs the next access only when all previous accesses are complete, which would mean poor performance.</p>

<p>It would be better if it re-orders a sequence of loads. So for example, load <script type="math/tex">A</script> and load <script type="math/tex">B</script> gets re-ordered to load <script type="math/tex">B</script> and load <script type="math/tex">A</script>, then the coherence traffic must be monitored to see if a write to <script type="math/tex">B</script> occurs before load <script type="math/tex">A</script> is executed, in which case the previous load <script type="math/tex">B</script> must be replayed.</p>

<p>The four kinds of memory access orderings are:</p>

<ul>
<li>write A, write B</li>
<li>write A, read B</li>
<li>read A, write B</li>
<li>read A, read B</li>
</ul>

<p>Unlike sequential consistency where all orderings must be enforced, a <em>relaxed consistency model</em> allows certain kinds of memory accesses to not be enforced. For example, &quot;read A, read B&quot; accesses can be made out-of-order.</p>

<p>In a system with a relaxed consistency model, ordering constraints are enforced on memory accesses via special instructions, memory barriers, which ensure that previous memory accesses are complete before proceeding.</p>

<p>A memory barrier/fence is an instruction in a system with a relaxed consistency model that ensures that all memory access instructions (of a certain kind) prior to the barrier (in program order) are complete before proceeding. For example, <code>msync</code> on x86.</p>

<p>The <code>volatile</code> keyword in C/C++ ensures that reads and writes are not reordered by the compiler via instruction scheduling. It has no effect on memory consistency. Reads and writes to <code>volatile</code> variables do not guarantee a memory barrier. This means that <code>volatile</code> alone is not sufficient to use a variable for inter-thread communication.</p>

<p>A data race can occur when:</p>

<ol>
<li>one core reads and another writes to the same variable</li>
<li>one core writes and another reads to the same variable</li>
<li>one core writes and another writes to the same variable</li>
</ol>

<p>A <em>data-race-free program</em> is one that runs the same as it would with sequential consistency in any other consistency model.</p>

<p>To facilitate debugging data-races in programs, some processors allow enabling sequential consistency on demand, such as while debugging.</p>

<p><em>Weak memory consistency</em> distinguishes between synchronization and non-synchronization accesses. Synchronization accesses aren&#39;t reordered among themselves or with other accesses (i.e. they&#39;re sequentially-consistent). Non-synchronization accesses made between synchronization accesses can be reordered.</p>

<p><em>Release consistency</em> distinguishes between acquires and releases, and they&#39;re not reordered among themselves. Non-synchronization accesses can be reordered except that writes must complete before the next release synchronization (i.e. writes cannot be reordered/moved to after the next release) and reads cannot execute before the preceding acquire event (i.e. reads cannot be reordered/moved to before the previous acquire).</p>

<p>Sequential consistency can be achieved with weak consistency by treating every regular access as a synchronization access.</p>

<p>Release consistency can be achieved with weak consistency by treating every synchronization event as both an acquire and a release.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>I wonder if this kind of prefetcher is meant for, for example, if someone iterates through a 2D array the &quot;wrong&quot; way, in column-major order, so first the first column of the first row, then the first column of the second row, and so on. Then a good stride prefetcher might recognize this access pattern and prefetch the appropriate column stripes. Though hopefully this would be recognized much sooner by the compiler and resolved with <a href="#loop-interchange">loop interchange</a>.&nbsp;<a href="#fnref1" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

<li id="fn2">
<p>This is one of the many areas of computer architecture that reminds me of distributed systems. This is like partitioning data.&nbsp;<a href="#fnref2" title="continue reading" rev="footnote"><i class="fa fa-level-up"></i></a></p></li>

</ol>
</div>
</div>
  <div class="meta">
    <div class="meta-component"><i class="fa fa-calendar fa-fw"></i> April 22, 2016</div>
    <div class="meta-component"><i class="fa fa-code-fork fa-fw"></i> <a href="https://github.com/blaenk/site/commits/master/input/notes/computer-architecture.markdown">History</a><span class="hash">, <a href="https://github.com/blaenk/site/commit/fd1c4c6" title="finish up computer architecture transcribing">fd1c4c6</a></span></div>
    <div class="meta-component"><i class="fa fa-pencil fa-fw"></i> <a href="..">Notes</a></div>
  </div>
</article>



    
    <footer id="footer">
  <div id="social">
    <a href="https://github.com/blaenk" title="github"><i class="fa fa-github-alt"></i></a>
    &middot;
    <a href="http://stackoverflow.com/users/101090/jorge-israel-pena" title="stackoverflow"><i class="fa fa-stack-overflow"></i></a>
    &middot;
    <a href="https://twitter.com/blaenk" title="twitter"><i class="fa fa-twitter"></i></a>
    &middot;
    <a href="mailto:jorge.israel.p@gmail.com" title="email"><i class="fa fa-envelope"></i></a>
    &middot;
    <a href="/rss.xml" title="feed"><i class="fa fa-rss-square"></i></a>
  </div>
  <!-- <div id="credit">
    Designed by <a href="http://www.blaenkdenum.com">Jorge Israel Peña</a>
  </div> -->
</footer>


<!-- this should instead be something like connectWS("{{{path}}}") -->


<script type="text/javascript">
  jQuery(function (){
    var ws = new WebSocket('ws://' + window.location.hostname + ':9160/notes/computer-architecture.markdown');

    ws.onmessage = function (e) {
      var content = jQuery('article .entry-content');
      content.html(e.data);

      window.refresh();

      MathJax.Hub.Queue(["Typeset", MathJax.Hub, jQuery('article .entry-content')[0]]);

      if (window.jumpDown)
        window.scrollDown();
    };
  });
</script>




<!-- google analytics -->
<script async="true" type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37339861-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

<!--MathJax CDN-->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    messageStyle: "none"
  });

  MathJax.Hub.Register.MessageHook('End Process', function() {
    jQuery('#MathJax_Font_Test').empty();
    jQuery('.MathJax_Display').parent().addClass('mathjax');
  });
</script>

  </div>
</body>
</html>
