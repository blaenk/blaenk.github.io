<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Clojure - Blaenk Denum</title>
  <meta name="author" content="Jorge Israel Peña">
  <meta name="description" content="AKA Blaenk Denum">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="/favicon.png" rel="shortcut icon">
  <link href='http://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Merriweather:900italic,900,700italic,400italic,700,400,300italic,300' rel='stylesheet' type='text/css'>
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='/css/screen.css' rel='stylesheet' type='text/css' media='screen' />
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src='/js/blaenk.js' type='text/javascript'></script>
</head>
<body>
  <div class="page-wrapper">
    <header id="header">
  <div id="stamp">
    <h1 id="name">
      <a href="/">
        <span class="emboldened">Jorge</span>.Israel.<span class="emboldened">Peña</span>
      </a>
    </h1>
    <h4 id="pseudonym">
      AKA <span class="emboldened">Blaenk</span>.Denum
    </h4>
  </div>
  <nav id="main-nav">
    <ul class="main">
      <li><a href="/about/">About</a></li>
      <li><a href="/notes/">Notes</a></li>
      <li><a href="/work/">Work</a></li>
      <li><a href="/lately/">Lately</a></li>
      <li><a id="search_btn">Search</a></li>
    </ul>
  </nav>
  <nav id="mobile-nav">
    <div class="menu">
      <a class="button">Menu</a>
      <div class="container">
        <ul class="main">
          <li><a href="/about/">About</a></li>
          <li><a href="/notes/">Notes</a></li>
          <li><a href="/work/">Work</a></li>
          <li><a href="/lately/">Lately</a></li>
        </ul>
      </div>
    </div>
    <div class="search">
      <a class="button"></a>
      <div class="container">
        <form action="http://google.com/search" method="get">
          <input type="text" name="q" results="0">
          <input type="hidden" name="q" value="site:blaenkdenum.com">
        </form>
      </div>
    </div>
  </nav>
</header>
<form class="desk_search" action="http://google.com/search" method="get">
  <input id="search" type="text" name="q" results="0" placeholder="Search" autocomplete="off" spellcheck="false">
  <input type="hidden" name="q" value="site:blaenkdenum.com">
</form>

    
        <article class="post">
  <h2 class="title"><a href="/notes/clojure"><span>Clojure</span></a></h2>
  <div class="entry-content"><p>Recently I&rsquo;ve been thinking about my opinions on the various languages I know, particularly with regards to which I should focus on, and I decided that knowing a <abbr title="Java Virtual Machine">JVM</abbr> language would be very beneficial because of how robust and time-proven the <abbr title="Java Virtual Machine">JVM</abbr> is, especially compared to other language <abbr title="Virtual Machine">VM</abbr>s. For this reason I considered Scala and Clojure, and Scala seemed more like Haskell to me so I decided to <a href="/notes/scala">go with that one first</a>.</p>

<p>I didn&rsquo;t have an overwhelming reaction to Scala, so I decided to give Clojure a shot as well to better compare them. My main resource is the book <a href="http://amzn.com/1449394701">Clojure Programming</a>. There&rsquo;s also <a href="http://www.braveclojure.com/">Clojure for the Brave and True</a>.</p>

<nav id="toc">
<h3>Contents</h3><ol>
<li>
<a href="#homoiconicity">Homoiconicity</a>
</li>
<li>
<a href="#reader">Reader</a>
<ol>
<li>
<a href="#scalar-literals">Scalar Literals</a>
</li>
<li>
<a href="#keywords">Keywords</a>
</li>
<li>
<a href="#symbols">Symbols</a>
</li>
<li>
<a href="#numbers">Numbers</a>
</li>
<li>
<a href="#regular-expressions">Regular Expressions</a>
</li>
<li>
<a href="#comments">Comments</a>
</li>
<li>
<a href="#whitespace">Whitespace</a>
</li>
<li>
<a href="#collection-literals">Collection Literals</a>
</li>
<li>
<a href="#record-literals">Record Literals</a>
</li>
<li>
<a href="#tagged-literals">Tagged Literals</a>
</li>
</ol>
</li>
<li>
<a href="#namespaces">Namespaces</a>
</li>
<li>
<a href="#special-forms">Special Forms</a>
<ol>
<li>
<a href="#suppressing-evaluation">Suppressing Evaluation</a>
</li>
<li>
<a href="#code-blocks">Code Blocks</a>
</li>
<li>
<a href="#defining-vars">Defining Vars</a>
</li>
<li>
<a href="#local-bindings">Local Bindings</a>
</li>
<li>
<a href="#functions">Functions</a>
</li>
<li>
<a href="#conditionals">Conditionals</a>
</li>
<li>
<a href="#looping">Looping</a>
</li>
<li>
<a href="#java-interop">Java Interop</a>
</li>
<li>
<a href="#specialized-mutation">Specialized Mutation</a>
</li>
<li>
<a href="#eval">Eval</a>
</li>
</ol>
</li>
<li>
<a href="#function-application">Function Application</a>
</li>
<li>
<a href="#collections">Collections</a>
<ol>
<li>
<a href="#sequences">Sequences</a>
<ol>
<li>
<a href="#lazy-sequences">Lazy Sequences</a>
</li>
<li>
<a href="#head-retention">Head Retention</a>
</li>
</ol>
</li>
<li>
<a href="#associative">Associative</a>
</li>
<li>
<a href="#indexed">Indexed</a>
</li>
<li>
<a href="#stacks">Stacks</a>
</li>
<li>
<a href="#sets">Sets</a>
</li>
<li>
<a href="#sorted">Sorted</a>
</li>
<li>
<a href="#accessing">Accessing</a>
</li>
<li>
<a href="#constructing">Constructing</a>
</li>
<li>
<a href="#transients">Transients</a>
</li>
</ol>
</li>
<li>
<a href="#metadata">Metadata</a>
</li>
<li>
<a href="#zippers">Zippers</a>
</li>
<li>
<a href="#concurrency-and-parallelism">Concurrency and Parallelism</a>
<ol>
<li>
<a href="#delays">Delays</a>
</li>
<li>
<a href="#futures">Futures</a>
</li>
<li>
<a href="#promises">Promises</a>
</li>
<li>
<a href="#watches">Watches</a>
</li>
<li>
<a href="#validators">Validators</a>
</li>
<li>
<a href="#parallelization-strategies">Parallelization Strategies</a>
</li>
<li>
<a href="#reference-types">Reference Types</a>
<ol>
<li>
<a href="#atoms">Atoms</a>
</li>
<li>
<a href="#refs">Refs</a>
</li>
<li>
<a href="#vars">Vars</a>
<ol>
<li>
<a href="#private-vars">Private Vars</a>
</li>
<li>
<a href="#docstrings">Docstrings</a>
</li>
<li>
<a href="#constants">Constants</a>
</li>
<li>
<a href="#dynamic-scope">Dynamic Scope</a>
</li>
</ol>
</li>
<li>
<a href="#agents">Agents</a>
</li>
</ol>
</li>
<li>
<a href="#software-transactional-memory">Software Transactional Memory</a>
<ol>
<li>
<a href="#live-locks">Live Locks</a>
</li>
<li>
<a href="#reader-retry">Reader Retry</a>
</li>
<li>
<a href="#write-skew">Write Skew</a>
</li>
</ol>
</li>
<li>
<a href="#channels">Channels</a>
</li>
</ol>
</li>
<li>
<a href="#macros">Macros</a>
<ol>
<li>
<a href="#debugging-macros">Debugging Macros</a>
</li>
<li>
<a href="#macroexpansion">Macroexpansion</a>
</li>
<li>
<a href="#syntax">Syntax</a>
</li>
</ol>
</li>
<li>
<a href="#protocols">Protocols</a>
</li>
<li>
<a href="#custom-types">Custom Types</a>
<ol>
<li>
<a href="#records">Records</a>
</li>
<li>
<a href="#types">Types</a>
</li>
<li>
<a href="#implementing-protocols">Implementing Protocols</a>
</li>
</ol>
</li>
<li>
<a href="#multimethods">Multimethods</a>
<ol>
<li>
<a href="#hierarchies">Hierarchies</a>
</li>
</ol>
</li>
<li>
<a href="#build-tools">Build Tools</a>
</li>
<li>
<a href="#java-interoperability">Java Interoperability</a>
<ol>
<li>
<a href="#exception-handling">Exception Handling</a>
</li>
<li>
<a href="#type-hinting">Type Hinting</a>
</li>
<li>
<a href="#arrays">Arrays</a>
</li>
<li>
<a href="#classes">Classes</a>
</li>
<li>
<a href="#annotations">Annotations</a>
</li>
</ol>
</li>
<li>
<a href="#abbr-titleread-eval-print-loopreplabbr"><abbr title="Read-Eval-Print-Loop">REPL</abbr></a>
</li>
<li>
<a href="#math">Math</a>
</li>
<li>
<a href="#testing">Testing</a>
</li>
</ol>
</nav>
<h1 id="homoiconicity">
<span class="hash">#</span>
<a href="#homoiconicity" class="header-link">Homoiconicity</a>
</h1>
<p>Clojure and other lisp languages are <em>homoiconic</em>, often referred to as &ldquo;code as data,&rdquo; which means that the way the code is written is itself the abstract syntax tree (<abbr title="Abstract Syntax Tree">AST</abbr>) of the program. This makes creating embedded domain specific languages (<abbr title="Embedded Domain Specific Language">EDSL</abbr>s) very straightforward, as well as simply making the code easier to reason about. Questions of precedence, for example, are directly encoded into the code.</p>

<p>Because Clojure code is itself an <abbr title="Abstract Syntax Tree">AST</abbr> in a Clojure data structure, metaprogramming is also more powerful because it simply involves manipulating that data structure; this is the basis of macros.</p>
<h1 id="reader">
<span class="hash">#</span>
<a href="#reader" class="header-link">Reader</a>
</h1>
<p>Clojure <abbr title="Abstract Syntax Tree">AST</abbr> structures can be deserialized into Clojure structures using the <code>read</code>-like functions. In the following examples, the structures are printed back out by the <abbr title="Read-Eval-Print-Loop">REPL</abbr> using the <code>pr-str</code> function. The fact that serialization of Clojure structures is this straightforward is what drives most Clojure developers to use it as the primary serialization mechanism.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">read-string</span> <span class="s">&quot;42&quot;</span><span class="p">)</span>
<span class="c1">;= 42</span>

<span class="p">(</span><span class="nf">read-string</span> <span class="s">&quot;(+ 1 2)&quot;</span><span class="p">)</span>
<span class="c1">;= (+ 1 2)</span>

<span class="p">(</span><span class="nb">pr-str </span><span class="p">(</span><span class="nf">read-string</span> <span class="s">&quot;[1 2 3]&quot;</span><span class="p">))</span>
<span class="c1">;= [1 2 3]</span>
</code></pre></figure>
<p><strong>Note</strong>: the Clojure <abbr title="Read-Eval-Print-Loop">REPL</abbr> always starts in the default <code>user</code> namespace.</p>

<p>The reader allows for different syntax to make code more concise. For example, evaluation of a form can be suppressed by prefixing it with a quote <code>&#39;</code>. Anonymous function literals can be defined with <code>#()</code>.</p>
<h2 id="scalar-literals">
<span class="hash">#</span>
<a href="#scalar-literals" class="header-link">Scalar Literals</a>
</h2>
<p>Characters are denoted by a blackslash, as in <code>\c</code>, and they natively support Unicode. It&rsquo;s also possible to use special characters such as <code>\n</code> would be used in strings, but individually:</p>

<ul>
<li><code>\space</code></li>
<li><code>\newline</code></li>
<li><code>\formfeed</code></li>
<li><code>\return</code></li>
<li><code>\backspace</code></li>
<li><code>\tab</code></li>
</ul>
<h2 id="keywords">
<span class="hash">#</span>
<a href="#keywords" class="header-link">Keywords</a>
</h2>
<p>Keywords are similar to Ruby/Scala symbols and Erlang atoms. They are prefixed by a colon <code>:</code> and consist of any non-whitespace character, where a slash <code>/</code> denotes a <em>namespaced keyword</em>, and a double colon <code>::</code> is expanded by the reader to a namespaced keyword in the current namespace, or another namespace if the keyword started by a namespace alias as in <code>::alias/keyword</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">pizza</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Ramunto&#39;s&quot;</span>
            <span class="ss">:location</span> <span class="s">&quot;Claremont, NH&quot;</span>
            <span class="ss">::location</span> <span class="s">&quot;123,-456&quot;</span><span class="p">})</span>
<span class="c1">;= #&#39;user/pizza</span>

<span class="nv">pizza</span>
<span class="c1">;= {:name &quot;Ramunto&#39;s&quot;, :location &quot;Claremont, NH&quot;, :user/location &quot;123,-456&quot;}</span>

<span class="p">(</span><span class="ss">:user/location</span> <span class="nv">pizza</span><span class="p">)</span>
<span class="c1">;= &quot;123,-456</span>
</code></pre></figure>
<p>Keywords are &ldquo;named&rdquo; values which are values that have intrinsic names that can be accessed using the <code>name</code> function, and the namespace can be accessed with the <code>namespace</code> function:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">name </span><span class="ss">:user/location</span><span class="p">)</span>
<span class="c1">;= &quot;location&quot;</span>

<span class="p">(</span><span class="nb">namespace </span><span class="ss">:user/location</span><span class="p">)</span>
<span class="c1">;= &quot;user&quot;</span>
</code></pre></figure>
<p>As in Ruby, keywords are often used for indexing hashes. The following defines a hashmap with a <code>:name</code> and <code>:city</code> key and then accesses the value for the <code>:city</code> key. Keywords can be used in the function position because they <em>are</em> functions that look themselves up in collections passed to them.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">person</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Sandra Cruz&quot;</span>
             <span class="ss">:city</span> <span class="s">&quot;Portland, ME&quot;</span><span class="p">})</span>
<span class="c1">;= #&#39;user/person</span>

<span class="p">(</span><span class="ss">:city</span> <span class="nv">person</span><span class="p">)</span>
<span class="c1">;= &quot;Portland, ME&quot;</span>
</code></pre></figure><h2 id="symbols">
<span class="hash">#</span>
<a href="#symbols" class="header-link">Symbols</a>
</h2>
<p>Symbols are identifiers that evaluate to the values they name. For example, in the following code, <code>average</code> is a symbol referring to the function held in the var named <code>average</code>. Symbols containing a slash <code>/</code> denote a <em>namespaced symbol</em> which evaluates to the named value in the specified namespace.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">average</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span><span class="p">])</span>
<span class="c1">;= 20</span>
</code></pre></figure>
<p>The variables can be referred to directly by prefixing a symbol with <code>#&#39;</code>.</p>
<h2 id="numbers">
<span class="hash">#</span>
<a href="#numbers" class="header-link">Numbers</a>
</h2>
<p>Numeric literals exist for a variety of number types. Custom numerical bases can be used with the <code>#r</code> prefix where <code>#</code> would be the desired number base.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Syntax</th>
<th style="text-align: left">Type</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">42, 0xff, 2r101, 040</td>
<td style="text-align: left">long</td>
</tr>
<tr>
<td style="text-align: left">3.14, 6.02e23</td>
<td style="text-align: left">double</td>
</tr>
<tr>
<td style="text-align: left">42N</td>
<td style="text-align: left">clojure.lang.BigInt</td>
</tr>
<tr>
<td style="text-align: left">0.01M</td>
<td style="text-align: left">java.math.BigDecimal</td>
</tr>
<tr>
<td style="text-align: left">22/7</td>
<td style="text-align: left">clojure.lang.Ratio</td>
</tr>
</tbody>
</table>
<h2 id="regular-expressions">
<span class="hash">#</span>
<a href="#regular-expressions" class="header-link">Regular Expressions</a>
</h2>
<p>Strings prefixed with a hash <code>#</code> are regex literals which yield <span class="path">java.util.regex.Pattern</span> instances.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">re-seq </span><span class="o">#</span><span class="s">&quot;(\d+)-(\d+)&quot;</span> <span class="s">&quot;1-3&quot;</span><span class="p">)</span>
<span class="c1">;= ([&quot;1-3&quot; &quot;1&quot; &quot;3&quot;])</span>
</code></pre></figure><h2 id="comments">
<span class="hash">#</span>
<a href="#comments" class="header-link">Comments</a>
</h2>
<p>Single-line comments are started with a semicolon <code>;</code>. There are also <em>form-level</em> comments prefixed by the <code>#_</code> reader macro which cue the reader to ignore the next Clojure <em>form</em> following the macro. This is particularly useful when wanting to comment out blocks of code. The <code>comment</code> macro can also be used to comment out code but they always evaluate to <code>nil</code>, which may be unexpected.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">read-string</span> <span class="s">&quot;(+ 1 2 #_(* 2 2) 8)&quot;</span><span class="p">)</span>
<span class="c1">;= (+ 1 2 8)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">some-func</span>
  <span class="p">[</span><span class="nv">args</span><span class="p">]</span>
  <span class="nv">code</span>
  <span class="o">#</span><span class="nv">_</span><span class="p">(</span><span class="k">if </span><span class="nv">debug-level</span>
    <span class="p">(</span><span class="nb">println </span><span class="s">&quot;debugging&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">println </span><span class="s">&quot;more debugging&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">comment </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">2</span><span class="p">))</span> <span class="mi">8</span><span class="p">)</span>
<span class="c1">;= NullPointerException</span>
</code></pre></figure><h2 id="whitespace">
<span class="hash">#</span>
<a href="#whitespace" class="header-link">Whitespace</a>
</h2>
<p>Commas are considered whitespace by the reader. Whether to use them or not is a question of style, but they&rsquo;re generally used when multiple pairs of values appear on the same line.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">= </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span><span class="p">])</span>
<span class="c1">;= true</span>

<span class="p">(</span><span class="nf">create-user</span> <span class="p">{</span><span class="ss">:name</span> <span class="nv">user</span>, <span class="ss">:email</span> <span class="nv">email</span><span class="p">})</span>
</code></pre></figure><h2 id="collection-literals">
<span class="hash">#</span>
<a href="#collection-literals" class="header-link">Collection Literals</a>
</h2>
<p>There are literals for lists, vectors, maps, and sets. Note that since lists denote calls in Clojure, it&rsquo;s necessary to quote them to prevent their evaluation as a call.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="o">&#39;</span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="ss">:name</span> <span class="mf">12.5</span><span class="p">)</span>     <span class="c1">;; list</span>
<span class="p">[</span><span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="mf">12.5</span><span class="p">]</span>          <span class="c1">;; vector</span>
<span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Bob&quot;</span> <span class="ss">:age</span> <span class="mi">31</span><span class="p">}</span> <span class="c1">;; map</span>
<span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span>              <span class="c1">;; set</span>
</code></pre></figure><h2 id="record-literals">
<span class="hash">#</span>
<a href="#record-literals" class="header-link">Record Literals</a>
</h2>
<p>Record literals consist of the pound sign <code>#</code> followed by the record name and a map literal containing the field names as keyword keys with their associated values. See <a href="#records">records</a>.</p>
<h2 id="tagged-literals">
<span class="hash">#</span>
<a href="#tagged-literals" class="header-link">Tagged Literals</a>
</h2>
<p>Tagged literals are custom data readers. On startup, Clojure looks for files named <span class="path">data_readers.clj</span> at the root of the classpath which must contain a map of symbols mapping tags&mdash;to be recognized by the Clojure reader&mdash;to the name of fully-qualified Vars that are invoked by the reader to parse the form following the tag.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">{</span><span class="nv">foo/bar</span> <span class="nv">my.project.foo/bar</span>
 <span class="nv">foo/baz</span> <span class="nv">my.project/baz</span><span class="p">}</span>

<span class="o">#</span><span class="nv">foo/bar</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></figure>
<p>The Var <code>#&#39;my.project.foo/bar</code> is invoked by the reader on vector <code>[1 2 3]</code> <em>after</em> it has been read as a normal Clojure data structure by the reader. That is, the reader will parse the form after the tag as a data structure, then invoke the tagged literal function on the data structure itself. The tagged literal function should then return a value that <em>replaces</em> the tagged data structure in the final result <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>.</p>
<h1 id="namespaces">
<span class="hash">#</span>
<a href="#namespaces" class="header-link">Namespaces</a>
</h1>
<p>Vars are defined using the <code>def</code> special form which takes the symbol used to refer to the var and the value to store in that var. When the symbol is used on its own to access the var&rsquo;s value, the symbol is said to be <em>unqualified</em> and so it is resolved within the current namespace. Vars can also be redefined by supplying the same symbol with a different value to the <code>def</code> function.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">;= #&#39;user/x</span>

<span class="nv">x</span>
<span class="c1">;= 1</span>

<span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="c1">;= #&#39;user/x</span>

<span class="nv">x</span>
<span class="c1">;= &quot;hello&quot;</span>
</code></pre></figure>
<p>Contrary to unqualified symbols, symbols can be <em>namespace-qualified</em> so that they are resolved within the specified namespace. For example, if we create a new namespace <code>foo</code>, we can continue to refer to the symbol <code>x</code> by qualifying the namespace. However, if we attempt to access the unqualified symbol, it will try to find <code>x</code> within the <code>foo</code> namespace, which doesn&rsquo;t exist:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="nv">*ns*</span>
<span class="c1">;= #&lt;Namespace user&gt;</span>

<span class="p">(</span><span class="kd">ns </span><span class="nv">foo</span><span class="p">)</span> <span class="c1">; create and switch to new &#39;foo&#39; namespace</span>
<span class="c1">;= nil</span>

<span class="nv">*ns*</span>
<span class="c1">;= #&lt;Namespace foo&gt;</span>

<span class="nv">user/x</span>
<span class="c1">;= &quot;hello&quot;</span>

<span class="nv">x</span>
<span class="c1">;= CompilerException: Unable to resolve symbol: x</span>
</code></pre></figure>
<p>The <code>in-ns</code> function can be used to switch to another namespace, creating it if it doesn&rsquo;t already exist. Symbols from other namespace will have to be fully qualified in order to access. The <code>refer</code> function can add mappings to all of another namespace&rsquo;s vars into the current namespace.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="mi">42</span><span class="p">)</span>

<span class="p">(</span><span class="nb">in-ns </span><span class="ss">&#39;asdf</span><span class="p">)</span>
<span class="nv">x</span>
<span class="c1">;= #&lt;CompilerException: Unable to resolve symbol: x&gt;</span>

<span class="p">(</span><span class="nf">clojure.core/refer</span> <span class="ss">&#39;user</span><span class="p">)</span>
<span class="nv">x</span>
<span class="c1">;= 42</span>
</code></pre></figure>
<p>The <code>refer</code> function also takes optional keyword arguments <code>:exclude</code> which can be used to exclude specific vars from the namespace, <code>:only</code> which specifies which mappings should be available unqualified, and <code>:rename</code> which can alias vars from the namespace to appear another way in the current namespace.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">refer </span><span class="ss">&#39;clojure.core</span>
  <span class="ss">:exclude</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">range</span><span class="p">)</span>
  <span class="ss">:rename</span> <span class="o">&#39;</span><span class="p">{</span><span class="nb">+ </span><span class="nv">add</span>
            <span class="nb">- </span><span class="nv">sub</span>
            <span class="nb">/ </span><span class="nv">div</span>
            <span class="nb">* </span><span class="nv">mul</span><span class="p">})</span>
</code></pre></figure>
<p>The <code>require</code> function can ensure that a namespace is loaded and can optionally establish aliases for the name of the namespace by passing a <em>libspec</em>, which is simply a vector containing the namespace, the <code>:as</code> keyword, and the alias to use.</p>

<p>If multiple namespaces are to be required and they share a common prefix, a list can be provided where the first element is the common prefix and the remaining elements are the remaining segments for the specific namespaces to load.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;clojure.set</span><span class="p">)</span>
<span class="p">(</span><span class="nf">clojure.set/union</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="mi">3</span> <span class="mi">4</span><span class="p">})</span>
<span class="c1">;= #{1 2 3 4}</span>

<span class="c1">; or</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.set</span> <span class="ss">:as</span> <span class="nv">set</span><span class="p">])</span>
<span class="p">(</span><span class="nf">set/union</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="mi">3</span> <span class="mi">4</span><span class="p">})</span>

<span class="c1">; or</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">clojure</span> <span class="nv">string</span> <span class="p">[</span><span class="nb">set </span><span class="ss">:as</span> <span class="nv">set</span><span class="p">])</span>
</code></pre></figure>
<p>The <code>use</code> function is similar to <code>require</code>, except that it <code>refer</code>s the specified namespace after it&rsquo;s loaded.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.xml</span><span class="p">)</span>

<span class="c1">; equivalent to</span>

<span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;clojure.xml</span><span class="p">)</span>
<span class="p">(</span><span class="nb">refer </span><span class="ss">&#39;clojure.xml</span><span class="p">)</span>
</code></pre></figure>
<p>The aforementioned functions create mappings from symbols to vars, but namespaces can also contain Java classes and interfaces. Mappings to these can be created with the <code>import</code> function, which essentially makes the class' short name available for use. This function also supports the common-prefixed collection that <code>require</code> accepts.</p>

<p>There is no equivalent of the Java wildcard import. Inner classes such as <span class="path">java.util.Map.Entry</span> can be referred to by the Java-internal notation e.g. <span class="path">java.util.Map$Entry</span>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">import </span><span class="ss">&#39;java.util.Date</span> <span class="ss">&#39;java.text.SimpleDateFormat</span><span class="p">)</span>
<span class="p">(</span><span class="nf">.format</span> <span class="p">(</span><span class="nf">SimpleDateFormat.</span> <span class="s">&quot;MM/dd/yyyy&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Date.</span><span class="p">))</span>
<span class="c1">;= &quot;06/25/2014&quot;</span>

<span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">Arrays</span> <span class="nv">Collections</span><span class="p">))</span>
</code></pre></figure>
<p>The aforementioned namespace functions are mainly useful in a <abbr title="Read-Eval-Print-Loop">REPL</abbr>. In actual source files, the <code>ns</code> macro should be used, which combines each of the aforementioned functionality by allowing one to specify what needs to be required, refered, used, and imported for the namespace to load and work properly.</p>

<p>The <code>:refer</code> keyword can be used in a <code>:require</code> form similar to <code>:only</code>, to allow the use of the provided symbols in an unqualified manner. In fact, the <code>:use</code> form can be obviated entirely by passing <code>:all</code> to <code>:refer</code> instead of a vector of symbols.</p>

<p>The <code>:refer-clojure</code> form is a synonym for <code>refer</code>ing to the <span class="path">clojure.core</span> namespace, which is particularly useful for the purpose of <code>:exclude</code>ing symbols to avoid collisions.</p>

<p>The following are equivalent.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">in-ns </span><span class="ss">&#39;examples.ns</span><span class="p">)</span>
<span class="p">(</span><span class="nf">clojure.core/refer</span> <span class="ss">&#39;clojure.core</span> <span class="ss">:exclude</span> <span class="o">&#39;</span><span class="p">[</span><span class="nb">next replace </span><span class="nv">remove</span><span class="p">])</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">clojure</span> <span class="p">[</span><span class="nv">string</span> <span class="ss">:as</span> <span class="nv">string</span><span class="p">]</span>
                   <span class="p">[</span><span class="nb">set </span><span class="ss">:as</span> <span class="nv">set</span><span class="p">])</span>
         <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.shell</span> <span class="ss">:as</span> <span class="nv">sh</span><span class="p">])</span>
<span class="p">(</span><span class="nf">use</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">clojure</span> <span class="nv">zip</span> <span class="nv">xml</span><span class="p">))</span>
<span class="p">(</span><span class="nb">import </span><span class="ss">&#39;java.util.Date</span>
        <span class="ss">&#39;java.text.SimpleDateFormat</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util.concurrent</span> <span class="nv">Executors</span>
                               <span class="nv">LinkedBlockingQueue</span><span class="p">))</span>

<span class="p">(</span><span class="kd">ns </span><span class="nv">examples.ns</span>
  <span class="p">(</span><span class="ss">:refer-clojure</span> <span class="ss">:exclude</span> <span class="p">[</span><span class="nb">next replace </span><span class="nv">remove</span><span class="p">])</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">(</span><span class="nf">clojure</span> <span class="p">[</span><span class="nv">string</span> <span class="ss">:as</span> <span class="nv">string</span><span class="p">]</span>
                     <span class="p">[</span><span class="nb">set </span><span class="ss">:as</span> <span class="nv">set</span><span class="p">]</span>
                     <span class="c1">; thanks to :refer</span>
                     <span class="p">[</span><span class="nv">zip</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]</span>
                     <span class="p">[</span><span class="nv">xml</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">])</span>
            <span class="p">[</span><span class="nv">clojure.java.shell</span> <span class="ss">:as</span> <span class="nv">sh</span><span class="p">])</span>
  <span class="c1">; before :require x :refer :all</span>
  <span class="c1">; (:use (clojure zip xml))</span>
  <span class="p">(</span><span class="ss">:import</span> <span class="nv">java.util.Date</span>
           <span class="nv">java.text.SimpleDateFormat</span>
           <span class="p">(</span><span class="nf">java.util.concurrent</span> <span class="nv">Executors</span>
                                 <span class="nv">LinkedBlockingQueue</span><span class="p">)))</span>
</code></pre></figure>
<p>Note that if a namespace contains dashes, the filename should contain underscores in their place.</p>

<p>There are functions <code>ns-map</code>, <code>ns-imports</code>, <code>ns-refers</code>, <code>ns-publics</code>, <code>ns-aliases</code>, and <code>ns-interns</code> which can yield a mapping of symbols pertaining to the respective category.</p>

<p>The <code>ns-unmap</code> and <code>ns-unalias</code> functions can be used to remove mappings to certain symbols and remove aliases for certain namespaces. The <code>remove-ns</code> function can be used to drop a namespace from the namespace map, making the code under that namespace eligible for garbage collection if it&rsquo;s not referred from anyplace else.</p>
<h1 id="special-forms">
<span class="hash">#</span>
<a href="#special-forms" class="header-link">Special Forms</a>
</h1>
<p>Special forms are Clojure&rsquo;s primitives of computation upon which the rest of Clojure is built.</p>
<h2 id="suppressing-evaluation">
<span class="hash">#</span>
<a href="#suppressing-evaluation" class="header-link">Suppressing Evaluation</a>
</h2>
<p>The special form <code>quote</code> suppresses evaluation of a Clojure expression. For example symbols evaluate to the value of the var they represent, but with <code>quote</code> that evaluation is suppressed, so they evaluate to themselves like strings and numbers do. The quote character <code>&#39;</code> is reader syntax for <code>quote</code>. In fact, <code>quote</code> can be used on reader sugars to determine how they&rsquo;re actually represented.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">quote </span><span class="nv">x</span><span class="p">)</span>
<span class="c1">;= x</span>

<span class="p">(</span><span class="nb">symbol? </span><span class="p">(</span><span class="k">quote </span><span class="nv">x</span><span class="p">))</span>
<span class="c1">;= true</span>

<span class="ss">&#39;x</span>
<span class="c1">;= x</span>

<span class="p">(</span><span class="nb">symbol? </span><span class="ss">&#39;x</span><span class="p">)</span>
<span class="c1">;= true</span>

<span class="p">(</span><span class="nb">= </span><span class="o">&#39;</span><span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;+</span> <span class="ss">&#39;x</span> <span class="ss">&#39;x</span><span class="p">))</span>
<span class="c1">;= true</span>
</code></pre></figure><h2 id="code-blocks">
<span class="hash">#</span>
<a href="#code-blocks" class="header-link">Code Blocks</a>
</h2>
<p>The special form <code>do</code> evaluates all of the expressions provided to it in order and yields the last expression&rsquo;s value as its value. Many other forms such as <code>fn</code>, <code>let</code>, <code>loop</code>, <code>try</code> and <code>defn</code> wrap their body in an implicit <code>do</code> expression so that multiple inner expressions are evaluated.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">do</span>
  <span class="p">(</span><span class="nb">println </span><span class="s">&quot;hi&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">apply * </span><span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]))</span>
<span class="c1">; hi</span>
<span class="c1">;= 120</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">rand-int </span><span class="mi">6</span><span class="p">))</span>
      <span class="nv">b</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">rand-int </span><span class="mi">6</span><span class="p">))]</span>
  <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">format</span> <span class="s">&quot;You rolled a %s and a %s&quot;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
</code></pre></figure><h2 id="defining-vars">
<span class="hash">#</span>
<a href="#defining-vars" class="header-link">Defining Vars</a>
</h2>
<p>The special form <code>def</code> defines or redefines a var with an optional value within the current namespace. Other forms implicitly create or redefine vars and are usually prefixed with <code>def</code> such as <code>defn</code> and <code>defn-</code>.</p>

<p>It&rsquo;s possible to refer to vars instead of the values that they hold by using the special form <code>var</code>. There&rsquo;s also a shorthand for this with <code>#&#39;</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">;= #&#39;user/x</span>

<span class="p">(</span><span class="k">var </span><span class="nv">x</span><span class="p">)</span>
<span class="c1">;= #&#39;user/x</span>

<span class="o">#</span><span class="ss">&#39;x</span>
<span class="c1">;= #&#39;user/x</span>
</code></pre></figure><h2 id="local-bindings">
<span class="hash">#</span>
<a href="#local-bindings" class="header-link">Local Bindings</a>
</h2>
<p>The special form <code>let</code> allows lexically scoped named references to be defined.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">hypot</span>
  <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x2</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)</span>
        <span class="nv">y2</span> <span class="p">(</span><span class="nb">* </span><span class="nv">y</span> <span class="nv">y</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">Math/sqrt</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x2</span> <span class="nv">y2</span><span class="p">))))</span>
</code></pre></figure>
<p>The <code>let</code> form also allows <em>destructuring</em> similar to pattern-matching in languages like Haskell, Rust, Scala, and Erlang. For example, to destructure a sequence, specifically a vector, we simply pass it a list of symbols that will take on the appropriate values. Destructuring can also be nested, as in other languages. The ampersand <code>&amp;</code> can be used to specify that the following symbol should take on the remaining <em>sequence</em> of values. The <code>:as</code> keyword can be used to bind the collection to a value, similar to what <code>@</code> does in Haskell, Scala, and Rust.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">v</span> <span class="p">[</span><span class="mi">42</span> <span class="s">&quot;foo&quot;</span> <span class="mf">99.2</span> <span class="p">[</span><span class="mi">5</span> <span class="mi">12</span><span class="p">]])</span>
<span class="c1">;= #&#39;user/v</span>

<span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">]</span> <span class="nv">v</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">z</span><span class="p">))</span>
<span class="c1">;= 141.2</span>

<span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">x</span> <span class="nv">_</span> <span class="nv">_</span> <span class="p">[</span><span class="nv">y</span> <span class="nv">z</span><span class="p">]]</span> <span class="nv">v</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
<span class="c1">;= 59</span>

<span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">x</span> <span class="o">&amp;</span> <span class="nv">rest</span><span class="p">]</span> <span class="nv">v</span><span class="p">]</span>
  <span class="nv">rest</span><span class="p">)</span>
<span class="c1">;= (&quot;foo&quot; 99.2 [5 12])</span>

<span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">x</span> <span class="nv">_</span> <span class="nv">z</span> <span class="ss">:as</span> <span class="nv">original-vector</span><span class="p">]</span> <span class="nv">v</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">conj </span><span class="nv">original-vector</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">z</span><span class="p">)))</span>
<span class="c1">;= [42 &quot;foo&quot; 99.2 [5 12] 141.2]</span>
</code></pre></figure>
<p>Maps can also be destructured in a similar manner. This works with Clojure&rsquo;s <code>hash-map</code>, <code>array-map</code>, records, collections implementing <span class="path">java.util.Map</span>, and values supported by the <code>get</code> function such as Clojure vectors, strings, and array can be keyed by their indices.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">m</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">6</span>
        <span class="ss">:c</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">]</span>
        <span class="ss">:d</span> <span class="p">{</span><span class="ss">:e</span> <span class="mi">10</span> <span class="ss">:f</span> <span class="mi">11</span><span class="p">}</span>
        <span class="s">&quot;foo&quot;</span> <span class="mi">88</span>
        <span class="mi">42</span> <span class="nv">false</span><span class="p">})</span>
<span class="c1">;= #&#39;user/m</span>

<span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="nv">a</span> <span class="ss">:a</span> <span class="nv">b</span> <span class="ss">:b</span><span class="p">}</span> <span class="nv">m</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
<span class="c1">;= 11</span>

<span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="nv">x</span> <span class="mi">3</span> <span class="nv">y</span> <span class="mi">8</span><span class="p">}</span> <span class="p">[</span><span class="mi">12</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">-18</span> <span class="mi">44</span> <span class="mi">6</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">]]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="c1">;= -17</span>
</code></pre></figure>
<p>The <code>:as</code> keyword can be used to bind the collection. The <code>:or</code> keyword can be used to provide a defaults map which will be consulted if the destructured keys aren&rsquo;t present.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="nv">k</span> <span class="ss">:unknown</span> <span class="nv">x</span> <span class="ss">:a</span>
       <span class="ss">:or</span> <span class="p">{</span><span class="nv">k</span> <span class="mi">50</span><span class="p">}}</span> <span class="nv">m</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">k</span> <span class="nv">x</span><span class="p">))</span>
<span class="c1">;= 55</span>
</code></pre></figure>
<p>Often times it may be desirable to destructure a map such that the symbols are named after the keys of the map, but doing this explicitly can get repetitive, which is why the options <code>:keys</code>, <code>:strs</code>, and <code>:syms</code> can be used.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">chas</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Chas&quot;</span> <span class="ss">:age</span> <span class="mi">31</span> <span class="ss">:location</span> <span class="s">&quot;Massachusetts&quot;</span><span class="p">})</span>
<span class="c1">;= #&#39;user/chas</span>

<span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="nb">name </span><span class="ss">:name</span> <span class="nv">age</span> <span class="ss">:age</span> <span class="nv">location</span> <span class="ss">:location</span><span class="p">}</span> <span class="nv">chas</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">format</span> <span class="s">&quot;%s is %s years old and lives in %s.&quot;</span> <span class="nb">name </span><span class="nv">age</span> <span class="nv">location</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nb">name </span><span class="nv">age</span> <span class="nv">location</span><span class="p">]}</span> <span class="nv">chas</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">format</span> <span class="s">&quot;%s is %s years old and lives in %s.&quot;</span> <span class="nb">name </span><span class="nv">age</span> <span class="nv">location</span><span class="p">))</span>
</code></pre></figure>
<p>It&rsquo;s also possible to destructure vectors which themselves contain key-value pairs. This can be done explicitly by binding the key-value pairs with <code>&amp;</code>, converting that to a <code>hash-map</code>, and then destructuring that, however, it&rsquo;s also possible with regular destructure syntax. This is specifically made possible by <code>let</code> by allowing the destructuring of rest sequences if they have an even number of values, i.e. key-value pairs.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">user-info</span> <span class="p">[</span><span class="s">&quot;robert8990&quot;</span> <span class="mi">2011</span> <span class="ss">:name</span> <span class="s">&quot;Bob&quot;</span> <span class="ss">:city</span> <span class="s">&quot;Boston&quot;</span><span class="p">])</span>
<span class="c1">;= #&#39;user/user-info</span>

<span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">username</span> <span class="nv">account-year</span> <span class="o">&amp;</span> <span class="nv">extra-info</span><span class="p">]</span> <span class="nv">user-info</span>
      <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nb">name </span><span class="nv">city</span><span class="p">]}</span> <span class="p">(</span><span class="nb">apply hash-map </span><span class="nv">extra-info</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">format</span> <span class="s">&quot;%s is in %s&quot;</span> <span class="nb">name </span><span class="nv">city</span><span class="p">))</span>
<span class="c1">;= &quot;Bob is in Boston&quot;</span>

<span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">username</span> <span class="nv">account-year</span> <span class="o">&amp;</span> <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nb">name </span><span class="nv">city</span><span class="p">]}]</span> <span class="nv">user-info</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">format</span> <span class="s">&quot;%s is in %s&quot;</span> <span class="nb">name </span><span class="nv">city</span><span class="p">))</span>
<span class="c1">;= &quot;Bob is in Boston&quot;</span>
</code></pre></figure><h2 id="functions">
<span class="hash">#</span>
<a href="#functions" class="header-link">Functions</a>
</h2>
<p>The special form <code>fn</code> is used to create functions. A function defined this way has no name, and so cannot be referred to later on. It can be place inside a var using the <code>def</code> form. The <code>fn</code> form also takes an optional name by which the function can reference itself. Furthermore, a function can have <em>multiple arities</em>, that is, define different bodies depending on the number of arguments passed.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">10</span> <span class="nv">x</span><span class="p">))</span> <span class="mi">8</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">add-ten</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">10</span> <span class="nv">x</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">add-ten</span> <span class="mi">20</span><span class="p">)</span>
<span class="c1">;= 30</span>

<span class="p">(</span><span class="k">def </span><span class="nv">strange-adder</span> <span class="p">(</span><span class="k">fn </span><span class="nv">adder-self-reference</span>
                     <span class="p">([</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">adder-self-reference</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
                     <span class="p">([</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">strange-adder</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1">;= 11</span>

<span class="p">(</span><span class="nf">strange-adder</span> <span class="mi">10</span> <span class="mi">50</span><span class="p">)</span>
<span class="c1">;= 60</span>
</code></pre></figure>
<p>The <code>defn</code> form encapsulates the functionality of <code>def</code> and <code>fn</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">strange-adder</span>
  <span class="p">([</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">strange-adder</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
</code></pre></figure>
<p>The special form <code>letfn</code> can be used to define multiple functions at once that are aware of each other. This is useful for definining mutually recursive functions.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">letfn</span> <span class="p">[(</span><span class="nf">odd?</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
          <span class="p">(</span><span class="nf">even?</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">even?</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
          <span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">odd?</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">))))])</span>

<span class="p">(</span><span class="nf">odd?</span> <span class="mi">11</span><span class="p">)</span>
<span class="c1">;= true</span>
</code></pre></figure>
<p>Variadic functions are possible using the rest arguments syntax from destructuring.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">concat-rest</span>
  <span class="p">[</span><span class="nv">x</span> <span class="o">&amp;</span> <span class="nv">rest</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">butlast </span><span class="nv">rest</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">make-user</span>
  <span class="p">[</span><span class="o">&amp;</span> <span class="p">[</span><span class="nv">user-id</span><span class="p">]]</span>
  <span class="p">{</span><span class="ss">:user-id</span> <span class="p">(</span><span class="nb">or </span><span class="nv">user-id</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">java.util.UUID/randomUUID</span><span class="p">)))})</span>
</code></pre></figure>
<p>It&rsquo;s also possible to use keyword arguments in functions, which is facilitated through map destructuring of rest sequences.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">make-user</span>
  <span class="p">[</span><span class="nv">username</span> <span class="o">&amp;</span> <span class="p">{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">email</span> <span class="nv">join-date</span><span class="p">]</span>
               <span class="ss">:or</span> <span class="p">{</span><span class="nv">join-date</span> <span class="p">(</span><span class="nf">java.util.Date.</span><span class="p">)}}]</span>
  <span class="p">{</span><span class="ss">:username</span> <span class="nv">username</span>
   <span class="ss">:join-date</span> <span class="nv">join-date</span>
   <span class="ss">:email</span> <span class="nv">email</span>
   <span class="ss">:exp-date</span> <span class="p">(</span><span class="nf">java.util.Date.</span> <span class="p">(</span><span class="nb">long </span><span class="p">(</span><span class="nf">+2.592e9</span> <span class="p">(</span><span class="nf">.getTime</span> <span class="nv">join-date</span><span class="p">))))})</span>

<span class="p">(</span><span class="nf">make-user</span> <span class="s">&quot;Bobby&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">make-user</span> <span class="s">&quot;Bobby&quot;</span>
           <span class="ss">:join-date</span> <span class="p">(</span><span class="nf">java.util.Date.</span> <span class="mi">111</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span>
           <span class="ss">:email</span> <span class="s">&quot;bobby@example.com&quot;</span><span class="p">)</span>
</code></pre></figure>
<p>Function literals have specific, concise syntax by being prepended with <code>#</code>. Placeholder arguments are prepended with <code>%</code>, though the first argument can be referred to by a single <code>%</code>. Function literals don&rsquo;t contain an implicit <code>do</code> form, so multiple statements require an explicit <code>do</code> form. It&rsquo;s also possible to specify variadic functions by assigning the rest of the arguments to <code>%&amp;</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span> <span class="p">(</span><span class="nf">Math/pow</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="o">#</span><span class="p">(</span><span class="nf">Math/pow</span> <span class="nv">%1</span> <span class="nv">%2</span><span class="p">)</span>

<span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span> <span class="o">&amp;</span> <span class="nv">rest</span><span class="p">]</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="p">(</span><span class="nb">apply + </span><span class="nv">rest</span><span class="p">)))</span>
<span class="o">#</span><span class="p">(</span><span class="nb">- </span><span class="nv">%</span> <span class="p">(</span><span class="nb">apply + </span><span class="nv">%</span><span class="o">&amp;</span><span class="p">))</span>
</code></pre></figure>
<p><strong>Note</strong>: Function literals cannot be nested.</p>
<h2 id="conditionals">
<span class="hash">#</span>
<a href="#conditionals" class="header-link">Conditionals</a>
</h2>
<p>The special form <code>if</code> is the single primitive conditional operator in Clojure. If no else-expression is provided it is assumed to be <code>nil</code>. There are other conditionals based on this form that are more convenient in specific situations.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">if </span><span class="nv">condition?</span> <span class="nv">true</span> <span class="nv">false</span><span class="p">)</span>

<span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">nums</span> <span class="p">(</span><span class="nb">seq </span><span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]))]</span>
  <span class="p">(</span><span class="nb">reduce + </span><span class="nv">nums</span><span class="p">)</span>
  <span class="s">&quot;No even numbers found.&quot;</span><span class="p">)</span> <span class="c1">; else</span>

<span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">true</span><span class="p">)</span> <span class="c1">; else nil</span>

<span class="p">(</span><span class="nf">cond</span>
  <span class="p">(</span><span class="nb">&lt; </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="s">&quot;negative&quot;</span>
  <span class="p">(</span><span class="nb">&gt; </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="s">&quot;positive&quot;</span>
  <span class="ss">:else</span>   <span class="s">&quot;zero&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">condp</span> <span class="nb">= </span><span class="mi">2</span>
  <span class="mi">1</span> <span class="s">&quot;one&quot;</span>
  <span class="mi">2</span> <span class="s">&quot;two&quot;</span>
  <span class="s">&quot;neither&quot;</span><span class="p">)</span>
<span class="c1">;= 2</span>

<span class="p">(</span><span class="nf">condp</span> <span class="nb">some </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
  <span class="o">#</span><span class="p">{</span><span class="mi">0</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">}</span> <span class="ss">:&gt;&gt;</span> <span class="nv">inc</span>
  <span class="o">#</span><span class="p">{</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">9</span><span class="p">}</span> <span class="ss">:&gt;&gt;</span> <span class="nv">dec</span>
  <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="ss">:&gt;&gt;</span> <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">;= 3</span>
</code></pre></figure><h2 id="looping">
<span class="hash">#</span>
<a href="#looping" class="header-link">Looping</a>
</h2>
<p>The special form <code>recur</code> transfers control to the local-most <code>loop</code> or function, allowing recursion without consuming stack space and thereby overflowing the stack. The <code>loop</code> special form takes a vector of binding names and initial values. The final expression is taken as the value of the form itself. The <code>recur</code> special form is considered very low-level that is usually unnecessary, instead opting for <code>doseq</code>, <code>dotimes</code>, <code>map</code>, <code>reduce</code>, <code>for</code>, and so on.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">x</span> <span class="mi">5</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">neg? </span><span class="nv">x</span><span class="p">)</span>
    <span class="nv">x</span>
    <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">countdown</span>
  <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">zero? </span><span class="nv">x</span><span class="p">)</span>
    <span class="ss">:blastoff!</span>
    <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">println </span><span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">x</span><span class="p">)))))</span>
</code></pre></figure><h2 id="java-interop">
<span class="hash">#</span>
<a href="#java-interop" class="header-link">Java Interop</a>
</h2>
<p>The special forms <code>.</code> and <code>new</code> exist for Java interoperability. Their use is somewhat unnatural in Clojure, however, and so there are sugared forms which are idiomatic.</p>

<p>There are also special forms for exception handling and throwing. There are also lock primitives to synchronize on the monitor associated with every Java object, but this is usually unnecessary as there&rsquo;s macro <code>locking</code> that is better suited.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="c1">; instantiation</span>
<span class="p">(</span><span class="k">new </span><span class="nv">java.util.ArrayList</span> <span class="mi">100</span><span class="p">)</span>
<span class="p">(</span><span class="nf">java.util.ArrayList.</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1">; static method</span>
<span class="p">(</span><span class="k">. </span><span class="nv">Math</span> <span class="nv">pow</span> <span class="mi">2</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nf">Math/pow</span> <span class="mi">2</span> <span class="mi">10</span><span class="p">)</span>

<span class="c1">; instance method</span>
<span class="p">(</span><span class="k">. </span><span class="s">&quot;hello&quot;</span> <span class="nv">substring</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nf">.substring</span> <span class="s">&quot;hello&quot;</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1">; static fields</span>
<span class="p">(</span><span class="k">. </span><span class="nv">Integer</span> <span class="nv">MAX_VALUE</span><span class="p">)</span>
<span class="nv">Integer/MAX_VALUE</span>

<span class="c1">; instance field</span>
<span class="p">(</span><span class="k">. </span><span class="nv">some-object</span> <span class="nv">some-field</span><span class="p">)</span>
<span class="p">(</span><span class="nf">.someField</span> <span class="nv">some-object</span><span class="p">)</span>
</code></pre></figure><h2 id="specialized-mutation">
<span class="hash">#</span>
<a href="#specialized-mutation" class="header-link">Specialized Mutation</a>
</h2>
<p>The <code>set!</code> special form can be used to perform in-place mutation of state, which is useful for setting thread-local values, Java fields, or mutable fields.</p>
<h2 id="eval">
<span class="hash">#</span>
<a href="#eval" class="header-link">Eval</a>
</h2>
<p>The <code>eval</code> form evaluates its single argument form, which is useful when used with <code>quote</code> or <code>&#39;</code> to suppress evaluation of the argument until it&rsquo;s evaluated by <code>eval</code>. With this final form, it&rsquo;s possible to reimplement a simple <abbr title="Read-Eval-Print-Loop">REPL</abbr>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">simple-repl</span>
  <span class="s">&quot;Simple REPL. :quit to exit.&quot;</span>
  <span class="p">[]</span>
  <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">ns-name </span><span class="nv">*ns*</span><span class="p">)</span> <span class="s">&quot;&gt;&gt;&gt; &quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">flush</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">expr</span> <span class="p">(</span><span class="nf">read</span><span class="p">)</span>
        <span class="nv">value</span> <span class="p">(</span><span class="nb">eval </span><span class="nv">expr</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">not= </span><span class="ss">:quit</span> <span class="nv">value</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">println </span><span class="nv">value</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">recur</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">simple-repl</span><span class="p">)</span>
</code></pre></figure><h1 id="function-application">
<span class="hash">#</span>
<a href="#function-application" class="header-link">Function Application</a>
</h1>
<p>The <code>apply</code> function can be used to apply a function to arguments, where the last argument can be a collection of arguments to apply, but the complete set of arguments must be passed. The <code>partial</code> function allows <em>partial application</em> by providing only a subset of the arguments, yielding a function that can be used further. The <code>comp</code> function can be used to compose other functions <sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">args</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">-2</span> <span class="mi">10</span><span class="p">])</span>
<span class="p">(</span><span class="nb">apply * </span><span class="mf">0.5</span> <span class="mi">3</span> <span class="nv">args</span><span class="p">)</span>
<span class="c1">;= -60.0</span>

<span class="p">(</span><span class="k">def </span><span class="nv">only-strings</span> <span class="p">(</span><span class="nb">partial filter </span><span class="nv">string?</span><span class="p">))</span>
<span class="p">(</span><span class="nf">only-strings</span> <span class="p">[</span><span class="s">&quot;a&quot;</span> <span class="mi">5</span> <span class="s">&quot;b&quot;</span> <span class="mi">6</span><span class="p">])</span>
<span class="c1">;= (&quot;a&quot; &quot;b&quot;)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">negated-sum-str</span> <span class="p">(</span><span class="nb">comp str - </span><span class="nv">+</span><span class="p">))</span>
<span class="p">(</span><span class="nf">negated-sum-str</span> <span class="mi">10</span> <span class="mi">12</span> <span class="mf">3.4</span><span class="p">)</span>
<span class="c1">;= &quot;-25.4&quot;</span>
</code></pre></figure>
<p>The <code>-&gt;</code> and <code>-&gt;&gt;</code> macros can be used in place of explicitly using <code>comp</code>. The <code>-&gt;</code> macro inserts its first argument as the first argument to the first form, which is very useful when the item is, for example, a Java object on which we&rsquo;re calling methods. The <code>-&gt;&gt;</code> macro on the other hand inserts its first argument as the last argument in the first form, useful for non-object items. This makes it unnecessary to create partial functions, instead simply requiring function calls without the last argument applied:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">composed</span>
  <span class="p">(</span><span class="nb">comp </span><span class="nv">keyword</span>
        <span class="nv">str/join</span>
        <span class="p">(</span><span class="nb">partial </span><span class="nv">interpose</span> <span class="sc">\-</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">partial map </span><span class="nv">str/lower-case</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">composed</span>
  <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nb">map </span><span class="nv">str/lower-case</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">interpose</span> <span class="sc">\-</span><span class="p">)</span>
       <span class="nv">str/join</span>
       <span class="nv">keyword</span><span class="p">))</span>
</code></pre></figure>
<p>Functions can be memoized using the <code>memoize</code> function.</p>
<h1 id="collections">
<span class="hash">#</span>
<a href="#collections" class="header-link">Collections</a>
</h1>
<p>There are a set of core collection functions which allow data structures to participate in the common collection abstraction. These consist of the following functions:</p>

<table>
<thead>
<tr>
<th style="text-align: left">Function</th>
<th style="text-align: left">Purpose</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>conj</code></td>
<td style="text-align: left">add item</td>
</tr>
<tr>
<td style="text-align: left"><code>seq</code></td>
<td style="text-align: left">yield sequence</td>
</tr>
<tr>
<td style="text-align: left"><code>count</code></td>
<td style="text-align: left">count items</td>
</tr>
<tr>
<td style="text-align: left"><code>empty</code></td>
<td style="text-align: left">yield empty instance</td>
</tr>
<tr>
<td style="text-align: left"><code>=</code></td>
<td style="text-align: left">check equality</td>
</tr>
</tbody>
</table>

<p>The <code>conj</code> function has the guarantee that it adds values efficiently, so that it <em>prepends</em> items to lists instead of appending them <sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup>.</p>
<h2 id="sequences">
<span class="hash">#</span>
<a href="#sequences" class="header-link">Sequences</a>
</h2>
<p>Sequences are an abstraction to obtain and traverse sequential views over arbitrary values, such as in a collection. Sequences provide a base set of operations:</p>

<table>
<thead>
<tr>
<th style="text-align: left">Function</th>
<th style="text-align: left">Purpose</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>seq</code></td>
<td style="text-align: left">produces sequence</td>
</tr>
<tr>
<td style="text-align: left"><code>first</code></td>
<td style="text-align: left">yields first item</td>
</tr>
<tr>
<td style="text-align: left"><code>rest</code></td>
<td style="text-align: left">yields items excluding first</td>
</tr>
<tr>
<td style="text-align: left"><code>next</code></td>
<td style="text-align: left">consumes current item</td>
</tr>
<tr>
<td style="text-align: left"><code>lazy-seq</code></td>
<td style="text-align: left">yields lazy sequence</td>
</tr>
</tbody>
</table>

<p>The important distinction between <code>next</code> and <code>rest</code> is that <code>next</code> yields <code>nil</code> when the sequence is empty, whereas <code>rest</code> continues to yield an empty sequence.</p>

<p>Sequences can be constructed using either <code>cons</code> or <code>list*</code>, where <code>cons</code> is similar to the Haskell <code>cons</code>. Unlike <code>conj</code>, which <em>may</em> prepend items in order to satisfy the efficiency guarantee, <code>cons</code> <em>always</em> prepends items. The <code>list*</code> function is a helper which can take any number of head values, followed by a sequence, so that the following two are equivalent:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">cons </span><span class="mi">0</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="p">(</span><span class="nb">range </span><span class="mi">2</span> <span class="mi">5</span><span class="p">)))</span>
<span class="c1">;= (0 1 2 3 4)</span>

<span class="p">(</span><span class="nb">list* </span><span class="mi">0</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">range </span><span class="mi">2</span> <span class="mi">5</span><span class="p">))</span>
<span class="c1">;= (0 1 2 3 4)</span>
</code></pre></figure><h3 id="lazy-sequences">
<span class="hash">#</span>
<a href="#lazy-sequences" class="header-link">Lazy Sequences</a>
</h3>
<p>Sequence contents can be evaluated lazily, where the process of accessing a lazy sequence is referred to as <em>realization</em> <sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup>, such that when all values of a lazy sequence have been computed, it is considered to be <em>fully realized</em>. An important characteristic of the <code>cons</code> and <code>list*</code> functions is that they <em>don't</em> force the evaluation of lazy sequence arguments.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">random-ints</span>
  <span class="p">[</span><span class="nv">limit</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">lazy-seq</span>
    <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">rand-int </span><span class="nv">limit</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">random-ints</span> <span class="nv">limit</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">take </span><span class="mi">3</span> <span class="p">(</span><span class="nf">random-ints</span> <span class="mi">50</span><span class="p">))</span>
<span class="c1">;= (53 23 62)</span>
</code></pre></figure>
<p>The <code>repeatedly</code> function constructs infinite lazy sequences by invoking a given function, so that the above could be simply expressed as:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">repeatedly</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">partial rand-int </span><span class="mi">50</span><span class="p">))</span>
<span class="c1">;= (13 64 36)</span>
</code></pre></figure>
<p>All of the core sequence-processing functions return lazy sequences, such as <code>map</code>, <code>for</code>, <code>filter</code>, <code>take</code>, and <code>drop</code>, so that lazy sequences can be layered without forcing underlying lazy sequences.</p>

<p>The <code>next</code> function is able to return <code>nil</code> instead of an empty sequence because it checks to see if it&rsquo;s empty, and that emptiness check <em>forces</em> the head of the tail sequence <sup id="fnref5"><a href="#fn5" rel="footnote">5</a></sup>. Because sequential destructuring uses <code>next</code> and <em>not</em> <code>rest</code>, it&rsquo;s important to note that destructuring a lazy sequence <em>always</em> realizes the tail&rsquo;s head value.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">x</span> <span class="o">&amp;</span> <span class="nv">rest</span><span class="p">]</span> <span class="p">(</span><span class="nf">random-ints</span> <span class="mi">50</span><span class="p">)])</span>
<span class="c1">; realized random number</span>
<span class="c1">; realized random number</span>
<span class="c1">;= nil</span>
</code></pre></figure>
<p>Laziness in Clojure is mostly used to transparently process big datasets that otherwise wouldn&rsquo;t fit entirely in memory, in order to express algorithms in a more straightforward manner. In this sense, sequences should be viewed as an ephemeral medium of computation, <em>not</em> as collections. In fact, evaluation of some lazy sequences is batched as a performance optimization, which means that some items' side effects can be run ahead of consumption by some amount.</p>

<p>It&rsquo;s possible to force the realization of an entire list with functions <code>doall</code> and <code>dorun</code>, where <code>doall</code> retains the contents of the sequence and <code>dorun</code> disposes of them <sup id="fnref6"><a href="#fn6" rel="footnote">6</a></sup>.</p>
<h3 id="head-retention">
<span class="hash">#</span>
<a href="#head-retention" class="header-link">Head Retention</a>
</h3>
<p>When a reference is held to a sequence, which is done by keeping a reference to the <em>head</em> of a sequence, it implies that the program is interested in that sequence&rsquo;s items. As a result, this prevents garbage collection from occurring on the items of the sequence, which is known as <em>head retention</em>.</p>

<p>Consider the <code>split-with</code> function <sup id="fnref7"><a href="#fn7" rel="footnote">7</a></sup> in the following scenario where a very long sequence is split into a very short prefix and a very long suffix and then both are counted. Lazy processing (counting) of the much longer suffix is negated (i.e. <em>not</em> lazy) due to the fact that a reference to the head of the larger sequence (of which the suffix is a part) is held as <code>t</code>, causing any potentially lazily processed items in the sequence to be retained anyways.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">t</span> <span class="nv">d</span><span class="p">]</span> <span class="p">(</span><span class="nb">split-with </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">%</span> <span class="mi">12</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span><span class="nv">e8</span><span class="p">))]</span>
  <span class="p">[(</span><span class="nb">count </span><span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nb">count </span><span class="nv">t</span><span class="p">)])</span>
<span class="c1">;= #&lt;OutOfMemoryError ...&gt;</span>
</code></pre></figure>
<p>If instead the short prefix were counted first so that the reference to the head of the full sequence were no longer necessary, there would be no reason to retain the elements of the entire sequence (including the longer suffix) and so it could process (count) the suffix lazily.</p>

<p>Inserting into a map or set, or using the <code>=</code> or <code>count</code> functions on a sequence are common causes of potentially premature realization.</p>
<h2 id="associative">
<span class="hash">#</span>
<a href="#associative" class="header-link">Associative</a>
</h2>
<p>Like sequences, associative is an abstraction shared by data structures that associate keys with values, the most common one being a map. These consist of the following functions:</p>

<table>
<thead>
<tr>
<th style="text-align: left">Function</th>
<th style="text-align: left">Purpose</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>assoc</code></td>
<td style="text-align: left">establish new association</td>
</tr>
<tr>
<td style="text-align: left"><code>dissoc</code></td>
<td style="text-align: left">drop association</td>
</tr>
<tr>
<td style="text-align: left"><code>get</code></td>
<td style="text-align: left">get value for given key</td>
</tr>
<tr>
<td style="text-align: left"><code>contains?</code></td>
<td style="text-align: left">check if association exists</td>
</tr>
</tbody>
</table>

<p>The <code>get</code> function returns <code>nil</code> if the key doesn&rsquo;t exist in the association. This poses a problem because it may be intentional to associate <code>nil</code> with a key, making it ambiguous as to whether or not the association exists. The solution is to use <code>find</code>, which always returns the entire association as a tuple, which in Clojure is expressed as a vector.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span><span class="p">}</span> <span class="ss">:b</span><span class="p">)</span>
<span class="c1">;= nil</span>

<span class="p">(</span><span class="nb">find </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span><span class="p">}</span> <span class="ss">:b</span><span class="p">)</span>
<span class="c1">;= nil</span>

<span class="p">(</span><span class="nb">find </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span><span class="p">}</span> <span class="ss">:a</span><span class="p">)</span>
<span class="c1">;= [:a 1]</span>
</code></pre></figure>
<p>The <code>get-in</code> function can yield a value in a nested associative structure given a vector path to the value. Like <code>get</code>, it can accept a default value to return if the path is not found.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">m</span> <span class="p">{</span><span class="ss">:profile</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Test&quot;</span><span class="p">}})</span>

<span class="p">(</span><span class="nf">get-in</span> <span class="nv">m</span> <span class="p">[</span><span class="ss">:profile</span> <span class="ss">:name</span><span class="p">])</span>
<span class="c1">;= &quot;Test&quot;</span>
</code></pre></figure>
<p>The <code>assoc</code> and <code>dissoc</code> functions can be used on multiple sets of values and list of keys, respectively.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">assoc </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">}</span>
  <span class="ss">:c</span> <span class="mi">3</span>
  <span class="ss">:d</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">;= {:a 1, :b 2, :c 3, :d 4}</span>

<span class="p">(</span><span class="nb">dissoc </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">}</span>
  <span class="ss">:a</span>
  <span class="ss">:b</span><span class="p">)</span>
<span class="c1">;= {}</span>
</code></pre></figure><h2 id="indexed">
<span class="hash">#</span>
<a href="#indexed" class="header-link">Indexed</a>
</h2>
<p>The indexed abstraction works on things that can be numerically indexed, such as vectors, lists, sequences, Java arrays and lists, strings, and regular expression matchers.</p>

<p>The <code>get</code> and <code>assoc</code> functions can also be used on vectors, where the indices would serve as the keys. There also exists the function <code>nth</code> which works the same way except that <code>nth</code> returns an exception when an index is out of bounds. However, both can be provided a default return value, in which case their semantics are identical. The <code>get</code> function is more resilient than <code>nth</code> since it returns <code>nil</code> when the subject of the lookup is unsupported.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">get </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">;= 2</span>

<span class="p">(</span><span class="nb">nth </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">;= exception</span>

<span class="p">(</span><span class="nb">nth </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">5</span> <span class="ss">:not-found</span><span class="p">)</span>
<span class="p">(</span><span class="nb">get </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">5</span> <span class="ss">:not-found</span><span class="p">)</span>
<span class="c1">;= :not-found</span>

<span class="p">(</span><span class="nb">get </span><span class="mi">42</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">;= nil</span>

<span class="p">(</span><span class="nb">nth </span><span class="mi">42</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">;= exception</span>
</code></pre></figure><h2 id="stacks">
<span class="hash">#</span>
<a href="#stacks" class="header-link">Stacks</a>
</h2>
<p>Clojure doesn&rsquo;t have a distinct stack type, but it supports stack operations on lists and vectors through the following functions:</p>

<table>
<thead>
<tr>
<th style="text-align: left">Function</th>
<th style="text-align: left">Purpose</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>conj</code></td>
<td style="text-align: left">push value</td>
</tr>
<tr>
<td style="text-align: left"><code>pop</code></td>
<td style="text-align: left">pop value</td>
</tr>
<tr>
<td style="text-align: left"><code>peek</code></td>
<td style="text-align: left">peek top value</td>
</tr>
</tbody>
</table>
<h2 id="sets">
<span class="hash">#</span>
<a href="#sets" class="header-link">Sets</a>
</h2>
<p>Sets can be added to with <code>conj</code> and can be tested for membership with <code>get</code>, acting like associations of items with themselves. There&rsquo;s also a <code>disj</code> which can be used to remove items from a set.</p>
<h2 id="sorted">
<span class="hash">#</span>
<a href="#sorted" class="header-link">Sorted</a>
</h2>
<p>The sorted abstraction guarantees that items in the collection will be maintained in a stable ordering. This abstraction supports maps and sets with following functions:</p>

<table>
<thead>
<tr>
<th style="text-align: left">Function</th>
<th style="text-align: left">Purpose</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>rseq</code></td>
<td style="text-align: left">reverse sequence in constant time</td>
</tr>
<tr>
<td style="text-align: left"><code>subseq</code></td>
<td style="text-align: left">return sequence of values within a certain range</td>
</tr>
<tr>
<td style="text-align: left"><code>rsubseq</code></td>
<td style="text-align: left">reversed <code>subseq</code></td>
</tr>
</tbody>
</table>

<p>Sorted maps and sets can be created with <code>sorted-map</code>, <code>sorted-set</code>, or with the <code>sorted-map-by</code> and <code>sorted-set-by</code> functions which accept a predicate or comparator which defines the sort order.</p>

<p>Comparators are functions that return an integer of value <code>-1</code>, <code>0</code>, or <code>1</code> depending on if the first argument is less than, equal to, or greater than the second argument. Any two-argument predicate can automatically be converted to a comparator using simple logic by treating the predicate as if it were <code>&lt;</code>.</p>

<ol>
<li>if the predicate returns true, return <code>-1</code></li>
<li>otherwise, flip the arguments

<ol>
<li>if true, return <code>1</code></li>
<li>else, return <code>0</code></li>
</ol></li>
</ol>

<p>This may be a possible implementation:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">comparator</span>
  <span class="p">[</span><span class="nv">f</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">f</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
      <span class="mi">-1</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">f</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))))</span>
</code></pre></figure>
<p>It&rsquo;s important to note that sort order, i.e. the comparator, defines the equality operation to use within a sorted collection. This can be fixed by delegating equality to a more general comparison function such as <code>compare</code> when the comparator results in <code>0</code>.</p>
<h2 id="accessing">
<span class="hash">#</span>
<a href="#accessing" class="header-link">Accessing</a>
</h2>
<p>Collections can also be used as functions that can be used to access values within a collection. For maps, an optional default return value can be provided, as with <code>get</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">([</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">;= :c</span>

<span class="p">({</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">}</span> <span class="ss">:b</span><span class="p">)</span>
<span class="c1">;= 2</span>

<span class="p">({</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">3</span><span class="p">}</span> <span class="ss">:z</span> <span class="ss">:not-found</span><span class="p">)</span>
<span class="c1">;= :not-found</span>
</code></pre></figure>
<p>Similarly, keywords and symbols are also functions that look themselves up in the provided collection. This is the recommended, idiomatic form of accessing values in a collection, as it helps avoid null pointer exceptions. This also makes them amenable for use as higher-order functions.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="ss">:b</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">3</span><span class="p">})</span>
<span class="c1">;= 3</span>

<span class="p">(</span><span class="ss">:c</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">5</span> <span class="ss">:b</span> <span class="mi">3</span><span class="p">}</span> <span class="ss">:not-found</span><span class="p">)</span>
<span class="c1">;= :not-found</span>

<span class="p">(</span><span class="nb">map </span><span class="ss">:name</span> <span class="p">[{</span><span class="ss">:age</span> <span class="mi">1</span> <span class="ss">:name</span> <span class="s">&quot;Tom&quot;</span><span class="p">}</span>
            <span class="p">{</span><span class="ss">:age</span> <span class="mi">2</span> <span class="ss">:name</span> <span class="s">&quot;Dick&quot;</span><span class="p">}</span>
            <span class="p">{</span><span class="ss">:age</span> <span class="mi">3</span> <span class="ss">:name</span> <span class="s">&quot;Harry&quot;</span><span class="p">}])</span>
<span class="c1">;= (&quot;Tom&quot; &quot;Dick&quot; &quot;Harry&quot;)</span>
</code></pre></figure>
<p>For example, the <code>some</code> function returns the first item in a sequence that satisfies a given predicate. This can be used with a set to find the first item in a sequence that is contained in the set.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">7</span><span class="p">}</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">])</span>
<span class="c1">;= 1</span>
</code></pre></figure>
<p>However, this can pose a problem when the set in question contains either <code>false</code> or <code>nil</code>, since sets return their own value if they&rsquo;re present in the set, and those two values are logically false. In these situations, it would be more appropriate to use <code>contains?</code> <sup id="fnref8"><a href="#fn8" rel="footnote">8</a></sup>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">remove </span><span class="o">#</span><span class="p">{</span><span class="mi">5</span> <span class="mi">7</span><span class="p">}</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">false</span> <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">)))</span>
<span class="c1">;= (false 0 1 2)</span>

<span class="p">(</span><span class="nb">remove </span><span class="o">#</span><span class="p">{</span><span class="mi">5</span> <span class="mi">7</span> <span class="nv">false</span><span class="p">}</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">false</span> <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">)))</span>
<span class="c1">;= (false 0 1 2)</span>

<span class="p">(</span><span class="nb">remove </span><span class="p">(</span><span class="nb">partial contains? </span><span class="o">#</span><span class="p">{</span><span class="mi">5</span> <span class="mi">7</span> <span class="nv">false</span><span class="p">})</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">false</span> <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">)))</span>
<span class="c1">;= (0 1 2)</span>
</code></pre></figure><h2 id="constructing">
<span class="hash">#</span>
<a href="#constructing" class="header-link">Constructing</a>
</h2>
<p>It&rsquo;s important to remember that list literals are the form in which code is specified in Clojure. To define an actual list without evaluating it as a function call, it&rsquo;s necessary to quote it so that it&rsquo;s not evaluated. This has the consequence of not evaluating any of the members, which may not be the intention. For this reason, the <code>list</code> function exists which evaluates each argument and uses the result as an element in the list.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">;= (1 2 (+ 1 2))</span>

<span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">;= (1 2 3)</span>
</code></pre></figure>
<p>Vectors can be constructed using the <code>vector</code> function, which is similar to <code>list</code>, or the <code>vec</code> function which accepts a sequence. Vectors are the type used to represent tuples.</p>

<p>Sets can be created from any sequence using the <code>set</code> function, similar to <code>vec</code>.</p>
<h2 id="transients">
<span class="hash">#</span>
<a href="#transients" class="header-link">Transients</a>
</h2>
<p>Transient collections are mutable and, as a result, any reference to an old version of a transient collection may no longer be valid. Only vectors, unsorted maps, and sets can be transients. Transient collections are usually used within functions, such as those in the core, for purposes of efficiency, and are typically publicly exposed as immutable, persistent collections.</p>

<p>Transients have their own collection manipulation functions that end in a <code>!</code> to signify that they are destructive. Using any of these functions on a transient renders that reference to the transient invalid. Instead, the <em>result</em> of these calls should be used going forward, just as with the persistent equivalents.</p>

<ul>
<li><code>conj!</code></li>
<li><code>assoc!</code></li>
<li><code>dissoc!</code></li>
<li><code>disj!</code></li>
<li><code>pop!</code></li>
</ul>

<p>The <code>transient</code> function can turn any persistent collection into a transient one, and the <code>persistent!</code> function can turn a transient back into a persistent. Converting a transient into a persistent makes the transient unusable.</p>

<p>Consider this possible implementation of <code>into</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">into</span>
  <span class="p">[</span><span class="nv">coll</span> <span class="nv">source</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">persistent!</span> <span class="p">(</span><span class="nb">reduce </span><span class="nv">conj!</span> <span class="p">(</span><span class="nf">transient</span> <span class="nv">coll</span><span class="p">)</span> <span class="nv">source</span><span class="p">)))</span>
</code></pre></figure>
<p>Transients have a concurrency safeguard to ensure that only the thread that created it can use or modify it. Transients don&rsquo;t have value semantics due to being mutable.</p>
<h1 id="metadata">
<span class="hash">#</span>
<a href="#metadata" class="header-link">Metadata</a>
</h1>
<p>Metadata is expressed as a map and can be attached to data structures, sequences, records, symbols, or reference types. There is reader syntax for attaching metadata to a value literal. Metadata that contains only keyword keys and whose value is <code>true</code> can be provided in shorter form, and can stack onto the next metadata values.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="o">^</span><span class="p">{</span><span class="ss">:created</span> <span class="p">(</span><span class="nf">System/currentTimeMillis</span><span class="p">)}</span>
  <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>

<span class="p">(</span><span class="nb">meta </span><span class="nv">a</span><span class="p">)</span>
<span class="c1">;= {:created 134134141234}</span>

<span class="p">(</span><span class="nb">meta </span><span class="o">^</span><span class="ss">:private</span> <span class="o">^</span><span class="ss">:dynamic</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1">;= {:dynamic true, :private true}</span>
</code></pre></figure>
<p>The <code>with-meta</code> function yields an object of the same type and object as a given object, but with the provided metadata. The <code>vary-meta</code> function does the same thing but instead takes a function that modifies the original object&rsquo;s metadata to use its result as its metadata.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="o">^</span><span class="p">{</span><span class="ss">:key</span> <span class="mi">1</span><span class="p">}</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="nv">a</span>
<span class="c1">;= [1 2 3]</span>

<span class="p">(</span><span class="nb">meta </span><span class="nv">a</span><span class="p">)</span>
<span class="c1">;= {:key 1}</span>

<span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="p">(</span><span class="nb">with-meta </span><span class="nv">a</span> <span class="p">{</span><span class="ss">:other</span> <span class="mi">4</span><span class="p">}))</span>
<span class="nv">b</span>
<span class="c1">;= [1 2 3]</span>

<span class="p">(</span><span class="nb">meta </span><span class="nv">b</span><span class="p">)</span>
<span class="c1">;= {:other 4}</span>

<span class="p">(</span><span class="k">def </span><span class="nv">c</span> <span class="p">(</span><span class="nf">vary-meta</span> <span class="nv">b</span> <span class="nb">assoc </span><span class="ss">:newkey</span> <span class="mi">2</span><span class="p">))</span>
<span class="nv">c</span>
<span class="c1">;= [1 2 3]</span>

<span class="p">(</span><span class="nb">meta </span><span class="nv">c</span><span class="p">)</span>
<span class="c1">;= {:other 4, :newkey 2}</span>
</code></pre></figure><h1 id="zippers">
<span class="hash">#</span>
<a href="#zippers" class="header-link">Zippers</a>
</h1>
<p>Zippers are a stack of all nodes traversed, thereby serving as a cursor into a data structure <sup id="fnref9"><a href="#fn9" rel="footnote">9</a></sup>. The <span class="path">clojure.zip</span> namespace provides a <code>zipper</code> factory and specialized zipper instances <code>seq-zip</code> for nested sequences, <code>vector-zip</code> for nested vectors, and <code>xml-zip</code> for <span class="path">clojure.xml</span>.</p>

<p>Zippers can be moved with operations <code>up</code> and <code>down</code>, <code>left</code> and <code>right</code> to move along siblings, <code>prev</code> and <code>next</code> which are depth-first traversals, and <code>leftmost</code> and <code>rightmost</code> to move to the first or last sibling.</p>

<p>The <code>node</code>, <code>branch?</code>, <code>children</code>, <code>lefts</code>, <code>rights</code>, and <code>root</code> function can be used to respectively yield the current node, whether it&rsquo;s a branch, the child nodes, all left or right siblings of the current nodes. When operating on trees, the <code>root</code> function is used to yield an updated tree which reflects all of the modifications made by the zipper since its creation.</p>

<p>Zippers can manipulate the structure they&rsquo;re representing with the <code>remove</code> function to remove the current node, <code>replace</code> it with another node, <code>insert</code> a child node at the front, or <code>append</code> it to the back. The <code>edit</code> function takes a function and extra arguments which replaces the current node with the result of applying the current node and the extra arguments to that function. The <code>make-node</code> function can also be used to create a new node, but it won&rsquo;t be added unless one of the above functions are used.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.zip</span> <span class="ss">:as</span> <span class="nv">z</span><span class="p">])</span>

<span class="p">(</span><span class="k">def </span><span class="nv">v</span> <span class="p">[[</span><span class="mi">1</span> <span class="mi">2</span> <span class="p">[</span><span class="mi">3</span> <span class="mi">4</span><span class="p">]]</span> <span class="p">[</span><span class="mi">5</span> <span class="mi">6</span><span class="p">]])</span>

<span class="p">(</span><span class="nb">-&gt; </span><span class="nv">v</span> <span class="nv">z/vector-zip</span> <span class="nv">z/down</span> <span class="nv">z/right</span> <span class="p">(</span><span class="nf">z/replace</span> <span class="mi">56</span><span class="p">)</span> <span class="nv">z/node</span><span class="p">)</span>
<span class="c1">;= 56</span>

<span class="p">(</span><span class="nb">-&gt; </span><span class="nv">v</span> <span class="nv">z/vector-zip</span> <span class="nv">z/down</span> <span class="nv">z/right</span> <span class="p">(</span><span class="nf">z/replace</span> <span class="mi">56</span><span class="p">)</span> <span class="nv">z/root</span><span class="p">)</span>
<span class="c1">;= [[1 2 [3 4]] 56]</span>

<span class="p">(</span><span class="nb">-&gt; </span><span class="nv">v</span> <span class="nv">z/vector-zip</span> <span class="nv">z/down</span> <span class="nv">z/right</span> <span class="nv">z/remove</span> <span class="nv">z/node</span><span class="p">)</span>
<span class="c1">;= 4</span>

<span class="p">(</span><span class="nb">-&gt; </span><span class="nv">v</span> <span class="nv">z/vector-zip</span> <span class="nv">z/down</span> <span class="nv">z/right</span> <span class="nv">z/remove</span> <span class="nv">z/root</span><span class="p">)</span>
<span class="c1">;= [[1 2 [3 4]]]</span>

<span class="p">(</span><span class="nb">-&gt; </span><span class="nv">v</span> <span class="nv">z/vector-zip</span> <span class="nv">z/down</span> <span class="nv">z/right</span> <span class="p">(</span><span class="nf">z/edit</span> <span class="nb">* </span><span class="mi">42</span><span class="p">)</span> <span class="nv">z/root</span><span class="p">)</span>
<span class="c1">;= [[1 84 [3 4]] [5 6]]</span>
</code></pre></figure>
<p>Custom zippers can be created with the <code>zipper</code> function which takes three functions:</p>

<ol>
<li>predicate that determines if a node can have children</li>
<li>function that yields a sequence of a given branch&rsquo;s children</li>
<li>function that returns a new branch node given an existing node and a sequence of children</li>
</ol>

<p>Consider creating a zipper for HTML elements represented as vectors and maps.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">el</span> <span class="p">[</span><span class="ss">:body</span> <span class="p">[</span><span class="ss">:h1</span> <span class="s">&quot;Clojure&quot;</span><span class="p">]</span>
               <span class="p">[</span><span class="ss">:p</span> <span class="s">&quot;Is very flexible&quot;</span><span class="p">]])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">html-zip</span> <span class="p">[</span><span class="nv">root</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">z/zipper</span>
    <span class="c1">; predicate for if node can have children</span>
    <span class="nv">vector?</span>
    <span class="c1">; yield sequence of branch&#39;s children</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">tagname</span> <span class="o">&amp;</span> <span class="nv">xs</span><span class="p">]]</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">map? </span><span class="p">(</span><span class="nb">first </span><span class="nv">xs</span><span class="p">))</span> <span class="p">(</span><span class="nb">next </span><span class="nv">xs</span><span class="p">)</span> <span class="nv">xs</span><span class="p">))</span>
    <span class="c1">; return new branch node given existing node</span>
    <span class="c1">; and sequence of children</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[[</span><span class="nv">tagname</span> <span class="o">&amp;</span> <span class="nv">xs</span><span class="p">]</span> <span class="nv">children</span><span class="p">]</span>
      <span class="p">(</span><span class="nb">into </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">map? </span><span class="p">(</span><span class="nb">first </span><span class="nv">xs</span><span class="p">))</span> <span class="p">[</span><span class="nv">tagname</span> <span class="p">(</span><span class="nb">first </span><span class="nv">xs</span><span class="p">)]</span> <span class="p">[</span><span class="nv">tagname</span><span class="p">])</span>
        <span class="nv">children</span><span class="p">))</span>
    <span class="nv">root</span><span class="p">))</span>
</code></pre></figure>
<p>A helper function can be created that operates on a zipper, such as one to wrap a DOM node in another tag.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">wrap</span>
  <span class="p">[</span><span class="nv">loc</span> <span class="nv">tag</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">z/edit</span> <span class="nv">loc</span> <span class="o">#</span><span class="p">(</span><span class="nb">vector </span><span class="nv">tag</span> <span class="nv">%</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">-&gt; </span><span class="nv">el</span> <span class="nv">html-zip</span> <span class="nv">z/down</span> <span class="nv">z/right</span> <span class="nv">z/down</span> <span class="p">(</span><span class="nf">wrap</span> <span class="ss">:b</span><span class="p">)</span> <span class="nv">z/root</span><span class="p">)</span>
<span class="c1">;= [:body [:h1 &quot;Clojure&quot;] [:p [:b &quot;Is very flexible&quot;]]]</span>
</code></pre></figure><h1 id="concurrency-and-parallelism">
<span class="hash">#</span>
<a href="#concurrency-and-parallelism" class="header-link">Concurrency and Parallelism</a>
</h1>
<p>It&rsquo;s possible to use delays, futures, and promises to control when and how computations are performed.</p>
<h2 id="delays">
<span class="hash">#</span>
<a href="#delays" class="header-link">Delays</a>
</h2>
<p>The <code>delay</code> function suspends some body of code such that it&rsquo;s evaluation is delayed until it&rsquo;s explicitly <em>dereferenced</em> with <code>deref</code>. There exists convenient reader syntax for dereferencing as <code>@</code>, which is in fact almost always preferred, except for when <code>deref</code> is used as a higher-order function or when wanting to set a timeout. Many Clojure types are dereferenceable including delays, futures, promises, atoms, refs, agents, and vars.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">d</span> <span class="p">(</span><span class="nf">delay</span> <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Running...&quot;</span><span class="p">)</span>
              <span class="ss">:done!</span><span class="p">))</span>

<span class="p">(</span><span class="nb">deref </span><span class="nv">d</span><span class="p">)</span> <span class="c1">; or @d</span>
<span class="c1">; Running...</span>
<span class="c1">;= :done!</span>
</code></pre></figure>
<p>The difference between delays and regular functions is that delays evaluate their body only once and from then on cache the return value so that subsequent dereferences are instant. The relation to this and concurrency is that multiple threads can safely attempt to dereference a delay and all of them will block until the delay is evaluated.</p>

<p>The <code>realized?</code> function can check if a delay has been materialized yet. This function can also be used with futures, promises, and lazy sequences.</p>
<h2 id="futures">
<span class="hash">#</span>
<a href="#futures" class="header-link">Futures</a>
</h2>
<p>A future evaluates a body of code in another thread. A future returns immediately, allowing the current thread to continue execution. The future can be dereferenced to access the return value of the future, which will naturally block if the separate thread isn&rsquo;t finished computing. An upper-bound can be placed on the amount of time that is spent blocking by providing a timeout and a timeout value.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">long-calculation</span> <span class="p">(</span><span class="nf">future</span> <span class="p">(</span><span class="nb">apply + </span><span class="p">(</span><span class="nb">range </span><span class="mi">1</span><span class="nv">e8</span><span class="p">))))</span>
<span class="o">@</span><span class="nv">long-calculation</span>
<span class="c1">;= 4999999950000000</span>

<span class="o">@</span><span class="p">(</span><span class="nf">future</span> <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">5000</span><span class="p">)</span> <span class="ss">:done!</span><span class="p">)</span>
<span class="c1">;= &lt;blocked for 5 seconds&gt;</span>
<span class="c1">;= :done!</span>

<span class="p">(</span><span class="nb">deref </span><span class="p">(</span><span class="nf">future</span> <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">5000</span><span class="p">)</span> <span class="ss">:done!</span><span class="p">)</span>
               <span class="mi">1000</span>
               <span class="ss">:impatient!</span><span class="p">)</span>
<span class="c1">;= :impatient!</span>
</code></pre></figure><h2 id="promises">
<span class="hash">#</span>
<a href="#promises" class="header-link">Promises</a>
</h2>
<p>Promises are like delays and futures, except that they are not created with any code that will eventually define their value. Instead, they&rsquo;re initially an empty container which can be filled at a later point in time using the <code>deliver</code> function. Like delays and futures, dereferencing a promise will block until there&rsquo;s a value to provide; timeouts can be specified <sup id="fnref10"><a href="#fn10" rel="footnote">10</a></sup>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">p</span> <span class="p">(</span><span class="nf">promise</span><span class="p">))</span>
<span class="p">(</span><span class="nf">realized?</span> <span class="nv">p</span><span class="p">)</span>
<span class="c1">;= false</span>

<span class="p">(</span><span class="nf">deliver</span> <span class="nv">p</span> <span class="mi">42</span><span class="p">)</span>
<span class="p">(</span><span class="nf">realized?</span> <span class="nv">p</span><span class="p">)</span>
<span class="c1">;= true</span>

<span class="o">@</span><span class="nv">p</span>
<span class="c1">;= 42</span>
</code></pre></figure><h2 id="watches">
<span class="hash">#</span>
<a href="#watches" class="header-link">Watches</a>
</h2>
<p>Watches are functions that are called whenever the state of a reference is changed, though not necessarily to a different value. For that reason, it&rsquo;s common for watch functions to check that the new value is different before proceeding. Watches take four arguments: a key, the reference, its old state, and its new state. The watch function can be registered on a reference with the <code>add-watch</code> function which takes the reference, the key to associate with the watch, and the function. The key associated with the watch can also be used to remove the watch later on.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">echo-watch</span>
  <span class="p">[</span><span class="nb">key identity </span><span class="nv">old</span> <span class="nv">new</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">println key </span><span class="nv">old</span> <span class="s">&quot;=&gt;&quot;</span> <span class="nv">new</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">sarah</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Sarah&quot;</span> <span class="ss">:age</span> <span class="mi">25</span><span class="p">}))</span>
<span class="p">(</span><span class="nf">add-watch</span> <span class="nv">sarah</span> <span class="ss">:echo</span> <span class="nv">echo-watch</span><span class="p">)</span>

<span class="p">(</span><span class="nf">swap!</span> <span class="nv">sarah</span> <span class="nv">update-in</span> <span class="p">[</span><span class="ss">:age</span><span class="p">]</span> <span class="nv">inc</span><span class="p">)</span>
<span class="c1">; :echo {:name Sarah, age 25} =&gt; {:name Sarah, :age 26}</span>

<span class="p">(</span><span class="nf">remove-watch</span> <span class="nv">sarah</span> <span class="ss">:echo</span><span class="p">)</span>
</code></pre></figure>
<p>It&rsquo;s important to note that the watch functions are called synchronously on the same thread that caused the state change, such that by the time the watch function is called, the value could have been changed again by another thread. For this reason it&rsquo;s important to rely only on the <code>old</code> and <code>new</code> values passed to the watch function instead of dereferencing the reference.</p>
<h2 id="validators">
<span class="hash">#</span>
<a href="#validators" class="header-link">Validators</a>
</h2>
<p>Validators are essentially constraints on reference state. It consists of a single argument function which takes the proposed new state, and if the result is logically false or throws an exception, the change is aborted with an exception.</p>

<p>A validator can be attached at the time of creation by passing a key-value pair to <code>atom</code>, <code>ref</code>, or <code>agent</code> consisting of the key <code>:validator</code> and the function to use. Alternatively, it&rsquo;s possible to add a validator to a var, or change a validator associated with an atom, ref, or agent using the <code>set-validator!</code> function.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="c1">;= constrains state to positive values</span>
<span class="p">(</span><span class="k">def </span><span class="nv">n</span> <span class="p">(</span><span class="nf">atom</span> <span class="mi">1</span> <span class="ss">:validator</span> <span class="nv">pos?</span><span class="p">))</span>
<span class="p">(</span><span class="nf">swap!</span> <span class="nv">n</span> <span class="nb">+ </span><span class="mi">500</span><span class="p">)</span>
<span class="c1">;= 501</span>

<span class="p">(</span><span class="nf">swap!</span> <span class="nv">n</span> <span class="nb">- </span><span class="mi">1000</span><span class="p">)</span>
<span class="c1">;= #&lt;IllegalStateException ...&gt;</span>

<span class="p">(</span><span class="k">def </span><span class="nv">sarah</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Sarah&quot;</span> <span class="ss">:age</span> <span class="mi">25</span><span class="p">}))</span>
<span class="p">(</span><span class="nf">set-validator!</span> <span class="nv">sarah</span> <span class="ss">:age</span><span class="p">)</span>
</code></pre></figure>
<p>The default thrown exception can be made more descriptive by assuring that the validator we use throws its own exception with a more descriptive string.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">set </span><span class="nv">validator!</span> <span class="nv">sarah</span>
     <span class="o">#</span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="ss">:age</span> <span class="nv">%</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">throw</span> <span class="p">(</span><span class="nf">IllegalStateException.</span> <span class="s">&quot;People must have `:age`s!&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">swap!</span> <span class="nv">sarah</span> <span class="nb">dissoc </span><span class="ss">:age</span><span class="p">)</span>

<span class="c1">;= #&lt;IllegalStateException ... People must have `:age`s!&gt;</span>
</code></pre></figure><h2 id="parallelization-strategies">
<span class="hash">#</span>
<a href="#parallelization-strategies" class="header-link">Parallelization Strategies</a>
</h2>
<p>The <code>pmap</code> function can be used to perform a <code>map</code> in parallel, evenly spread across available computational cores. However, as usual, the parallelization overhead must be taken into account with respect to the work being done, so that the overhead doesn&rsquo;t outweigh the computation itself. In the event that it does, however, a common workaround is to chunk the dataset so that each unit of work is larger.</p>

<p>Two other constructs are built on top of <code>pmap</code>: the <code>pcalls</code> function evaluates a variable number of zero-arity functions, yielding a lazy sequence of their return values, while the <code>pvalues</code> function does the same but for a variable number of expressions.</p>
<h2 id="reference-types">
<span class="hash">#</span>
<a href="#reference-types" class="header-link">Reference Types</a>
</h2>
<p>References are essentially boxes that hold a value which can be changed by certain functions, depending on the reference type. The value &ldquo;within&quot; can be accessed using the <code>deref</code> function, which will <em>never</em> block for reference types. The four reference types are <code>var</code>, <code>ref</code>, <code>agent</code>, and <code>atom</code>. Each of these reference types are intended for use in different concurrent operations.</p>

<table>
  <thead>
    <tr>
      <td style="background-color: #D0E9FF"></td>
      <th>coordinated</th>
      <th>uncoordinated</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>synchronous</th>
      <td style="text-align: center">refs</td>
      <td style="text-align: center">atoms</td>
    </tr>
    <tr>
      <th>asynchronous</th>
      <td style="text-align: center">N/A</td>
      <td style="text-align: center">agents</td>
    </tr>
  </tbody>
</table>

<p>Reference types can be decorated with metadata, although the metadata can only be changed using the <code>after-meta!</code> function which modifies it in-place. The metadata for <code>atom</code>, <code>ref</code>, and <code>agent</code> references can be specified using an optional <code>:meta</code> keyword argument. Reference types can notify specified functions when their state changes, where the functions are known as <em>watches</em>. Changes to the state that reference types hold can be validated with <em>validator</em> functions, potentially aborting non-conforming change operations.</p>
<h3 id="atoms">
<span class="hash">#</span>
<a href="#atoms" class="header-link">Atoms</a>
</h3>
<p>Atoms are the most basic reference type which implement synchronous, uncoordinated, atomic compare-and-set modifications. Operations that modify the state of atoms block until the modification is complete, i.e. the modifications are atomic.</p>

<p>The <code>atom</code> function is used to create an atom, and the <code>swap!</code> function is the most common modification operation used on them, which replaces the value of the atom with the result of applying some function and additional arguments to its present value, returning the new value.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">sarah</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Sarah&quot;</span> <span class="ss">:age</span> <span class="mi">25</span> <span class="ss">:wears-glasses?</span> <span class="nv">false</span><span class="p">}))</span>

<span class="c1">; this sets the atom&#39;s value to</span>
<span class="c1">; (update-in @sarah [:age] + 3)</span>
<span class="p">(</span><span class="nf">swap!</span> <span class="nv">sarah</span> <span class="nv">update-in</span> <span class="p">[</span><span class="ss">:age</span><span class="p">]</span> <span class="nb">+ </span><span class="mi">3</span><span class="p">)</span>
<span class="c1">;= {:age 28, :wears-glasses? false, :name &quot;Sarah&quot;}</span>
</code></pre></figure>
<p>Since atoms use compare-and-set semantics, if the value of the atom changes (i.e. by another thread) before the new value is finished computing, it will abort the update and re-attempt based off of the new value, doing so until the original value remains the same when the new value is computed.</p>

<p>Since atoms are synchronous reference types, functions that change their values don&rsquo;t return until they have completed.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nf">atom</span> <span class="mi">2000</span><span class="p">))</span>
<span class="p">(</span><span class="nf">swap!</span> <span class="nv">x</span> <span class="o">#</span><span class="p">(</span><span class="nf">Thread/sleep</span> <span class="nv">%</span><span class="p">))</span> <span class="c1">;= blocks for 2 seconds</span>
<span class="c1">;= nil</span>
</code></pre></figure>
<p>A more direct function <code>compare-and-set!</code> can be used if we already know the value that the atom currently holds. The function returns a boolean indicating whether the value was indeed changed, which happens only if the value provided is indeed what&rsquo;s currently in the atom.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="nf">atom</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nf">compare-and-set!</span> <span class="nv">a</span> <span class="mi">10</span> <span class="mi">20</span><span class="p">)</span>
<span class="c1">;= false</span>

<span class="p">(</span><span class="nf">compare-and-set!</span> <span class="nv">a</span> <span class="mi">0</span> <span class="mi">20</span><span class="p">)</span>
<span class="c1">;= true</span>

<span class="o">@</span><span class="nv">a</span>
<span class="mi">10</span>
</code></pre></figure>
<p>Note that this function doesn&rsquo;t use value semantics when comparing the provided value to the value inside the atom. Instead, the value must be <code>identical?</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">xs</span> <span class="p">(</span><span class="nf">atom</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span><span class="p">}))</span>
<span class="p">(</span><span class="nf">compare-and-set!</span> <span class="nv">xs</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span><span class="p">}</span> <span class="s">&quot;new value&quot;</span><span class="p">)</span>
<span class="c1">;= false</span>
</code></pre></figure>
<p>We can also completely overwrite the contained value using the <code>reset!</code> function, regardless of what its current value may be.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">reset!</span> <span class="nv">xs</span> <span class="ss">:y</span><span class="p">)</span>
<span class="c1">;= :y</span>

<span class="o">@</span><span class="nv">xs</span>
<span class="c1">;= :y</span>
</code></pre></figure><h3 id="refs">
<span class="hash">#</span>
<a href="#refs" class="header-link">Refs</a>
</h3>
<p>Refs are the coordinate reference type which ensure that multiple identities can be used with concurrent operations with:</p>

<ul>
<li>no possibility of being in an observable inconsistent state</li>
<li>no possibility of race conditions or deadlocks</li>
<li>no manual use of locks, monitors, or other synchronization primitives</li>
</ul>

<p>See the section on <a href="#software-transactional-memory">Software Transactional Memory</a> for more information.</p>
<h3 id="vars">
<span class="hash">#</span>
<a href="#vars" class="header-link">Vars</a>
</h3>
<p>Vars are generally used implicitly in Clojure. Top-level functions and values are stored in vars, which are defined in the current namespace using the special form <code>def</code> or its derivatives, which also copies the metadata provided. <a href="#symbols">Recall</a> that vars can be created with reader syntax <code>#&#39;</code>, but they can also be explicitly created using the <code>var</code> function.</p>

<blockquote>
<p>Words are pale shadows of forgotten names. As names have power, words have power. Words can light fires in the minds of men. Words can wring tears from the hardest hearts. There are seven words that will break a strong man&rsquo;s will. But a word is nothing but a painting of a fire. A name is the fire itself.</p>

<p><cite><strong>The Name of the Wind</strong> by Patrick Rothfuss</cite></p>
</blockquote>

<p>Evaluating a symbol involves looking for a var with the name of the symbol in the current namespace and dereferencing it to obtain its value. The above passage reminds me of this relationship, where words are to names as symbols are to vars.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="nv">map</span>
<span class="c1">;= #&lt;core$map ...&gt;</span>

<span class="o">#</span><span class="ss">&#39;map</span>
<span class="c1">;= #&#39;clojure.core/map</span>

<span class="o">@#</span><span class="ss">&#39;map</span>
<span class="c1">;= #&lt;core$map ...&gt;</span>
</code></pre></figure><h4 id="private-vars">
<span class="hash">#</span>
<a href="#private-vars" class="header-link">Private Vars</a>
</h4>
<p>Private vars can only be referred to using the fully qualified name when in another namespace and their value can only be manually dereferenced. They&rsquo;re created by providing the <code>:private</code> metadata key as true. The <code>defn-</code> form creates private functions.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="c1">; in user namespace</span>
<span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:private</span> <span class="nv">everything</span> <span class="mi">42</span><span class="p">)</span>

<span class="c1">; switch to other namespace</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">other-namespace</span><span class="p">)</span>

<span class="p">(</span><span class="nb">refer </span><span class="ss">&#39;user</span><span class="p">)</span>
<span class="c1">;= nil</span>

<span class="nv">everything</span>
<span class="c1">;= #&lt;CompilerException ...&gt;</span>

<span class="o">@#</span><span class="ss">&#39;user/everything</span>
<span class="c1">;= 42</span>
</code></pre></figure><h4 id="docstrings">
<span class="hash">#</span>
<a href="#docstrings" class="header-link">Docstrings</a>
</h4>
<p>Docstrings are string literals that serve as documentation for top-level vars, immediately following the symbol name. The <code>def</code> form actually takes the docstring as an optional argument and sets the <code>:doc</code> metadata key to its value.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span>
  <span class="s">&quot;A sample value.&quot;</span>
  <span class="mi">5</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">b</span>
  <span class="s">&quot;Some function&quot;</span>
  <span class="p">[</span><span class="nv">c</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">c</span><span class="p">))</span>

<span class="p">(</span><span class="nb">doc </span><span class="nv">a</span><span class="p">)</span>
<span class="c1">; -------</span>
<span class="c1">; user/a</span>
<span class="c1">;   A sample value.</span>
</code></pre></figure><h4 id="constants">
<span class="hash">#</span>
<a href="#constants" class="header-link">Constants</a>
</h4>
<p>Constant values can be declared with the <code>:const</code> metadata keyword. Constants aren&rsquo;t resolved at runtime, instead the value held by the var is retained permanently at compile time <sup id="fnref11"><a href="#fn11" rel="footnote">11</a></sup>. Later redefinitions of the var have no effect.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:const</span> <span class="nv">max-value</span> <span class="mi">255</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">valid-value?</span>
  <span class="p">[</span><span class="nv">v</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">&lt;= </span><span class="nv">v</span> <span class="nv">max-value</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">max-value</span> <span class="mi">500</span><span class="p">)</span>
<span class="p">(</span><span class="nf">valid-value?</span> <span class="mi">299</span><span class="p">)</span>
<span class="c1">;= false</span>
</code></pre></figure><h4 id="dynamic-scope">
<span class="hash">#</span>
<a href="#dynamic-scope" class="header-link">Dynamic Scope</a>
</h4>
<p>Although for the most part Clojure is lexically scoped, vars have a feature known as dynamic scope. Vars have a root binding, which is the value bound to the var when it&rsquo;s defined with <code>def</code> or some derivative.</p>

<p>However, if the var is defined to be dynamic, with the <code>:dynamic</code> metadata keyword, then the root binding can be overridden and shadowed on a per-thread basis with the <code>binding</code> form. The naming convention for dynamic vars is to surround the names with asterisks <code>*</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:dynamic</span> <span class="nv">*max-value*</span> <span class="mi">255</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">valid-value?</span>
  <span class="p">[</span><span class="nv">v</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">&lt;= </span><span class="nv">v</span> <span class="nv">*max-value*</span><span class="p">))</span>

<span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*max-value*</span> <span class="mi">500</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">valid-value?</span> <span class="mi">299</span><span class="p">))</span>
<span class="c1">;= true</span>
</code></pre></figure>
<p>Dynamic bindings can stack by nesting <code>binding</code> calls, each inner scope shadowing the outer one. As a result, <code>get-*var*</code> will evaluate to <code>:c</code> and not the outer scope bindings.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:dynamic</span> <span class="nv">*var*</span> <span class="ss">:root</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">get-*var*</span> <span class="p">[]</span> <span class="nv">*var*</span><span class="p">)</span>

<span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*var*</span> <span class="ss">:a</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*var*</span> <span class="ss">:b</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*var*</span> <span class="ss">:c</span><span class="p">]</span>
      <span class="p">(</span><span class="nf">get-*var*</span><span class="p">))))</span>
<span class="c1">;= c</span>
</code></pre></figure>
<p>Dynamic scope is idiomatically used to specify optional return values. This is possible using the <code>thread-bound?</code> function to check if the current thread has established a thread-local binding on the var. The <code>set!</code> function can then be used to change the value of the current thread-local binding.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:dynamic</span> <span class="nv">*ret-val*</span> <span class="nv">nil</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">some-func</span>
  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nf">thread-bound?</span> <span class="o">#</span><span class="ss">&#39;*ret-val*</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">set!</span> <span class="nv">*ret-val*</span> <span class="mi">42</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">some-func</span><span class="p">)</span>
<span class="nv">*ret-val*</span>
<span class="c1">;= nil</span>

<span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*ret-val*</span> <span class="nv">nil</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">some-func</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">println </span><span class="s">&quot;ret-val: &quot;</span> <span class="nv">*ret-val*</span><span class="p">))</span>
<span class="c1">;= ret-val: 42</span>
</code></pre></figure>
<p>Binding conveyance is the propagation of dynamic var bindings across threads, and it&rsquo;s possible with agents, futures, and <code>pmap</code> and its derivatives. In the following code, <code>future</code> propagates the dynamic scope across to the other thread for the duration of its operation.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*max-value*</span> <span class="mi">500</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">valid-value?</span> <span class="mi">299</span><span class="p">))</span>
  <span class="o">@</span><span class="p">(</span><span class="nf">future</span> <span class="p">(</span><span class="nf">valid-value?</span> <span class="mi">299</span><span class="p">)))</span>
<span class="c1">; true</span>
<span class="c1">;= true</span>
</code></pre></figure>
<p>However, lazy sequences in general do not support binding conveyance. To mitigate this, it&rsquo;s necessary to push the dynamic scope required for each step in the lazy sequence into the code that&rsquo;s values are realized.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*max-value*</span> <span class="mi">500</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">map </span><span class="nv">valid-value?</span> <span class="p">[</span><span class="mi">299</span><span class="p">]))</span>
<span class="c1">;= (false)</span>

<span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*max-value*</span> <span class="mi">500</span><span class="p">]</span>
        <span class="p">(</span><span class="nf">valid-value?</span> <span class="nv">%</span><span class="p">))</span>
     <span class="p">[</span><span class="mi">299</span><span class="p">])</span>
<span class="c1">;= (true)</span>
</code></pre></figure>
<p>Although generally discouraged, the root binding of vars can be mutated as a function of its current value using the <code>alter-var-root</code> function. Other functions like <code>with-redefs</code> can change the root binding within their scope, which can be useful for testing, such as mocking out functions or values.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">alter-var-root</span> <span class="o">#</span><span class="ss">&#39;x</span> <span class="nv">inc</span><span class="p">)</span>
<span class="c1">;= 1</span>
</code></pre></figure>
<p>Forward declarations are possible by not providing a value when defining a var. Although the <code>def</code> form can be used for this purpose, the <code>declare</code> macro is more idiomatic since it makes the intention more explicit, and allows a variable number of unbound vars to be declared.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">declare </span><span class="nv">a-fn</span> <span class="nv">b-fn</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">public-api-function</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nf">b-fn</span> <span class="p">(</span><span class="nf">a-fn</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn- </span><span class="nv">a-fn</span> <span class="p">[]</span>
  <span class="nv">...</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn- </span><span class="nv">b-fn</span> <span class="p">[]</span>
  <span class="nv">...</span><span class="p">)</span>
</code></pre></figure><h3 id="agents">
<span class="hash">#</span>
<a href="#agents" class="header-link">Agents</a>
</h3>
<p>Changes to an agent&rsquo;s state are independent of changes to other agents' states, and all changes are made away from the thread of execution that scheduled them. I/O and other side-effecting functions may be safely used with agents. Agents are <abbr title="Software Transactional Memory">STM</abbr>-aware, such that they can safely be used in the context of retrying transactions.</p>

<p>The modification operations for agents are <code>send</code> and <code>send-off</code>. The function and optional arguments passed to these functions are called an agent action.  Each agent maintains a queue of actions. Invoking a modification function returns immediately after queueing the specified action, and each action is evaluated serially, in order, on one of many threads dedicated to the evaluation of agent actions.</p>

<p>The <code>send</code> function sends actions to be evaluated within a fixed-size thread pool, and due to being fixed in size, it&rsquo;s important to not give it actions that may perform I/O or other blocking operations, as it would prevent other non-blocking, CPU-bound actions from fully utilizing the resource.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="nb">agent </span><span class="mi">500</span><span class="p">))</span>
<span class="p">(</span><span class="nb">send </span><span class="nv">a</span> <span class="nb">range </span><span class="mi">1000</span><span class="p">)</span>
<span class="o">@</span><span class="nv">a</span>
<span class="c1">;= (500 501 ... 999)</span>
</code></pre></figure>
<p>On the other hand, actions queued with <code>send-off</code> are evaluated in an unbounded thread pool (same one used by futures), allowing any number of potentially blocking actions to be evaluated concurrently.</p>

<p>It&rsquo;s possible to block on the completion of all actions from a given set of actors sent from the current thread using <code>await</code>. It&rsquo;s important to realize that by the time an agent is dereferenced, it could&rsquo;ve been modified by another action. The <code>await-for</code> function allows one to specify a timeout.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="nb">agent </span><span class="mi">5000</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="p">(</span><span class="nb">agent </span><span class="mi">10000</span><span class="p">))</span>

<span class="p">(</span><span class="nb">send-off </span><span class="nv">a</span> <span class="o">#</span><span class="p">(</span><span class="nf">Thread/sleep</span> <span class="nv">%</span><span class="p">))</span>
<span class="p">(</span><span class="nb">send-off </span><span class="nv">b</span> <span class="o">#</span><span class="p">(</span><span class="nf">Thread/sleep</span> <span class="nv">%</span><span class="p">))</span>

<span class="o">@</span><span class="nv">a</span>
<span class="c1">;= 5000</span>

<span class="p">(</span><span class="nb">await </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
<span class="c1">;= nil</span>

<span class="c1">; a has been set to nil because</span>
<span class="c1">; it&#39;s the return value of Thread/sleep</span>
<span class="o">@</span><span class="nv">a</span>
<span class="c1">;= nil</span>
</code></pre></figure>
<p>Because actions are evaluated in a separate thread, exceptions thrown by them can&rsquo;t be dealt with by the same thread that dispatched the action. As a result, an error causes the agent to fail silently.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="nb">agent </span><span class="nv">nil</span><span class="p">))</span>
<span class="p">(</span><span class="nb">send </span><span class="nv">a</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="p">(</span><span class="nf">throw</span> <span class="p">(</span><span class="nf">Exception.</span> <span class="s">&quot;something is wrong&quot;</span><span class="p">))))</span>
<span class="c1">;= #&lt;Agent: nil&gt;</span>

<span class="nv">a</span>
<span class="c1">;= #&lt;Agent FAILED: nil&gt;</span>

<span class="o">@</span><span class="nv">a</span>
<span class="c1">;= nil</span>

<span class="p">(</span><span class="nb">send </span><span class="nv">a</span> <span class="nv">identity</span><span class="p">)</span>
<span class="c1">;= #&lt;Exception ... something is wrong&gt;</span>
</code></pre></figure>
<p>The agent can be salvaged by using <code>restart-agent</code> to reset the agent&rsquo;s state to the provided value, enabling it to receive actions again.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">restart-agent</span> <span class="nv">a</span> <span class="mi">42</span><span class="p">)</span>
<span class="c1">;= 42</span>

<span class="p">(</span><span class="nb">send </span><span class="nv">a</span> <span class="nv">inc</span><span class="p">)</span>
<span class="c1">;= #&lt;Agent: 43&gt;</span>

<span class="c1">; queue three actions which throw exceptions</span>
<span class="p">(</span><span class="nb">reduce send </span><span class="nv">a</span>
             <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">)]</span>
               <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="p">(</span><span class="nf">throw</span> <span class="p">(</span><span class="nf">Exception.</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;error #&quot;</span> <span class="nv">x</span><span class="p">))))))</span>

<span class="p">(</span><span class="nf">agent-error</span> <span class="nv">a</span><span class="p">)</span>
<span class="c1">;= #&lt;Exception ... error #0&gt;</span>
</code></pre></figure>
<p>The <code>restart-agent</code> function also accepts <code>:clear-actions</code> which would cause it to clear up any pending actions, otherwise they immediately begin evaluating once again.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">restart-agent</span> <span class="nv">a</span> <span class="mi">42</span><span class="p">)</span>
<span class="c1">;= 42</span>

<span class="c1">; didn&#39;t pass :clear-actions</span>
<span class="c1">; so next action is valuated</span>
<span class="p">(</span><span class="nf">agent-error</span> <span class="nv">a</span><span class="p">)</span>
<span class="c1">;= #&lt;Exception ... error #1&gt;</span>

<span class="p">(</span><span class="nf">restart-agent</span> <span class="nv">a</span> <span class="mi">42</span> <span class="ss">:clear-actions</span> <span class="nv">true</span><span class="p">)</span>
<span class="c1">;= 42</span>

<span class="p">(</span><span class="nf">agent-error</span> <span class="nv">a</span><span class="p">)</span>
<span class="c1">;= nil</span>
</code></pre></figure>
<p>The default behavior for agents is for them to require intervention when an action fails. An alternative is to have the agent ignore a failed action and continue with the evaluation of the next action in the queue. This can be specified at creation time with the <code>agent</code> function and the <code>:error-mode</code> option with a value of <code>:continue</code>, where the default is <code>:fail</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="nb">agent </span><span class="nv">nil</span> <span class="ss">:error-mode</span> <span class="ss">:continue</span><span class="p">))</span>
<span class="p">(</span><span class="nb">send </span><span class="nv">a</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="p">(</span><span class="nf">throw</span> <span class="p">(</span><span class="nf">Exception.</span> <span class="s">&quot;something is wrong&quot;</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">send </span><span class="nv">a</span> <span class="nv">identity</span><span class="p">)</span>
<span class="c1">;= #&lt;Agent: nil&gt;</span>
</code></pre></figure>
<p>It&rsquo;s also possible to specify an error handler which takes as argument the agent in question and the error using the <code>:error-handler</code> option with the <code>agent</code> steam.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="nb">agent </span><span class="nv">nil</span>
              <span class="ss">:error-mode</span> <span class="ss">:continue</span>
              <span class="ss">:error-handler</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">the-agent</span> <span class="nv">exception</span><span class="p">]</span>
                               <span class="p">(</span><span class="nf">.println</span> <span class="nv">System/out</span> <span class="p">(</span><span class="nf">.getMessage</span> <span class="nv">exception</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">send </span><span class="nv">a</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="p">(</span><span class="nf">throw</span> <span class="p">(</span><span class="nf">Exception.</span> <span class="s">&quot;something is wrong&quot;</span><span class="p">))))</span>
<span class="c1">;= #&lt;Agent: nil&gt;</span>
<span class="c1">; something is wrong</span>

<span class="p">(</span><span class="nb">send </span><span class="nv">a</span> <span class="nv">identity</span><span class="p">)</span>
<span class="c1">;= #&lt;Agent: nil&gt;</span>
</code></pre></figure>
<p>The error mode and handler can be changed dynamically with the <code>set-error-mode!</code> and <code>set-error-handler!</code> functions.</p>

<p>Agent actions queued within <a href="#software-transactional-memory">Software Transactional Memory</a> transactions aren&rsquo;t actually added to the queue until the transaction is actually committed. This allows agents to be used within transactions regardless of the number of times the transaction is retried. The same thing applies to actions queued within the scope of other agent actions.</p>

<p>If a validator or something else causes the transaction to fail, then the held off queued actions will be discarded.</p>

<p>The <code>*agent*</code> var is one that&rsquo;s usually unbound except for within the scope of an evaluating action, where it&rsquo;s bound to the current agent, the owner of that action.</p>
<h2 id="software-transactional-memory">
<span class="hash">#</span>
<a href="#software-transactional-memory" class="header-link">Software Transactional Memory</a>
</h2>
<p>Software Transactional Memory (<abbr title="Software Transactional Memory">STM</abbr>) transactions ensure that changes to refs are made atomically, consistently (transaction fails if changes don&rsquo;t satisfy ref constraints), and in isolation (transaction changes don&rsquo;t affect states from within transactions in other threads).</p>

<p>The <code>dosync</code> function establishes the scope of a transaction. Nested transaction scopes are joined into a single logical transaction. All modifications of refs must occur within a transaction. Transactions are synchronous, blocking the current thread until the transaction is complete.</p>

<p>The <code>alter</code> function can be used to modify the value of a ref, much like <code>swap!</code>. When <code>alter</code> returns, the in-transaction value of the ref is changed to what it was set to, allowing further modifications within the same transaction to work off of the previous modifications.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">names</span> <span class="p">(</span><span class="nb">ref </span><span class="p">[]))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">add-name</span>
  <span class="p">[</span><span class="nv">name</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">dosync</span>
    <span class="p">(</span><span class="nb">alter </span><span class="nv">names</span> <span class="nb">conj </span><span class="nv">name</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">add-name</span> <span class="s">&quot;zack&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">add-name</span> <span class="s">&quot;shelley&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">println </span><span class="o">@</span><span class="nv">names</span><span class="p">)</span>
<span class="c1">;= [&quot;zack&quot; &quot;shelley]</span>
</code></pre></figure>
<p>When the transaction is about to be committed (i.e. completed), the value of the ref outside of the transaction <em>must</em> be the same as it was prior to the first in-transaction use of <code>alter</code> on that ref. If this is not the case, then the transaction is restarted from the beginning with the new value of the involved refs.</p>

<p>There are instances in which the order in which a function is applied to a ref is not important, however. In these situations, the behavior in which transactions are retried would waste a lot of time and unnecessary work trying to keep the values up to date. The <code>commute</code> function can be used for when the order of application doesn&rsquo;t matter.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="c1">; in transaction, (commute ref ...) sets ref to</span>
<span class="p">(</span><span class="nb">apply </span><span class="nv">fun</span> <span class="nv">in-transaction-value-of-ref</span> <span class="nv">args</span><span class="p">)</span>

<span class="c1">; when committed sets ref to</span>
<span class="p">(</span><span class="nb">apply </span><span class="nv">fun</span> <span class="nv">most-recently-committed-value-of-ref</span> <span class="nv">args</span><span class="p">)</span>
</code></pre></figure>
<p>A good example of this is incrementing a counter. Using <code>alter</code> in this situation would lead to many retried transactions, even though what ultimately matters is the end result: the final count.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">counter</span> <span class="p">(</span><span class="nb">ref </span><span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">alter-inc!</span> <span class="p">[</span><span class="nv">counter</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">dosync </span><span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="nb">alter </span><span class="nv">counter</span> <span class="nv">inc</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">commute-inc!</span> <span class="p">[</span><span class="nv">counter</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">dosync </span><span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="nb">commute </span><span class="nv">counter</span> <span class="nv">inc</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">bombard-counter!</span> <span class="p">[</span><span class="nv">n</span> <span class="nv">f</span> <span class="nv">counter</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply </span><span class="nv">pcalls</span> <span class="p">(</span><span class="nb">repeat </span><span class="nv">n</span> <span class="o">#</span><span class="p">(</span><span class="nf">f</span> <span class="nv">counter</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">dosync ref-set </span><span class="nv">counter</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">bombard-counter!</span> <span class="mi">20</span> <span class="nv">alter-inc!</span> <span class="nv">counter</span><span class="p">)))</span>
<span class="s">&quot;Elapsed time: 2007.049224 msecs&quot;</span>
<span class="p">(</span><span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">7</span> <span class="mi">10</span> <span class="mi">5</span> <span class="mi">8</span> <span class="mi">6</span> <span class="mi">9</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">12</span> <span class="mi">11</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">20</span> <span class="mi">18</span> <span class="mi">19</span><span class="p">)</span>

<span class="p">(</span><span class="nb">dosync ref-set </span><span class="nv">counter</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">bombard-counter!</span> <span class="mi">20</span> <span class="nv">commute-inc!</span> <span class="nv">counter</span><span class="p">)))</span>
<span class="s">&quot;Elapsed time: 401.748181 msecs&quot;</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">11</span> <span class="mi">15</span> <span class="mi">13</span> <span class="mi">12</span> <span class="mi">14</span> <span class="mi">16</span> <span class="mi">19</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">20</span><span class="p">)</span>
</code></pre></figure>
<p>It&rsquo;s important to realize that the in-transaction value of the ref will be the one altered by the function application passed to <code>commute</code>, but the actual value of the ref once the transaction is committed will be based off of the latest value of that ref. For this reason, care needs to be taken to ensure that the transaction doesn&rsquo;t rely on the value of the ref.</p>

<p>The <code>ref-state</code> function can set the in-transaction value of the ref to the provided value, usually used to set ref states to initial values. Like <code>alter</code>, it will cause a retry of the transaction if the ref&rsquo;s state changes prior to commit-time. It&rsquo;s essentially <code>alter</code> with a function that returns a constant value.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="c1">; equivalent</span>
<span class="p">(</span><span class="nb">dosync </span><span class="p">(</span><span class="nb">ref-set </span><span class="nv">bilbo</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Bilbo&quot;</span><span class="p">}))</span>
<span class="p">(</span><span class="nb">dosync </span><span class="p">(</span><span class="nb">alter </span><span class="nv">bilbo</span> <span class="p">(</span><span class="nb">constantly </span><span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Bilbo&quot;</span><span class="p">})))</span>
</code></pre></figure>
<p>Validators can be used in transactions, since they throw exceptions when the validation fails, and any exception thrown within a transaction causes that transaction to fail.</p>

<p>The <code>io!</code> function makes explicit side-effecting code. If it&rsquo;s evaluated within a transaction, it throws an exception, aborting the transaction. This is useful because the retry-behavior of transactions makes it possible that side-effecting code is run multiple times, which is often not the intention. Operations on atoms should also be considered side-effecting, as they don&rsquo;t participate in <abbr title="Software Transactional Memory">STM</abbr> semantics.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">unsafe</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nf">io!</span> <span class="p">(</span><span class="nb">println </span><span class="s">&quot;writing to database&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">dosync </span><span class="p">(</span><span class="nf">unsafe</span><span class="p">))</span>
<span class="c1">;= #&lt;IllegalStateException I/O in transaction&gt;</span>
</code></pre></figure>
<p>It&rsquo;s also very important to ensure that values held in refs are immutable, or unintended effects may occur.</p>
<h3 id="live-locks">
<span class="hash">#</span>
<a href="#live-locks" class="header-link">Live Locks</a>
</h3>
<p>A live lock is the equivalent of a deadlock in <abbr title="Software Transactional Memory">STM</abbr>, which occurs when a transaction never gets the chance to commit due to ref contention. One fallback that Clojure uses is called <em>barging</em>, where an older transaction is allowed to proceed in certain circumstances, forcing newer transactions to retry. If barging fails to push through the older transaction within a certain time frame, Clojure&rsquo;s <abbr title="Software Transactional Memory">STM</abbr> will cause the transaction to fail, yielding a stack trace via a thrown exception. There is also a limit to the amount of times a transaction can be retried, which if exceeded, causes the transaction to fail.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nb">ref </span><span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nf">dosync</span>
  <span class="o">@</span><span class="p">(</span><span class="nf">future</span> <span class="p">(</span><span class="nb">dosync </span><span class="p">(</span><span class="nb">ref-set </span><span class="nv">x</span> <span class="mi">0</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">ref-set </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">;= &lt;RuntimeException ... Transaction Failed after reaching retry limit&gt;</span>

<span class="o">@</span><span class="nv">x</span>
<span class="c1">;= 0</span>
</code></pre></figure><h3 id="reader-retry">
<span class="hash">#</span>
<a href="#reader-retry" class="header-link">Reader Retry</a>
</h3>
<p>In general, dereferencing ref types is guaranteed to never block, but inside of a transaction, dereferencing ref types may trigger a transaction retry. This may seem confusing, since a single read would always be a consistent snapshot of a ref.</p>

<p>However, consider the scenario where two refs are being dereferenced for the purpose of adding them and returning their sum <sup id="fnref12"><a href="#fn12" rel="footnote">12</a></sup>. If during the course of this transaction, one of the ref&rsquo;s state is modified, the computation would be <em>inconsistent</em> because the two refs are from different points in time. This is why it&rsquo;s logical to retry the entire transaction.</p>

<p>This situation can be mitigated by maintaining a history of the ref states. If this were done, then the transaction could simply look for the state of the ref from the point in time that the transaction began.</p>

<p>With this scheme, each ref has a minimum and maximum history size, which can be specified as <code>:min-history</code> and <code>:max-history</code> key-value pairs to <code>ref</code>. With the default minimum of 0, a transaction retry would increase the history size by one so that two states would be tracked throughout the duration of the transaction, and again increment it on the next retry, and so on.</p>

<p>In the worst case, if the max history size isn&rsquo;t large enough to track the target state of the ref throughout the duration of the transaction, then the transaction will continually retry until it can complete or until it reaches the retry limit, in which case it fails.</p>

<p>Consider the following code where transactions continuously increment a ref every 20 milliseconds for a total of 500 times within a future, followed by a transaction on the same thread that tries to read the ref after one second.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">stm-experiment</span>
  <span class="p">[</span><span class="nv">min-hist</span> <span class="nv">max-hist</span><span class="p">]</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nb">ref </span><span class="mi">0</span> <span class="ss">:min-history</span> <span class="nv">min-hist</span> <span class="ss">:max-history</span> <span class="nv">max-hist</span><span class="p">)]</span>
      <span class="p">(</span><span class="nf">future</span> <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">_</span> <span class="mi">500</span><span class="p">]</span> <span class="p">(</span><span class="nb">dosync </span><span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">20</span><span class="p">)</span> <span class="p">(</span><span class="nb">alter </span><span class="nv">a</span> <span class="nv">inc</span><span class="p">))))</span>
      <span class="p">(</span><span class="nb">dosync </span><span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">@</span><span class="nv">a</span><span class="p">)))</span>
</code></pre></figure>
<p>In the default case, the minimum history size is 0 and the maximum size is 10. This maximum history size is never enough to fully track the value that <code>a</code> was at at the time the transaction was started, since by the time that it wants to read <code>a</code>, it would have changed 50 times. As a result, it has to keep retrying, effectively waiting until the writer transactions finish, by which time it&rsquo;ll then re-read the value of <code>a</code> as 500, which is the end result.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">stm-experiment</span> <span class="mi">0</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1">;= 500</span>
</code></pre></figure>
<p>If the minimum history size is set to 50 from the beginning, then Clojure won&rsquo;t have to wait to incrementally grow the history by one on each retry. As a result, the transaction will be able to keep track of the state of the ref as it was at the beginning of the transaction, which was 0. That state will be at the very end of the history list.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">stm-experiment</span> <span class="mi">50</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1">;= 0</span>
</code></pre></figure>
<p>If we set the maximum size just under the required size to 48, then it&rsquo;ll retry twice at which time the size (50) will be sufficient to keep track of the state. By this time, twice 50 increments will have occurred, so the value at the beginning of the third transaction run will be around 100.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">stm-experiment</span> <span class="mi">48</span> <span class="mi">100</span><span class="p">)</span>
<span class="c1">;= ~100</span>
</code></pre></figure>
<p>If we cap the maximum size under what is required, then it is as in the first case, where the history list will not be able to grow to the required capacity, and as a result the transaction will continue to retry until it can successfully complete, which should be once all writer transactions are complete.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">stm-experiment</span> <span class="mi">48</span> <span class="mi">48</span><span class="p">)</span>
<span class="c1">;= 500</span>
</code></pre></figure><h3 id="write-skew">
<span class="hash">#</span>
<a href="#write-skew" class="header-link">Write Skew</a>
</h3>
<p>Write skew refers to the situation in which a transaction doesn&rsquo;t modify a ref, but the consistency of the transaction&rsquo;s changes depend on the state of the ref that was read, and this state changes mid-transaction, causing the transaction&rsquo;s effects on other refs to end up being inconsistent with the read ref.</p>

<p>The <code>ensure</code> function can be used to mitigate this, as it dereferences a ref such that the read will conflict with any modifications prompted by other transactions until the transaction is complete, causing them to retry as necessary.</p>

<p>The <code>ensure</code> function is equivalent to dummy writes, which end up requiring that the read value persists until the transaction is committed, with the advantage that <code>ensure</code> generally minimizes the number of transaction retries involving read-only refs.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="c1">; all semantically equivalent</span>
<span class="p">(</span><span class="nb">ensure </span><span class="nv">a</span><span class="p">)</span>
<span class="p">(</span><span class="nb">alter </span><span class="nv">a</span> <span class="nv">identity</span><span class="p">)</span>
<span class="p">(</span><span class="nb">ref-set </span><span class="nv">a</span> <span class="o">@</span><span class="nv">a</span><span class="p">)</span>
</code></pre></figure><h2 id="channels">
<span class="hash">#</span>
<a href="#channels" class="header-link">Channels</a>
</h2>
<p>The <a href="https://clojure.github.io/core.async/"><span class="path">core.async</span></a> library provides an implementation of channels similar to Go&rsquo;s. <code>go</code> is a macro that examines its body for any channel operations and turns it into a state machine, immediately returning a channel on which it eventually places the value of its body&rsquo;s last expression, if non-nil, and closes it. Upon a blocking operation, the state machine is parked and the actual thread of control is released. The body is resumed on a thread-pool thread (or the sole JavaScript <abbr title="Virtual Machine">VM</abbr> thread) when the blocking operation completes,</p>

<p>The primary channel operations within go blocks are <code>&gt;!</code> for putting and <code>&lt;!</code> for taking. There are also analogous operations for ordinary threads which block the thread on which they&rsquo;re called until complete <code>-&gt;!!</code> for putting and <code>&lt;!!</code> for taking. These can be used on threads created with, for example, <code>future</code>, but there&rsquo;s also a macro called <code>thread</code> that&rsquo;s similar to <code>go</code> which launches a first-class thread and returns a channel, and should be preferred over <code>future</code> for channel work.</p>

<p>The <code>alts!</code> function can be used in <code>go</code> blocks to wait for any one of a set of operations to complete, much like <code>select</code>. Timeouts are channels that close after a period of time, and can be created with the <code>timeout</code> function and included in the set given to an <code>alt</code> variant to place an upper bound on the amount of time spent waiting for an operation to complete.</p>

<p>Given the persistent, immutable nature of data structures in Clojure, it&rsquo;s safe and efficient to place them in channels.</p>

<p>Broadcast channels can be created by creating a <em>mult</em> channel from the source channel with the <code>mult</code> function. Other channels can <em>tap into</em> the mult channel with the <code>tap</code> function, which copies the mult channel into an existing channel (i.e. mutates the channel). Data is sent through the source channel as usual. To stop listening into the mult channel, the <code>untap</code> channel is used with the mult channel and the end channel as arguments.</p>
<h1 id="macros">
<span class="hash">#</span>
<a href="#macros" class="header-link">Macros</a>
</h1>
<p>Code in Clojure is represented as data structures, as was described in <a href="#homoiconicity">homoiconicity</a>. These structures are then evaluated depending on the data type&rsquo;s rules, such as most literals evaluating to themselves (integers, strings, keywords, etc.), symbols evaluating to the value in the var in some namespace, and lists to calls of functions, special forms, or macros.</p>

<p>Whereas function calls are provided their arguments already evaluated, macros are called by the compiler <em>at compile-time</em> with their arguments <em>unevaluated</em> and must return some Clojure data structure that itself <em>can</em> be evaluated. This data structure itself could contain other macro calls, which are recursively expanded until there are no macro calls. This is known as <em>macroexpansion</em>.</p>

<p>Macros are expanded at compile time so the compiler can catch compile-time errors.</p>
<h2 id="debugging-macros">
<span class="hash">#</span>
<a href="#debugging-macros" class="header-link">Debugging Macros</a>
</h2>
<p>It&rsquo;s easy to refer to vars within macros that aren&rsquo;t yet defined, and this would produce an error when the macro is actually used. This is because macros are expanded at compile time, at which time Clojure can&rsquo;t know if the symbol will refer to a var that has a defined value at runtime.</p>
<h2 id="macroexpansion">
<span class="hash">#</span>
<a href="#macroexpansion" class="header-link">Macroexpansion</a>
</h2>
<p>The <code>macroexpand-1</code> function can be used to debug macros as it allows one to see what code the compiler would expand the macro to. The 1 at the end of the function name refers to the fact that it only expands the <em>top-level</em> macro once.</p>

<p>Using the <code>macroexpand-1</code> function can expand to yet another top-level macro, for this the <code>macroexpand</code> function exists, since it expands the top-level macro until it&rsquo;s no longer a macro.</p>

<p>Neither of the above functions expand nested macros. For this, the <code>clojure.walk/macroexpand-all</code> function can be used.</p>
<h2 id="syntax">
<span class="hash">#</span>
<a href="#syntax" class="header-link">Syntax</a>
</h2>
<p>It&rsquo;s common to want to return lists to represent further calls to functions, special forms, or macros. The <code>list</code> function can be used with each symbol quoted to avoid its evaluation, but that&rsquo;s too cumbersome.</p>

<p>The first useful syntax is the backquote <code>`</code>, also known as syntax-quote. The backquote is similar to the regular <code>quote</code> function or syntax <code>&#39;</code>, except that it fully qualifies unqualified symbols with the current namespace. The syntax-quote also handles qualification of the corresponding namespace in the event of namespace-aliasing. This qualification behavior is critical to ensure that the macro doesn&rsquo;t expand to code that inadvertently refers to or redefines already-named values, a safety practice known as macro hygiene.</p>

<p>Another advantage of syntax-quoting is that specific elements of the list can be unquoted, causing them to be evaluated within the scope of the syntax-quoted form. This can be done with the tilde <code>~</code> symbol prefix.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="c1">; both are equivalent</span>
<span class="p">(</span><span class="nb">list </span><span class="o">`</span><span class="nb">map </span><span class="o">`</span><span class="nb">println </span><span class="p">[</span><span class="nv">foo</span><span class="p">])</span>
<span class="o">`</span><span class="p">(</span><span class="nb">map println </span><span class="o">~</span><span class="p">[</span><span class="nv">foo</span><span class="p">])</span>
</code></pre></figure>
<p>The unquote-splicing operator <code>~@</code> can be used to unpack the contents of one list into another.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="c1">; equivalent</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">defs</span> <span class="o">&#39;</span><span class="p">((</span><span class="k">def </span><span class="nv">x</span> <span class="mi">123</span><span class="p">)</span>
             <span class="p">(</span><span class="k">def </span><span class="nv">y</span> <span class="mi">456</span><span class="p">))]</span>
  <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nb">list </span><span class="ss">&#39;do</span><span class="p">)</span> <span class="nv">defs</span><span class="p">))</span>
<span class="c1">;= (do (def x 123) (def y 456))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">defs</span> <span class="o">&#39;</span><span class="p">((</span><span class="k">def </span><span class="nv">x</span> <span class="mi">123</span><span class="p">)</span>
             <span class="p">(</span><span class="k">def </span><span class="nv">y</span> <span class="mi">456</span><span class="p">))]</span>
  <span class="o">`</span><span class="p">(</span><span class="k">do </span><span class="o">~@</span><span class="nv">defs</span><span class="p">))</span>
<span class="c1">;= (do (def x 123) (def y 456))</span>
</code></pre></figure>
<p>Using the unquote-splicing operator is idiomatic for macros that accept code bodies, such as the following.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defmacro </span><span class="nv">foo</span>
  <span class="p">[</span><span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="nf">do-something</span> <span class="o">~@</span><span class="nv">body</span><span class="p">))</span>
</code></pre></figure>
<p>The <code>gensym</code> function returns a symbol that is guaranteed to be unique, and thus won&rsquo;t collide with the environment surrounding the macro. It can take a string to prefix the symbol name with. Since creating gensym macros is very common, there is shorthand syntax for them with the pound sign <code>#</code> suffix, which will automatically expand into a gensym, each time into the same one <em>as long as</em> it&rsquo;s within the same syntax-quoted form. This is known as an auto-gensym.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">gensym</span><span class="p">)</span>
<span class="c1">;= G__2386</span>

<span class="p">(</span><span class="nb">gensym </span><span class="s">&quot;sym&quot;</span><span class="p">)</span>
<span class="c1">;= sym2391</span>

<span class="p">(</span><span class="kd">defmacro </span><span class="nv">hygienic</span> <span class="p">[</span><span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">sym</span> <span class="p">(</span><span class="nf">gensym</span><span class="p">)]</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="o">~</span><span class="nv">sym</span> <span class="ss">:macro-value</span><span class="p">]</span>
      <span class="o">~@</span><span class="nv">body</span><span class="p">)))</span>

<span class="c1">; or</span>
<span class="p">(</span><span class="kd">defmacro </span><span class="nv">hygienic</span> <span class="p">[</span><span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x#</span> <span class="ss">:macro-value</span><span class="p">]</span>
    <span class="o">~@</span><span class="nv">body</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">1</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">hygienic</span> <span class="p">(</span><span class="nb">println </span><span class="s">&quot;x:&quot;</span> <span class="nv">x</span><span class="p">)))</span>
<span class="c1">; x: 1</span>
</code></pre></figure>
<p>It&rsquo;s important to emphasize that the auto-gensym only evaluates to the same symbol as long as it&rsquo;s within the same syntax-quoted form. If auto-gensyms need to span across syntax-quoted forms, then an explicit gensym is required.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="o">`</span><span class="p">(</span><span class="nf">x#</span> <span class="nv">x#</span><span class="p">)</span>
<span class="c1">;= (x__asdf x__asdf)</span>

<span class="p">[</span><span class="o">`</span><span class="nv">x#</span> <span class="o">`</span><span class="nv">x#</span><span class="p">]</span>
<span class="c1">;= [x__asdf x__wxyz]</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nf">gensym</span><span class="p">)]</span>
  <span class="p">[</span><span class="nv">x</span> <span class="nv">x</span><span class="p">])</span>
<span class="c1">;= [G__asdf G__asdf]</span>
</code></pre></figure>
<p>A macro that deliberately exposes a name to the caller of the macro is <em>anaphoric</em>. Anaphoric macros are generally discouraged as it requires the user of the macro to remember the exposed names within their scope. Instead, it&rsquo;s idiomatic to let users choose the names to use.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defmacro </span><span class="nv">with</span>
  <span class="p">[</span><span class="nb">name </span><span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="o">~</span><span class="nb">name </span><span class="mi">5</span><span class="p">]</span>
    <span class="o">~@</span><span class="nv">body</span><span class="p">))</span>

<span class="p">(</span><span class="nf">with</span> <span class="nv">bar</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">10</span> <span class="nv">bar</span><span class="p">))</span>
<span class="c1">;= 15</span>
</code></pre></figure>
<p>Double expansion is a common problem where a macro argument appears more than once in the expansion, causing multiple evaluations which can lead to unexpected results if they contain side-effects or decreased performance if the evaluation is computationally expensive.</p>

<p>The idiomatic solution to this problem is to introduce a local binding to which the evaluation of the expression is centralized and by which it is referred to as henceforth.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defmacro </span><span class="nv">spy</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="nf">do</span>
    <span class="p">(</span><span class="nb">println </span><span class="s">&quot;spied&quot;</span> <span class="o">&#39;~</span><span class="nv">x</span> <span class="o">~</span><span class="nv">x</span><span class="p">)</span>
    <span class="o">~</span><span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nf">spy</span> <span class="p">(</span><span class="nb">rand-int </span><span class="mi">10</span><span class="p">))</span>
<span class="c1">; spied (rand-int 10) 9</span>
<span class="c1">;= 7</span>

<span class="p">(</span><span class="kd">defmacro </span><span class="nv">spy</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x#</span> <span class="o">~</span><span class="nv">x</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">println </span><span class="s">&quot;spied&quot;</span> <span class="o">&#39;~</span><span class="nv">x</span> <span class="nv">x#</span><span class="p">)</span>
    <span class="nv">x#</span><span class="p">))</span>

<span class="p">(</span><span class="nf">spy</span> <span class="p">(</span><span class="nb">rand-int </span><span class="mi">10</span><span class="p">))</span>
<span class="c1">; spied (rand-int 10) 9</span>
<span class="c1">;= 9</span>
</code></pre></figure>
<p>The <code>defmacro</code> macro introduces the two implicit local bindings <code>&amp;env</code> and <code>&amp;form</code>. The <code>&amp;env</code> binding contains a map where the keys are the names of all of the current locals, though the values are unspecified. Since the keys don&rsquo;t have a namespace, their values can&rsquo;t be accessed outside of the macro. However, within the macro, the keys and their values can be accessed using typical expansion syntax.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defmacro </span><span class="nv">spy-env</span> <span class="p">[]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ks</span> <span class="p">(</span><span class="nb">keys </span><span class="o">&amp;</span><span class="nv">env</span><span class="p">)]</span>
    <span class="c1">; zip the symbols with what they evaluate to</span>
    <span class="o">`</span><span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nb">zipmap </span><span class="o">&#39;~</span><span class="nv">ks</span> <span class="p">[</span><span class="o">~@</span><span class="nv">ks</span><span class="p">]))))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">1</span> <span class="nv">y</span> <span class="mi">2</span><span class="p">]</span> <span class="p">(</span><span class="nf">spy-env</span><span class="p">))</span>
<span class="c1">; {x 1, y 2}</span>

<span class="c1">; equivalent to</span>
<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">1</span> <span class="nv">y</span> <span class="mi">2</span><span class="p">]</span> <span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nb">zipmap </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">])))</span>
</code></pre></figure>
<p>Since macros are <em>currently</em> implemented as functions that take two extra arguments at the front, <code>&amp;form</code> and <code>&amp;env</code>, it&rsquo;s possible to access the macro&rsquo;s var and dereference it to use its implementing function directly. This is possible with the <code>#&#39;</code> syntax to refer to a var specifically (instead of the value the symbol represents) and <code>@</code> to then dereference that var.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="c1">; equivalent</span>
<span class="p">(</span><span class="o">@#</span><span class="ss">&#39;spy-env</span> <span class="nv">nil</span> <span class="p">{</span><span class="ss">&#39;x</span> <span class="mi">2</span><span class="p">})</span>
<span class="p">((</span><span class="nb">deref </span><span class="p">(</span><span class="k">var </span><span class="nv">simplify</span><span class="p">))</span> <span class="nv">nil</span> <span class="p">{</span><span class="ss">&#39;x</span> <span class="mi">2</span><span class="p">})</span>
</code></pre></figure>
<p>The <code>&amp;form</code> binding holds the whole form that is being macro-expanded, which consists of a list containing the name of the macro as a symbol and the arguments to the macro. As a result, <code>&amp;form</code> contains all of the metadata specified by the user or added by the reader.</p>

<p>One instance where having access to this metadata could be useful is to produce more accurate errors, with &ldquo;correct&rdquo; line numbers, specifically the line number of the macro&rsquo;s <em>usage</em> and not its location within the macro&rsquo;s expanded code.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defmacro </span><span class="nv">func</span>
  <span class="p">[</span><span class="o">&amp;</span> <span class="nv">xs</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">condition</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">throw</span> <span class="p">(</span><span class="nf">IllegalArgumentException.</span>
            <span class="p">(</span><span class="nf">format</span> <span class="s">&quot;some error on line %s&quot;</span>
              <span class="c1">; get :line from &amp;form&#39;s metadata</span>
              <span class="c1">; which contains the line number</span>
              <span class="c1">; on which the user used the macro</span>
              <span class="p">(</span><span class="nb">-&gt; </span><span class="o">&amp;</span><span class="nv">form</span> <span class="nb">meta </span><span class="ss">:line</span><span class="p">))))</span>
    <span class="mi">1</span><span class="p">))</span>
</code></pre></figure>
<p>It&rsquo;s important to note that by default, defining a macro does not preserve the its arguments' metadata. To preserve it, the arguments should be re-bound by creating a symbol with <code>gensym</code> and using the metadata of <code>&amp;form</code> and setting it to the gensym with <code>with-meta</code>, then binding the argument to that gensym.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">preserve-metadata</span>
  <span class="p">[</span><span class="o">&amp;</span><span class="nv">form</span> <span class="nv">expr</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">res</span> <span class="p">(</span><span class="nb">with-meta </span><span class="p">(</span><span class="nb">gensym </span><span class="s">&quot;res&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">meta </span><span class="o">&amp;</span><span class="nv">form</span><span class="p">))]</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="o">~</span><span class="nv">res</span> <span class="o">~</span><span class="nv">expr</span><span class="p">]</span>
      <span class="o">~</span><span class="nv">res</span><span class="p">)))</span>
</code></pre></figure><h1 id="protocols">
<span class="hash">#</span>
<a href="#protocols" class="header-link">Protocols</a>
</h1>
<p>Protocols are the corollary to interfaces in other languages <sup id="fnref13"><a href="#fn13" rel="footnote">13</a></sup> and they consist of a variable number of methods each with a variable number of arities, where each has an arity of at least 1 which corresponds to <code>this</code> in Java, which is implicit and so can be given any name. By convention, protocol names are written in camel-case to make them easy to distinguish from other Clojure entities.</p>

<p>Note that the &ldquo;rest&rdquo; arguments destructuring syntax can&rsquo;t be used with Clojure protocols since they generate <abbr title="Java Virtual Machine">JVM</abbr> interfaces which can&rsquo;t support all of the argument structure variations of Clojure functions.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defprotocol </span><span class="nv">ProtocolName</span>
  <span class="s">&quot;documentation&quot;</span>
  <span class="p">(</span><span class="nf">a-method</span> <span class="p">[</span><span class="nv">this</span> <span class="nv">arg1</span> <span class="nv">arg2</span><span class="p">]</span> <span class="s">&quot;method docstring&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">another-method</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">arg</span><span class="p">]</span> <span class="s">&quot;docstring&quot;</span><span class="p">))</span>
</code></pre></figure>
<p>Protocols can then be extended to existing types using <code>extend-protocol</code> with the name of the protocol as the first argument and the type that will be extending it as the second. A variable number of symbols (type names) and corresponding lists (method implementations for the previous symbol) can be provided to <code>extend-protocol</code>.</p>

<p>It&rsquo;s <em>not</em> necessary to implement every method in a protocol. Instead, calling an unimplemented method will simply throw an exception.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">extend-protocol</span> <span class="nv">SomeProtocol</span>
  <span class="nv">Type1</span>
  <span class="p">(</span><span class="nf">method1-from-SomeProtocol</span> <span class="p">[</span><span class="nv">this</span> <span class="nv">x</span><span class="p">])</span>
  <span class="nv">Type2</span>
  <span class="p">(</span><span class="nf">method1-from-SomeProtocol</span> <span class="p">[</span><span class="nv">this</span> <span class="nv">x</span><span class="p">]))</span>
</code></pre></figure>
<p>The converse to <code>extend-protocol</code> is <code>extend-type</code> which can be used to extend several protocols to one type.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">extend-type</span> <span class="nv">SomeType</span>
  <span class="nv">Protocol1</span>
  <span class="p">(</span><span class="nf">method-from-protocol1</span> <span class="p">[</span><span class="nv">this</span> <span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">impl</span><span class="p">))</span>
  <span class="nv">Protocol2</span>
  <span class="p">(</span><span class="nf">method-from-protocol2</span> <span class="p">[</span><span class="nv">this</span> <span class="nv">y</span><span class="p">]</span> <span class="p">(</span><span class="nf">impl</span><span class="p">)))</span>
</code></pre></figure>
<p>It&rsquo;s possible extend a protocol to <code>nil</code>, potentially doing away with many null pointer exceptions if a sane default exists for an operation.</p>
<h1 id="custom-types">
<span class="hash">#</span>
<a href="#custom-types" class="header-link">Custom Types</a>
</h1>
<p>Clojure types are Java classes that can be defined with <code>defrecord</code> and <code>deftype</code>. Records are meant for application-level data, while types are meant for low-level infrastructure types such as for new data structures. The differences between the two functions lie in the defaults that records provide for interoperating with the rest of Clojure and Java, and the capabilities of types to optimize low-level operations.</p>

<p>Creating an instance of a type is done by putting the type name in the function position with a period <code>.</code> as suffix. Conversely, fields can be accessed with the field name in the function position with a period <code>.</code> prefix and the instance as the second argument.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defrecord </span><span class="nv">Point</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">])</span>

<span class="c1">; or</span>
<span class="p">(</span><span class="kd">deftype </span><span class="nv">Point</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">])</span>

<span class="p">(</span><span class="nf">.x</span> <span class="p">(</span><span class="nf">Point.</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1">;= 3</span>
</code></pre></figure>
<p>It&rsquo;s important to realize that types are not defined in namespaces, so they&rsquo;re not implicitly imported when using the namespace from another one, and so they must be explicitly qualified when importing.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defrecord </span><span class="nv">Point</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">])</span>

<span class="p">(</span><span class="kd">ns </span><span class="nv">user2</span><span class="p">)</span>
<span class="p">(</span><span class="nb">refer </span><span class="ss">&#39;user</span><span class="p">)</span>
<span class="nv">Point</span>
<span class="c1">;= CompilerException ...</span>

<span class="p">(</span><span class="nb">import </span><span class="ss">&#39;user.Point</span><span class="p">)</span>
<span class="nv">Point</span>
<span class="c1">;= user.Point</span>
</code></pre></figure>
<p>It&rsquo;s also possible to provide type metadata for primitive and non-primitive fields, otherwise they are assumed to be <span class="path">java.lang.Object</span>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defrecord </span><span class="nv">NamedPoint</span> <span class="p">[</span><span class="o">^</span><span class="nv">String</span> <span class="nb">name </span><span class="o">^</span><span class="nb">long </span><span class="nv">x</span> <span class="o">^</span><span class="nb">long </span><span class="nv">y</span><span class="p">])</span>
</code></pre></figure>
<p>The enumeration of defined fields for a class defined by <code>deftype</code> or <code>defrecord</code> is known as its <em>basis</em> and is available via a static method <code>/getBasis</code>, and each symbol in this basis retains the metadata provided in its definition.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">NamedPoint/getBasis</span><span class="p">)</span>
<span class="c1">;= [name x y]</span>

<span class="p">(</span><span class="nb">map meta </span><span class="p">(</span><span class="nf">NamedPoint/getBasis</span><span class="p">))</span>
<span class="c1">;= ({:tag String} {:tag long} {:tag long})</span>
</code></pre></figure><h2 id="records">
<span class="hash">#</span>
<a href="#records" class="header-link">Records</a>
</h2>
<p>Record types are defined by <code>defrecord</code> and are a specialization of types defined by <code>deftype</code>, specifically, they support:</p>

<ul>
<li>value semantics</li>
<li>associative collection abstraction</li>
<li>metadata support</li>
<li>reader support (serialization)</li>
<li>convenience constructors for instances with metadata and auxiliary fields</li>
</ul>

<p>Value semantics refers to being immutable and basing equality on the constituent fields, so that two records are equal if their fields have the same values.</p>

<p>Since they implement the associative collection abstraction, fields can be accessed by keywords named after the fields. A consequence of this is that new fields can be added with <code>assoc</code>, which is implemented as map associated with the record. However, if a <em>declared</em> field is removed with <code>dissoc</code>, the result is a map of the remaining fields and not the original record. Note, however, that unlike maps, records are not functions.</p>

<p>Record literals consist of the pound sign <code>#</code> followed by the record name and a map literal containing the field names as keyword keys with their associated values. Thanks to this syntax, records can very easily be serialized and deserialized.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">pr-str </span><span class="p">(</span><span class="nf">Point.</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1">;= &quot;#user.Point{:x 3, :y 4}&quot;</span>

<span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">read-string</span> <span class="nv">*1</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">Point.</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="c1">;= true</span>
</code></pre></figure>
<p>Records also have auxiliary constructors that take a penultimate argument consisting of the metadata to attach to the instance and a final argument consisting of extra fields to create.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">Point.</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">{</span><span class="ss">:foo</span> <span class="ss">:bar</span><span class="p">}</span> <span class="p">{</span><span class="ss">:z</span> <span class="mi">5</span><span class="p">})</span>

<span class="c1">; equivalent</span>
<span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">Point.</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">with-meta </span><span class="p">{</span><span class="ss">:foo</span> <span class="ss">:bar</span><span class="p">})</span>
    <span class="p">(</span><span class="nb">assoc </span><span class="ss">:z</span> <span class="mi">5</span><span class="p">))</span>
</code></pre></figure>
<p>Both <code>deftype</code> and <code>defrecord</code> implicitly create a factory function of the form <code>-&gt;MyType</code> which takes fields values positionally. Records also create a <code>map-&gt;MyType</code> factory function which takes a single map used for populating the new instance. These are both useful when used as higher-order functions.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">-&gt;Point</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">;= #user.Point{:x 3, :y 4}</span>

<span class="p">(</span><span class="nf">map-&gt;Point</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">3</span>, <span class="ss">:y</span> <span class="mi">4</span>, <span class="ss">:z</span> <span class="mi">5</span><span class="p">})</span>
<span class="c1">;= #user.Point{:x 3, :y 4, :z 5}</span>

<span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nb">partial apply </span><span class="nv">-&gt;Point</span><span class="p">)</span> <span class="p">[[</span><span class="mi">5</span> <span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span><span class="p">]])</span>
<span class="c1">;= (#user.Point{:x 5, :y 6}</span>
<span class="c1">;=  #user.Point{:x 7, :y 8})</span>

<span class="p">(</span><span class="nb">map </span><span class="nv">map-&gt;Point</span> <span class="p">[{</span><span class="ss">:x</span> <span class="nv">y</span> <span class="ss">:y</span> <span class="mi">2</span><span class="p">}</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">5</span> <span class="ss">:y</span> <span class="mi">6</span> <span class="ss">:z</span> <span class="mi">44</span><span class="p">}])</span>
<span class="c1">;= (#user.Point{:x 1, :y 2}</span>
<span class="c1">;=  #user.Point{:x 5, :y 6, :z 44})</span>
</code></pre></figure><h2 id="types">
<span class="hash">#</span>
<a href="#types" class="header-link">Types</a>
</h2>
<p>The <code>deftype</code> form is the lowest-level method of defining types in Clojure, which is why <code>defrecord</code> is built on top of it. Types defined by <code>deftype</code> allow for mutable fields. By contrast to <code>defrecord</code>, <em>immutable</em> fields are accessible <em>only</em> via interop forms, where the field name is prefixed by a period <code>.</code>, and <em>not</em> via keyword as in the associative abstraction.</p>

<p>Fields can be specified via metadata to be volatile or unsynchronized, denoted respectively by <code>^:volatile-mutable</code> and <code>^:unsynchronized-mutable</code>. Volatile refers to <code>volatile</code> in Java, where reads and writes of the field are atomic and cannot be reordered by the JIT compiler or CPU. Unsynchronized fields are regular Java mutable fields.</p>

<p>Unlike immutable fields, mutable fields are always private and as such can only be accessed from within method bodies provided inline with the type definition. Mutable fields can be set using the <code>set!</code> function.</p>
<h2 id="implementing-protocols">
<span class="hash">#</span>
<a href="#implementing-protocols" class="header-link">Implementing Protocols</a>
</h2>
<p>Protocols can be extended to existing types using the aforementioned <code>extend*</code> family of functions or within the <code>deftype</code> or <code>defrecord</code> functions, which would be known as an inline implementation.</p>

<p>Inline implementations correspond to Java interface implementations, which means that inline implementation methods have direct access to fields, whereas external implementations must use Java interop or keyword accessors, and method calls will be as fast as Java interface method calls.</p>

<p>However, this has a variety of consequences. For example, clashes can occur by implementing two protocols each containing methods with the same name and signature, which can occur with those interfaces for which <code>defrecord</code> automatically provides implementations, or even by implementing protocols whose methods conflict with <span class="path">java.lang.Object</span> methods.</p>

<p>Since inline implementations are baked into the type, those implementations can&rsquo;t be changed at runtime without redefining the entire type, necessitating the re-evaluation of all code that depends on the type. Worse, existing instances will not be updated after this redefinition and re-evaluation.</p>

<p>It&rsquo;s possible to create anonymous types with the <code>reify</code> function, which evaluates to an instance of an unnamed type, which is useful for creating objects that satisfy a given protocol on-the-fly, much like anonymous inner classes in Java.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">.listFiles</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="s">&quot;.&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">reify</span>
    <span class="nv">java.io.FileFilter</span>
    <span class="p">(</span><span class="nf">accept</span> <span class="p">[</span><span class="nv">this</span> <span class="nv">f</span><span class="p">]</span>
      <span class="p">(</span><span class="nf">.isDirectory</span> <span class="nv">f</span><span class="p">))))</span>
</code></pre></figure>
<p>Both <code>extend-type</code> and <code>extend-protocol</code> are based on <code>extend</code>, which takes the type to extend as the first argument and then a variable number of protocols and implementation maps, which are maps consisting of method names as keywords to functions implementing those methods.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defrecord </span><span class="nv">Point</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">])</span>

<span class="p">(</span><span class="nf">extend</span> <span class="nv">Point</span>
  <span class="nv">Protocol1</span>
  <span class="p">{</span><span class="ss">:method1</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">pt</span> <span class="nv">arg1</span> <span class="nv">arg2</span><span class="p">]</span> <span class="p">(</span><span class="nf">impl</span><span class="p">))</span>
   <span class="ss">:method2</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">pt</span> <span class="nv">arg1</span> <span class="nv">arg2</span><span class="p">]</span> <span class="p">(</span><span class="nf">impl</span><span class="p">))})</span>
</code></pre></figure>
<p>Since the implementation maps are just maps, they can be passed around and expanded upon.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">some-core-impl</span>
  <span class="p">{</span><span class="ss">:core-method1</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">pt</span><span class="p">]</span> <span class="p">(</span><span class="nf">impl</span><span class="p">))</span>
   <span class="ss">:core-method2</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">pt</span><span class="p">]</span> <span class="p">(</span><span class="nf">impl</span><span class="p">))})</span>

<span class="p">(</span><span class="nf">extend</span> <span class="nv">Point</span>
  <span class="nv">Matrix</span>
  <span class="p">(</span><span class="nb">assoc </span><span class="nv">some-core-impl</span>
    <span class="ss">:mixed-in-method1</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">pt</span><span class="p">]</span> <span class="p">(</span><span class="nf">impl</span><span class="p">))</span>
    <span class="ss">:mixed-in-method2</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">pt</span><span class="p">]</span> <span class="p">(</span><span class="nf">impl</span><span class="p">))))</span>
</code></pre></figure>
<p>Similarly, it&rsquo;s possible to simulate mixin behaviors. Consider a <code>Measurable</code> protocol which defines methods for retrieving dimensions of things, and a type <code>Button</code> that extends it. Given another implementation map <code>bordered</code>, we want to create a <code>BorderedButton</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defprotocol </span><span class="nv">Measurable</span>
  <span class="s">&quot;Protocol for retrieving the dimensions of widgets&quot;</span>
  <span class="p">(</span><span class="nf">width</span> <span class="p">[</span><span class="nv">measurable</span><span class="p">]</span> <span class="s">&quot;Returns the width&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">height</span> <span class="p">[</span><span class="nv">measureable</span><span class="p">]</span> <span class="s">&quot;Returns the height&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defrecord </span><span class="nv">Button</span> <span class="p">[</span><span class="nv">text</span><span class="p">])</span>

<span class="p">(</span><span class="nf">extend-type</span> <span class="nv">Button</span>
  <span class="nv">Measurable</span>
  <span class="p">(</span><span class="nf">width</span> <span class="p">[</span><span class="nv">btn</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">* </span><span class="mi">8</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">btn</span> <span class="ss">:text</span> <span class="nv">count</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">height</span> <span class="p">[</span><span class="nv">btn</span><span class="p">]</span> <span class="mi">8</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">bordered</span>
  <span class="p">{</span><span class="ss">:width</span> <span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="ss">:border-width</span> <span class="nv">%</span><span class="p">))</span>
   <span class="ss">:height</span> <span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="ss">:border-height</span> <span class="nv">%</span><span class="p">))})</span>
</code></pre></figure>
<p>To create a <code>BorderedButton</code>, we would need the implementation map of <code>Button</code>. Protocols name vars that contain a map with relevant information, including an implementation map. We can then use the <code>merge-with</code> function to merge the two implementation maps, combining the same methods by adding their results.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defrecord </span><span class="nv">BorderedButton</span> <span class="p">[</span><span class="nv">text</span> <span class="nv">border-width</span> <span class="nv">border-height</span><span class="p">])</span>

<span class="p">(</span><span class="nf">extend</span> <span class="nv">BorderedButton</span>
  <span class="nv">Measurable</span>
  <span class="p">(</span><span class="nf">merge-with</span>
    <span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">apply </span><span class="nv">%1</span> <span class="nv">%</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">%2</span> <span class="nv">%</span><span class="o">&amp;</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">get-in</span> <span class="nv">Measurable</span> <span class="p">[</span><span class="ss">:impls</span> <span class="nv">Button</span><span class="p">])</span>
    <span class="nv">bordered</span><span class="p">))</span>

<span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">btn</span> <span class="p">(</span><span class="nf">BorderedButton.</span> <span class="s">&quot;Hello World&quot;</span> <span class="mi">6</span> <span class="mi">4</span><span class="p">)]</span>
  <span class="p">[(</span><span class="nf">width</span> <span class="nv">btn</span><span class="p">)</span> <span class="p">(</span><span class="nf">height</span> <span class="nv">btn</span><span class="p">)])</span>
<span class="c1">;= [100 16]</span>
</code></pre></figure>
<p>There are a variety of functions that can be used for protocol introspection. The <code>extenders</code> function returns the classes that have been extended by the given protocol at the point in time in which the function is called, since classes can extend protocols at run-time. Similarly, the <code>extends?</code> function tests if a type extends a given protocol. The <code>satisfies?</code> function is like the <code>instance?</code> corollary to <code>extends?</code>, since it works on instances.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">extenders</span> <span class="nv">Measurable</span><span class="p">)</span>
<span class="c1">;= (user.BorderedButton user.Button)</span>

<span class="p">(</span><span class="nf">extends?</span> <span class="nv">Measurable</span> <span class="nv">Button</span><span class="p">)</span>
<span class="c1">;= true</span>

<span class="p">(</span><span class="nf">satisfies?</span> <span class="nv">Measurable</span> <span class="p">(</span><span class="nf">Button.</span> <span class="s">&quot;hello&quot;</span><span class="p">))</span>
<span class="c1">;= true</span>
</code></pre></figure><h1 id="multimethods">
<span class="hash">#</span>
<a href="#multimethods" class="header-link">Multimethods</a>
</h1>
<p>Protocols provided polymorphic dispatch by way of type-based single dispatch. Multimethods provide multiple dispatch, and even dispatch based on things other than argument type. Multimethods are created using <code>defmulti</code>, which defines the multiple dispatch, and implementations are provided with <code>defmethod</code>, which defines the methods to which the calls are dispatched.</p>

<p>Multimethods work by passing the arguments passed to the multimethod are passed to a <em>dispatch function</em> defined by <code>defmulti</code>, which yields a <em>dispatch value</em> which is used to select the method to invoke for those arguments.</p>

<p>In the example below, the <code>:tag</code> is is the dispatch value.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defmulti </span><span class="nv">fill</span>
  <span class="s">&quot;Fill xml/html node with the provided value&quot;</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">node </span><span class="nv">value</span><span class="p">]</span> <span class="p">(</span><span class="ss">:tag</span> <span class="nv">node</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">fill</span> <span class="ss">:div</span>
  <span class="p">[</span><span class="nb">node </span><span class="nv">value</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">assoc node </span><span class="ss">:content</span> <span class="p">[(</span><span class="nb">str </span><span class="nv">value</span><span class="p">)]))</span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">fill</span> <span class="ss">:input</span>
  <span class="p">[</span><span class="nb">node </span><span class="nv">value</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">assoc-in</span> <span class="nb">node </span><span class="p">[</span><span class="ss">:attrs</span> <span class="ss">:value</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="nv">value</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">fill</span> <span class="p">{</span><span class="ss">:tag</span> <span class="ss">:div</span><span class="p">}</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="c1">;= {:content [&quot;hello&quot;], :tag :div}</span>

<span class="p">(</span><span class="nf">fill</span> <span class="p">{</span><span class="ss">:tag</span> <span class="ss">:input</span><span class="p">}</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="c1">;= {:attrs {:value &quot;hello&quot;}, :tag :input}</span>
</code></pre></figure>
<p>It&rsquo;s possible to define a base case implementation using the special dispatch value <code>:default</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">fill</span> <span class="p">{</span><span class="ss">:span</span> <span class="ss">:input</span><span class="p">}</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="c1">;= #&lt;IllegalArgumentException ...&gt;</span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">fill</span> <span class="ss">:default</span>
  <span class="p">[</span><span class="nb">node </span><span class="nv">value</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">assoc node </span><span class="ss">:content</span> <span class="p">[(</span><span class="nb">str </span><span class="nv">value</span><span class="p">)]))</span>

<span class="p">(</span><span class="nf">fill</span> <span class="p">{</span><span class="ss">:span</span> <span class="ss">:input</span><span class="p">}</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="c1">;= {:content [&quot;hello&quot;], :span :input}</span>
</code></pre></figure>
<p>It&rsquo;s also possible to specify what the default dispatch value should be by passing it as an option to <code>defmulti</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defmulti </span><span class="nv">fill</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">node </span><span class="nv">value</span><span class="p">]</span> <span class="p">(</span><span class="ss">:tag</span> <span class="nv">node</span><span class="p">))</span>
  <span class="ss">:default</span> <span class="nv">nil</span><span class="p">)</span>
</code></pre></figure><h2 id="hierarchies">
<span class="hash">#</span>
<a href="#hierarchies" class="header-link">Hierarchies</a>
</h2>
<p>Hierarchies express relationships between dispatch values which can multimethods can use to refine the selection of implementation method. Relationships are defined with the <code>derive</code> function, which accepts an optional hierarchy reference, and the remaining arguments express that the first derives from the second.</p>

<p>If the first optional argument&mdash;the hierarchy reference&mdash;is not provided to <code>derive</code>, then it is assumed to encode that relationship in the default, global hierarchy. Otherwise, a separate hierarchy can be created with the <code>make-hierarchy</code> function.</p>

<p>The relationships are defined to be between named objects (e.g. keywords or symbols) and classes, but classes (and interfaces) can only serve as leaves in a relationship. Since the global hierarchy is global, and thus shared, collisions are avoided by prohibiting non-namespaced keywords or symbols.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="c1">; ::keyword expands to :currentnamespace/keyword</span>
<span class="c1">; `symbol would expand to &#39;originnamespaceorcurrent/keyword</span>
<span class="p">(</span><span class="nf">derive</span> <span class="ss">::checkbox</span> <span class="ss">::checkable</span><span class="p">)</span>
<span class="p">(</span><span class="nf">derive</span> <span class="ss">::radio</span> <span class="ss">::checkable</span><span class="p">)</span>
<span class="c1">;= true</span>
</code></pre></figure>
<p>The <code>isa?</code> function can be used to test a relationship. It also takes an optional first argument for the hierarchy reference, in case it&rsquo;s not the global one.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">isa?</span> <span class="ss">::checkbox</span> <span class="ss">::checkable</span><span class="p">)</span>
</code></pre></figure>
<p>Multimethods can use independent hierarchies via a <code>:hierarchy</code> option, and then use the relationships in method implementations to refer to categories of dispatch values.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">def </span><span class="nv">fill-hierarchy</span>
  <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">make-hierarchy</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">derive</span> <span class="ss">:input.radio</span> <span class="ss">::checkable</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">derive</span> <span class="ss">:input.checkbox</span> <span class="ss">::checkable</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">derive</span> <span class="ss">::checkable</span> <span class="ss">:input</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defmulti </span><span class="nv">fill</span>
  <span class="o">#</span><span class="ss">&#39;fill-dispatch</span>
  <span class="ss">:default</span> <span class="nv">nil</span>
  <span class="ss">:hierarchy</span> <span class="o">#</span><span class="ss">&#39;fill-hierarchy</span><span class="p">)</span>

<span class="c1">; default case</span>
<span class="p">(</span><span class="kd">defmethod </span><span class="nv">fill</span> <span class="nv">nil</span> <span class="p">[</span><span class="nb">node </span><span class="nv">value</span><span class="p">]</span> <span class="nv">...</span><span class="p">)</span>

<span class="c1">; all ::checkable&#39;s match</span>
<span class="c1">; - :input.radio</span>
<span class="c1">; - :input.checkbox</span>
<span class="p">(</span><span class="kd">defmethod </span><span class="nv">fill</span> <span class="ss">::checkable</span> <span class="p">[</span><span class="nb">node </span><span class="nv">value</span><span class="p">]</span> <span class="nv">...</span><span class="p">)</span>
</code></pre></figure>
<p>The hierarchy can be modified dynamically with <code>alter-var-root</code>, which can be used in a pattern where the default method implementation can extend the hierarchy to include new dispatch values which triggered that method.</p>

<p>The <code>isa?</code> function treats vectors, specifically pairs, as special cases. As a result, dispatch values can be vectors consisting of a relationship. Since the Java class hierarchy is in every hierarchy, a pattern is to piggyback a Java class as added information. The implementation method below, for example, applies when the dispatch value is a <code>::checkable</code> and the value in question is a Clojure set. This is possible because the dispatch function returns a pair of the dispatch value and the value&rsquo;s class, both encoded as a hierarchical relationship.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="c1">; equivalent</span>
<span class="p">(</span><span class="nf">isa?</span> <span class="p">[</span><span class="ss">::checkbox</span> <span class="ss">::checkable</span><span class="p">])</span>
<span class="p">(</span><span class="nf">isa?</span> <span class="ss">::checkbox</span> <span class="ss">::checkable</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defmethod </span><span class="nv">fill</span> <span class="p">[</span><span class="ss">::checkable</span> <span class="nv">clojure.lang.IPersistentSet</span><span class="p">]</span>
  <span class="p">[</span><span class="nb">node </span><span class="nv">value</span><span class="p">]</span>
  <span class="nv">...</span><span class="p">)</span>
</code></pre></figure>
<p>When a type implements multiple interfaces, multimethods won&rsquo;t know which implementation to pick unless one is defined as being preferred using the <code>prefer-method</code> function, which takes as argument the multimethod in question and the two dispatch values, where the first is the one that is preferred over the second.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defmulti </span><span class="nv">run</span> <span class="nv">class</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defmethod </span><span class="nv">run</span> <span class="nv">Runnable</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">.run</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defmethod </span><span class="nv">run</span> <span class="nv">java.util.concurrent.Callable</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">.call</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nf">run</span> <span class="o">#</span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;hello!&quot;</span><span class="p">))</span>
<span class="c1">;= multiple methods match dispatch value, neither preferred</span>

<span class="p">(</span><span class="nf">prefer-method</span> <span class="nv">run</span> <span class="nv">java.util.concurrent.Callable</span> <span class="nv">Runnable</span><span class="p">)</span>
<span class="p">(</span><span class="nf">run</span> <span class="o">#</span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;hello!&quot;</span><span class="p">))</span>
<span class="c1">;= hello!</span>
</code></pre></figure>
<p>Multimethods support a variety of introspection methods including <code>remove-method</code>, <code>remove-all-methods</code>, <code>prefers</code>, <code>methods</code>, and <code>get-method</code>, which are pretty self-explanatory.</p>

<p>The <code>type</code> function is similar to the <code>class</code> function, except that if a <code>:type</code> metadata is present, it returns its value instead of what <code>class</code> would return.</p>
<h1 id="build-tools">
<span class="hash">#</span>
<a href="#build-tools" class="header-link">Build Tools</a>
</h1>
<p>The most popular build tool in the Java world is Maven. Maven&rsquo;s dependency management model consists of <em>artifacts</em>, which are files that are the product of the build process. Artifacts are identified by <em>coordinates</em>, which are a group of attributes that uniquely identify a particular version of an artifact, in the form <span class="path">groupId:artifactId:packaging:version</span>.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Attribute</th>
<th style="text-align: left">Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">groupId</td>
<td style="text-align: left">organizational/project identifier</td>
</tr>
<tr>
<td style="text-align: left">artifactId</td>
<td style="text-align: left">project identifier</td>
</tr>
<tr>
<td style="text-align: left">packaging</td>
<td style="text-align: left">type of artifact (jar)</td>
</tr>
<tr>
<td style="text-align: left">version</td>
<td style="text-align: left">version string</td>
</tr>
</tbody>
</table>

<p>A project defines its own coordinates in a Maven <span class="path">pom.xml</span> or Leiningen <span class="path">project.cjl</span> file. The <span class="path">pom.xml</span> file can be uploaded to a Maven repository in order to make it available to others. The most popular Maven repositories consist of Maven central and, for Clojure, <a href="http://clojars.org">clojars.org</a>.</p>

<p>Dependencies can be expressed by specifying the versions that are required. There are snapshot and release version types, where snapshot versions are tracked &ldquo;bleeding edge&rdquo; releases suffixed with <code>-SNAPSHOT</code> and release versions are frozen releases that may follow <a href="http://semver.org/">semantic versioning practices</a>.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Type</th>
<th style="text-align: left">Example</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Release</td>
<td style="text-align: left">0.2.1-beta5</td>
</tr>
<tr>
<td style="text-align: left">Snapshot</td>
<td style="text-align: left">1.0.0-SNAPSHOT</td>
</tr>
</tbody>
</table>

<p>Version ranges can be used to restrict or relax certain dependencies. Version range format uses <a href="http://en.wikipedia.org/wiki/Interval_%28mathematics%29#Excluding_the_endpoints">mathematical range format</a> to express inclusive or exclusive ends, where an omitted end represents &ldquo;infinity.&rdquo; A version without range delimiters refers to a &ldquo;soft&rdquo; version requirement so that the version chosen is deferred to the one required by any other transitive dependency, if any. Conversely, version number within brackets specifies a &ldquo;hard&rdquo; version dependency.</p>

<p>Although Maven is the most popular build tool in Java, its dependency management and project configuration is overly verbose for what&rsquo;s needed with Clojure. Instead, it&rsquo;s more common to use <a href="http://leiningen.org/">Leiningen</a> when working with Clojure.</p>

<p>A <span class="path">project.cjl</span> file is used for project configuration and dependency management. The <code>defproject</code> macro is used takes as first two arguments the projects coordinates, with the second of the two being the version string on its own, so that Maven&rsquo;s coordinate <span class="path">com.abc:site:1.0.0</span> corresponds to <code>com.abc/site &quot;1.0.0&quot;</code> in Leiningen. If the first argument is an unnamespaced symbol, then it&rsquo;s assumed that the artifact ID and the group ID are the same.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defproject </span><span class="nv">leiningen.org</span> <span class="s">&quot;1.0.0&quot;</span>
  <span class="ss">:description</span> <span class="s">&quot;Generate static HTML for http://leiningen.org&quot;</span>
  <span class="ss">:dependencies</span> <span class="p">[[</span><span class="nv">enlive</span> <span class="s">&quot;1.0.1&quot;</span><span class="p">]</span>
                 <span class="p">[</span><span class="nv">cheshire</span> <span class="s">&quot;4.0.0&quot;</span><span class="p">]</span>
                 <span class="p">[</span><span class="nv">org.markdownj/markdownj</span> <span class="s">&quot;0.3.0-1.0.2b4&quot;</span><span class="p">]]</span>
  <span class="ss">:main</span> <span class="nv">leiningen.web</span><span class="p">)</span>
</code></pre></figure>
<p>Leiningen has a variety of sub-commands to the main <code>lein</code> command.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Command</th>
<th style="text-align: left">Use</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>repl</code></td>
<td style="text-align: left">start <abbr title="Read-Eval-Print-Loop">REPL</abbr> with dependencies in classpath</td>
</tr>
<tr>
<td style="text-align: left"><code>test</code></td>
<td style="text-align: left">run all tests</td>
</tr>
<tr>
<td style="text-align: left"><code>jar</code></td>
<td style="text-align: left">package project into a jar file</td>
</tr>
<tr>
<td style="text-align: left"><code>uberjar</code></td>
<td style="text-align: left">like <code>jar</code> command but unpacks all dependencies into it as well</td>
</tr>
<tr>
<td style="text-align: left"><code>compile</code></td>
<td style="text-align: left">perform ahead-of-time compilation</td>
</tr>
<tr>
<td style="text-align: left"><code>pom</code></td>
<td style="text-align: left">generate Maven-compatible <code>pom.xml</code> file; for repo publishing</td>
</tr>
<tr>
<td style="text-align: left"><code>deps</code></td>
<td style="text-align: left">downloads all dependencies if necessary</td>
</tr>
</tbody>
</table>

<p>To perform ahead-of-time (<abbr title="Ahead-of-Time">AOT</abbr>) compilation, an <code>:aot</code> slot needs to be added to the <code>defproject</code> macro with a value of <code>:all</code> to compile all namespaces in the project, or a vector of namespaces specifying which to compile.</p>

<p>It may be useful to perform <abbr title="Ahead-of-Time">AOT</abbr> compilation as a sanity check, but ignore the produced class files. While Maven has support for this, Leiningen doesn&rsquo;t and so the best approximation would be to perform a <code>compile</code> followed by a <code>clean</code>.</p>

<p>I encountered problems when setting <code>:aot</code> in the <code>dev</code> environment, it seems to particularly conflict with leiningen plugins. For this reason it&rsquo;s probably best to reserve this option for the <code>uberjar</code> or other release environment.</p>
<h1 id="java-interoperability">
<span class="hash">#</span>
<a href="#java-interoperability" class="header-link">Java Interoperability</a>
</h1>
<p>The <code>doto</code> macro can perform a series of operations on an object, yielding the object at the end.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">doto </span><span class="p">(</span><span class="nf">ArrayList.</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">.add</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">.add</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">.add</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></figure><h2 id="exception-handling">
<span class="hash">#</span>
<a href="#exception-handling" class="header-link">Exception Handling</a>
</h2>
<p>Exceptions are the same as Java&rsquo;s. The <code>try</code> form defines the scope of the exception-handling. It can contain a variable number of <code>catch</code> forms and optionally a single <code>finally</code> form. The <code>finally</code> form executes regardless of whether or not there were exceptions, and it&rsquo;s only useful for side-effecting actions as it doesn&rsquo;t affect the result of the <code>try</code> form.</p>

<p>The <code>throw</code> form can be used to throw an exception, which must take an instance of a class that is <code>Throwable</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">as-int</span>
  <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">try</span>
    <span class="p">(</span><span class="nf">Integer/parseInt</span> <span class="nv">s</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">catch</span> <span class="nv">NumberFormatException</span> <span class="nv">e</span>
      <span class="p">(</span><span class="nf">.printStackTrace</span> <span class="nv">e</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">finally</span>
      <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Attempted to parse as integer: &quot;</span> <span class="nv">s</span><span class="p">))))</span>
</code></pre></figure>
<p>Idiomatic Java uses <code>finally</code> <sup id="fnref14"><a href="#fn14" rel="footnote">14</a></sup> to ensure that resources are closed properly in the case of exceptions. Java 7 introduced try-with-statements which can do this more concisely. Similarly, Clojure provides the <code>with-open</code> form that does this as well, which can take a variable number of resource bindings.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">append-to</span>
  <span class="p">[</span><span class="nv">f</span> <span class="nv">text</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">io/writer</span> <span class="nv">f</span> <span class="ss">:append</span> <span class="nv">true</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">doto </span><span class="nv">w</span>
      <span class="p">(</span><span class="nf">.write</span> <span class="nv">text</span><span class="p">)</span>
      <span class="nv">.flush</span><span class="p">)))</span>
</code></pre></figure><h2 id="type-hinting">
<span class="hash">#</span>
<a href="#type-hinting" class="header-link">Type Hinting</a>
</h2>
<p>Type hints are explicit indications of the object type to the Clojure compiler. When this isn&rsquo;t done, Clojure code that uses interop might perform reflection at run-time to determine the method to call, which can impact performance. Setting <code>*warn-on-reflection*</code> to <code>true</code> can yield reflection warnings which warn when a particular method can&rsquo;t be resolved statically.</p>

<p>Type hints can be added to return values by adding them to the argument vectors.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">file-extension</span>
  <span class="o">^</span><span class="nv">String</span> <span class="p">[</span><span class="o">^</span><span class="nv">java.io.File</span> <span class="nv">f</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nb">re-seq </span><span class="o">#</span><span class="s">&quot;\.(.+)&quot;</span> <span class="p">(</span><span class="nf">.getName</span> <span class="nv">f</span><span class="p">))</span>
    <span class="nv">first</span>
    <span class="nv">second</span><span class="p">))</span>
</code></pre></figure><h2 id="arrays">
<span class="hash">#</span>
<a href="#arrays" class="header-link">Arrays</a>
</h2>
<p>Primitive Java arrays are supported via a variety of functions.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="c1">; convert to array</span>
<span class="p">(</span><span class="nb">into-array </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">])</span>

<span class="c1">; new Integer[10][100]</span>
<span class="p">(</span><span class="nb">make-array </span><span class="nv">Integer</span> <span class="mi">10</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1">; access some_array[4]</span>
<span class="p">(</span><span class="nb">aget </span><span class="nv">some-array</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1">; set array some_array[4] = 3</span>
<span class="p">(</span><span class="nb">aset </span><span class="nv">some-array</span> <span class="mi">4</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></figure>
<p>There are also helper functions to create primitive arrays, such as <code>boolean-array</code>, <code>byte-array</code>, and so on, which takes as argument the desired size or a collection from which to source the array.</p>

<p>Sometimes it&rsquo;s necessary to get the class of an array type to, for example, implement a protocol for an array of that type. Classes for arrays are written using <abbr title="Java Virtual Machine">JVM</abbr> notation with left brackets <code>[</code> for each array dimension followed by a letter denoting the array type.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Type</th>
<th style="text-align: left">Letter</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>boolean</code></td>
<td style="text-align: left">Z</td>
</tr>
<tr>
<td style="text-align: left"><code>byte</code></td>
<td style="text-align: left">B</td>
</tr>
<tr>
<td style="text-align: left"><code>char</code></td>
<td style="text-align: left">C</td>
</tr>
<tr>
<td style="text-align: left"><code>long</code></td>
<td style="text-align: left">J</td>
</tr>
<tr>
<td style="text-align: left"><code>int</code></td>
<td style="text-align: left">I</td>
</tr>
<tr>
<td style="text-align: left"><code>short</code></td>
<td style="text-align: left">S</td>
</tr>
<tr>
<td style="text-align: left"><code>double</code></td>
<td style="text-align: left">D</td>
</tr>
<tr>
<td style="text-align: left"><code>float</code></td>
<td style="text-align: left">F</td>
</tr>
</tbody>
</table>

<p>The <code>Class/forName</code> function can then be used to yield a class from this notation.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">class </span><span class="p">(</span><span class="nb">make-array </span><span class="nv">Character/TYPE</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">))</span>
<span class="c1">;= [[[C</span>

<span class="p">(</span><span class="nf">Class/forName</span> <span class="s">&quot;[[[C&quot;</span><span class="p">)</span>
<span class="c1">;= [[[C</span>
</code></pre></figure>
<p>There also exist type hints that are specifically for use with arrays.</p>

<ul>
<li><code>^objects</code></li>
<li><code>^booleans</code></li>
<li><code>^bytes</code></li>
<li><code>^chars</code></li>
<li><code>^longs</code></li>
<li><code>^ints</code></li>
<li><code>^shorts</code></li>
<li><code>^doubles</code></li>
<li><code>^floats</code></li>
</ul>

<p>Using the <code>map</code> and <code>reduce</code> functions on arrays would box the resulting values. For this reason, the <code>amap</code> and <code>areduce</code> functions exist which avoid autoboxing. The <code>amap</code> function takes as first argument the name to give the array, followed by the name to give the index, followed by the name to give the result array, and finally the expression whose result will be used as the value at the current index in the result array.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span> <span class="p">(</span><span class="nf">int-array</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">amap</span> <span class="nv">a</span> <span class="nv">i</span> <span class="nv">res</span>
    <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">aget </span><span class="nv">a</span> <span class="nv">i</span><span class="p">))))</span>
</code></pre></figure>
<p>With multidimensional arrays, the intermediate levels are arrays of objects.</p>

<p>The <code>aget</code> and <code>aset</code> functions support multidimensional operations by recursively using <code>apply</code> to get/set each level of the array. The use of <code>apply</code> causes the primitives to get autoboxed, which would have a <em>significant</em> impact on performance. The workaround for this is to bind each array dimension to a different name in order to be able to provide type hints.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="mi">1000</span><span class="p">]</span>
        <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">j</span> <span class="mi">1000</span><span class="p">]</span>
          <span class="p">(</span><span class="nb">aset </span><span class="nv">arr</span> <span class="nv">i</span> <span class="nv">j</span> <span class="mf">1.0</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">aget </span><span class="nv">arr</span> <span class="nv">i</span> <span class="nv">j</span><span class="p">))))</span>
<span class="c1">; &quot;Elapsed time: 50802.798 msecs&quot;</span>

<span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="mi">1000</span><span class="p">]</span>
        <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">j</span> <span class="mi">1000</span><span class="p">]</span>
          <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="o">^</span><span class="nv">doubles</span> <span class="nv">darr</span> <span class="p">(</span><span class="nb">aget </span><span class="o">^</span><span class="nv">objects</span> <span class="nv">arr</span> <span class="nv">i</span><span class="p">)]</span>
            <span class="p">(</span><span class="nb">aset </span><span class="nv">darr</span> <span class="nv">j</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">aget </span><span class="nv">darr</span> <span class="nv">j</span><span class="p">)))))</span>
<span class="c1">; &quot;Elapsed time: 21.543 msecs&quot;</span>
</code></pre></figure><h2 id="classes">
<span class="hash">#</span>
<a href="#classes" class="header-link">Classes</a>
</h2>
<p>The <code>proxy</code> form can be used to yield an instance of an anonymous class, like <code>reify</code>, except that it can be used to extend an existing base class or interfaces. It takes a vector containing the base class and/or interfaces, and another vector for the arguments to use for that class' constructor. The rest of the forms are method implementations.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">proxy </span><span class="p">[</span><span class="nv">java.util.LinkedHashMap</span><span class="p">]</span> <span class="p">[</span><span class="mi">16</span> <span class="mf">0.75</span> <span class="nv">true</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">removeEldestEntry</span> <span class="p">[</span><span class="nv">entry</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">count </span><span class="nv">this</span><span class="p">)</span> <span class="nv">max-size</span><span class="p">)))</span>
</code></pre></figure>
<p>Alternatively, the <code>gen-class</code> is more definitive in terms of defining a Java class, as it can define a class in any package with any name, extending a base class with access to its protected fields, implent interfaces, define a variable number of constructors, static and instance methods, and static main methods.</p>

<p>The <code>gen-class</code> form must be <abbr title="Ahead-of-Time">AOT</abbr> compiled, which causes it to emit Java class files. The implementations of the methods specified in <code>gen-class</code> are delegated to regular Clojure functions, whose names start witha  prefix which by default is <code>-</code>. Method declarations specify their signature as a vector where the first element is the method name, the second element is a vector of the arguments' types, and the last and third element is the return type.</p>

<p>The namespace form <code>ns</code> can accept a <code>:gen-class</code> form which consists of a map that is forwarded to the <code>gen-class</code> form, where the class takes on the name of the namespace.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">gen-class</span>
  <span class="ss">:name</span> <span class="nv">TestClass</span>
  <span class="ss">:main</span> <span class="nv">true</span>
  <span class="ss">:methods</span> <span class="p">[</span><span class="o">^</span><span class="ss">:static</span> <span class="p">[</span><span class="nv">printTimes</span> <span class="p">[</span><span class="nv">String</span> <span class="nv">int</span><span class="p">]</span> <span class="nv">void</span><span class="p">]</span>
            <span class="o">^</span><span class="ss">:static</span> <span class="p">[</span><span class="nv">add</span> <span class="p">[</span><span class="nb">int </span><span class="nv">int</span><span class="p">]</span> <span class="nv">int</span><span class="p">]])</span>

<span class="p">(</span><span class="kd">defn- </span><span class="nv">-printTimes</span>
  <span class="p">[</span><span class="nb">str </span><span class="nv">times</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">_</span> <span class="nv">times</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">println </span><span class="nv">str</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn- </span><span class="nv">-add</span>
  <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">-main</span>
 <span class="p">[]</span>
 <span class="p">(</span><span class="nb">println </span><span class="s">&quot;nothing&quot;</span><span class="p">))</span>
</code></pre></figure><h2 id="annotations">
<span class="hash">#</span>
<a href="#annotations" class="header-link">Annotations</a>
</h2>
<p>Annotations can be created using regular metadata syntax on class-generation forms, such as <code>gen-class</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">gen-class</span>
  <span class="ss">:name</span> <span class="nv">SomeTest</span>
  <span class="c1">; this metadata is equivalent to Java&#39;s</span>
  <span class="c1">; @org.junit.Test</span>
  <span class="ss">:methods</span> <span class="p">[</span><span class="o">^</span><span class="p">{</span><span class="nv">org.junit.Test</span> <span class="nv">true</span><span class="p">}</span> <span class="nv">simpleTest</span> <span class="p">[]</span> <span class="nv">void</span><span class="p">])</span>
</code></pre></figure><h1 id="abbr-titleread-eval-print-loopreplabbr">
<span class="hash">#</span>
<a href="#abbr-titleread-eval-print-loopreplabbr" class="header-link"><abbr title="Read-Eval-Print-Loop">REPL</abbr></a>
</h1>
<p>In the <abbr title="Read-Eval-Print-Loop">REPL</abbr>, <code>*n</code> contains the <code>n</code>th recently evaluated expression&rsquo;s result, i.e. <code>*1</code> refers to the most recent result, <code>*e</code> refers to the last uncaught exception.</p>

<p>The <span class="path">clojure.repl</span> namespace contains various <abbr title="Read-Eval-Print-Loop">REPL</abbr> utilities. The <code>pst</code> function could be used to print the stack trace of the provided exception, or <code>*e</code> if not provided. The <code>apropos</code> function shows which functions in the loaded namespaces matches the provided regular expression or string, whereas <code>find-doc</code> is similar but it searches within the documentation. The <code>source</code> function can output the source code for the provided function. The <code>doc</code> function can print out the documentation for a given var, and <code>dir</code> can print a list of public vars in the given namespace.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">apropos</span> <span class="o">#</span><span class="s">&quot;^ref&quot;</span><span class="p">)</span>
<span class="c1">;= (ref-max-history refer-clojure ref-set</span>
<span class="c1">;=  ref-history-count ref ref-min-history refer)</span>

<span class="p">(</span><span class="nf">dir</span> <span class="nv">clojure.string</span><span class="p">)</span>
<span class="c1">; blank?</span>
<span class="c1">; capitalize</span>
<span class="c1">; escape</span>
<span class="c1">; ...</span>
</code></pre></figure><h1 id="math">
<span class="hash">#</span>
<a href="#math" class="header-link">Math</a>
</h1>
<p>Like Java, Clojure has a mixed numerics model so that it can make use of primitives and boxed numbers, although the only primitives it supports are <code>long</code> and <code>double</code>. In fact, Clojure automatically widens return values of <code>float</code>, <code>int</code>, and <code>short</code> to their 64-bit or larger equivalents.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">class </span><span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">Integer.</span> <span class="mi">5</span><span class="p">)))</span>
<span class="c1">;= java.lang.Long</span>
</code></pre></figure>
<p>When an mathematical operation overflows the bounds of the value type, an exception is thrown instead of silently wrapping around as in other languages. There are <code>unchecked-*</code> variants that don&rsquo;t perform this check. Alternatively, a global configuration value <code>*unchecked-math*</code> can be set to true so that all mathematical operations are unchecked.</p>

<p>There are additional &ldquo;prime&rdquo; autopromoting variants of core mathematical functions which will automatically promote results that would otherwise overflow.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nb">inc </span><span class="nv">Long/MAX_VALUE</span><span class="p">)</span>
<span class="c1">;= ArithmeticException</span>

<span class="p">(</span><span class="nf">inc</span><span class="o">&#39;</span> <span class="nv">Long/MAX_VALUE</span><span class="p">)</span>
<span class="c1">;= 9223372036854775808N</span>
</code></pre></figure>
<p>When comparing numbers, <code>=</code> returns true if the numbers are the same and within the same category, e.g. both are integers. The <code>==</code> function, on the other hand, returns true if the numbers are numerically equivalent, regardless of the categories they&rsquo;re in.</p>
<h1 id="testing">
<span class="hash">#</span>
<a href="#testing" class="header-link">Testing</a>
</h1>
<p>The <span class="path">clojure.test</span> namespace contains the official Clojure test framework. Assertions are possible with the <code>is</code> macro, which takes an expression it evaluates to determine if it is logically true and an optional message which will be printed if the assertion fails.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.test</span><span class="p">)</span>

<span class="p">(</span><span class="nf">is</span>
  <span class="p">(</span><span class="nb">= </span><span class="mi">5</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">4</span> <span class="mi">2</span><span class="p">))</span>
  <span class="s">&quot;Brush up on addition&quot;</span><span class="p">)</span>
<span class="c1">; FAIL in &lt;location&gt;</span>
<span class="c1">; Brush up on addition</span>
<span class="c1">; expected: (= 5 (+ 4 2))</span>
<span class="c1">;   actual: (not (= 5 6))</span>
<span class="c1">;= false</span>
</code></pre></figure>
<p>There are also assertions that can be used within expressions, such as <code>thrown?</code> which ensures that a certain type of exception is thrown during evaluation, or <code>thrown-with-msg?</code> which takes a regular expression to test the contents of the exception message.</p>

<p>The <code>testing</code> macro can be used to nest tests so that each test&rsquo;s description is printed out when certain test fails.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;Strings&quot;</span>
  <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;regex&quot;</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">re-find </span><span class="o">#</span><span class="s">&quot;foo&quot;</span> <span class="s">&quot;foobar&quot;</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">re-find </span><span class="o">#</span><span class="s">&quot;foo&quot;</span> <span class="s">&quot;bar&quot;</span><span class="p">))))</span>

<span class="c1">; FAIL &lt;location&gt;</span>
<span class="c1">; Strings regex</span>
<span class="c1">; ...</span>
</code></pre></figure>
<p>The <code>deftest</code> macro can be used to define tests such that they are marked as tests. This is done by defining a zero-argument function and adding a <code>^:test</code> metadata slot. This allows test runners to easily find tests.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">deftest</span> <span class="nv">test-foo</span>
  <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="ss">:test</span> <span class="p">(</span><span class="nb">meta </span><span class="o">#</span><span class="ss">&#39;test-foo</span><span class="p">))</span>
<span class="c1">;= #&lt;user$fn__366 ...&gt;</span>
</code></pre></figure>
<p>The <code>with-test</code> macro can be used to define a function and its accompanying tests in a single location.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">with-test</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">hello</span> <span class="p">[</span><span class="nv">name</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello, &quot;</span> <span class="nv">name</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">hello</span> <span class="s">&quot;Brian&quot;</span><span class="p">)</span> <span class="s">&quot;Hello, Brian&quot;</span><span class="p">))</span>

<span class="c1">; can be run explicitly</span>
<span class="p">((</span><span class="ss">:test</span> <span class="p">(</span><span class="nb">meta </span><span class="o">#</span><span class="ss">&#39;hello</span><span class="p">)))</span>
<span class="c1">; FAIL in &lt;location&gt;</span>
<span class="c1">; ...</span>
</code></pre></figure>
<p>The <code>run-tests</code> function can dynamically find tests in the specified namespaces by checking for the <code>^:test</code> metadata. If no namespaces are specified, it searches in the current namespace: <code>*ns*</code>.</p>

<p>It&rsquo;s possible to define test suites by simply having one test call another. However, this can cause the test runner to run the same tests multiple times. This can be avoided by simply omitting the <code>^:test</code> metadata for subordinate tests, i.e. not using <code>deftest</code>.</p>

<p>Another way to avoid this is by defining an entry point for tests by creating a function called <code>test-ns-hook</code> in the namespace, which, if found by <code>run-tests</code>, is the only test function run in that namespace, giving complete control over which tests are run and their order.</p>

<p>Fixtures&mdash;which allow set-up and tear-down routines to establish and take down an environment required for a test&mdash;are naturally possible via higher-order functions, where the argument to the fixture is the test to run within the context of the environment the fixture establishes. Fixtures are mutually exclusive with the <code>test-ns-hook</code> entry point for tests, so that if the entry point is defined, fixtures wont be run.</p>

<p>Fixtures are simply functions that take one argument&mdash;the test to run within its environment&mdash;and are registered using the <code>use-fixtures</code> function. It takes as its first argument the kind of life cycle to use:</p>

<ul>
<li><code>:once</code> runs the fixture once and then runs all of the tests within that environment</li>
<li><code>:each</code> re-runs the fixture separately for each test</li>
</ul>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">some-fixture</span>
  <span class="p">[</span><span class="nv">f</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">set-up</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">f</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">tear-down</span><span class="p">))</span>

<span class="p">(</span><span class="nf">use-fixtures</span> <span class="ss">:once</span> <span class="nv">some-fixture</span><span class="p">)</span>
</code></pre></figure>
<p>The <code>are</code> macro can templatize assertions in order to avoid repetition.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">deftest</span> <span class="nv">test-addition</span>
  <span class="p">(</span><span class="nf">are</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">]</span> <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
    <span class="mi">10</span>  <span class="mi">7</span>  <span class="mi">3</span>
    <span class="mi">20</span>  <span class="mi">10</span> <span class="mi">10</span>
    <span class="mi">100</span> <span class="mi">89</span> <span class="mi">11</span><span class="p">))</span>

<span class="c1">; expands to</span>
<span class="p">(</span><span class="nf">do</span>
  <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">10</span>  <span class="p">(</span><span class="nb">+ </span><span class="mi">7</span> <span class="mi">3</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">20</span>  <span class="p">(</span><span class="nb">+ </span><span class="mi">10</span> <span class="mi">10</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">100</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">89</span> <span class="mi">11</span><span class="p">))))</span>
</code></pre></figure>
<p>The <code>assert</code> macro can be used to throw an error if the condition is not met, which is useful in instances where it&rsquo;s preferable to fail as early as possible. Assertions can be disabled globally by setting <code>*assert*</code> to <code>false</code>, which should be set before compilation of code that uses it.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="nf">assert</span>
  <span class="nv">false</span>
  <span class="s">&quot;value should be true&quot;</span><span class="p">)</span>
<span class="c1">;= #&lt;AssertionError ...&gt;</span>
<span class="c1">;=   value should be true</span>
</code></pre></figure>
<p>The <code>fn</code> special form has support for testing preconditions and postconditions, such that an error is thrown if one isn&rsquo;t met. This is done by specifying a map with <code>:pre</code> and/or <code>:post</code> keys as the first value in the function body, which gets expanded to calls to <code>assert</code> when the function is compiled.</p>

<p>The values to the keys are vectors where each item is a separate assertion. Postcondition assertions can refer to the value to-be-returned as <code>%</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">even-to-odd</span>
  <span class="p">[</span><span class="nv">num</span><span class="p">]</span>
  <span class="p">{</span><span class="ss">:pre</span>  <span class="p">[(</span><span class="nb">= </span><span class="p">(</span><span class="nf">mod</span> <span class="nv">num</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">)]</span>
   <span class="ss">:post</span> <span class="p">[(</span><span class="nb">not= </span><span class="p">(</span><span class="nf">mod</span> <span class="nv">%</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">)]}</span>
  <span class="p">(</span><span class="nb">inc </span><span class="nv">num</span><span class="p">))</span>

<span class="p">(</span><span class="nf">even-to-odd</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">; AssertionError</span>
</code></pre></figure>
<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>This is used in Om in the form of <code>#js</code> to parse a map and output JSON in its place, or parse a vector and output an array in its place.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>Similar to Haskell&rsquo;s compose function <code>.</code>&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>Similar to Haskell&rsquo;s cons function <code>:</code>&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

<li id="fn4">
<p>Compared to Haskell&rsquo;s <em>forcing</em>.&nbsp;<a href="#fnref4" rev="footnote">&#8617;</a></p>
</li>

<li id="fn5">
<p>It wouldn&rsquo;t force the value in Haskell because of the concept of <a href="http://www.haskell.org/haskellwiki/Thunk">thunks</a>.&nbsp;<a href="#fnref5" rev="footnote">&#8617;</a></p>
</li>

<li id="fn6">
<p>This strikes me as <em>very</em> similar to Haskell&rsquo;s <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Monad.html#v:sequence"><code>sequence</code></a> and <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Monad.html#v:sequence_"><code>sequence_</code></a>, respectively.&nbsp;<a href="#fnref6" rev="footnote">&#8617;</a></p>
</li>

<li id="fn7">
<p>This function is essentially Haskell&rsquo;s <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html#v:break"><code>break</code></a>&nbsp;<a href="#fnref7" rev="footnote">&#8617;</a></p>
</li>

<li id="fn8">
<p>It seems to me like it would always be preferable to use <code>contains?</code> due to this edge case, but it&rsquo;s good to know that sets can be used in this way.&nbsp;<a href="#fnref8" rev="footnote">&#8617;</a></p>
</li>

<li id="fn9">
<p>Zippers are used in <a href="http://en.wikipedia.org/wiki/Xmonad">Xmonad</a> to track window placement and focus.&nbsp;<a href="#fnref9" rev="footnote">&#8617;</a></p>
</li>

<li id="fn10">
<p>This reminds me of Haskell&rsquo;s <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html"><code>MVar</code></a>&nbsp;<a href="#fnref10" rev="footnote">&#8617;</a></p>
</li>

<li id="fn11">
<p>Reminds me of static variables in C/C++.&nbsp;<a href="#fnref11" rev="footnote">&#8617;</a></p>
</li>

<li id="fn12">
<p><a href="http://stackoverflow.com/questions/21966319/deref-inside-a-transaction-may-trigger-a-retry-what-is-the-role-of-ref-state-h">what is the role of ref state history?</a>&nbsp;<a href="#fnref12" rev="footnote">&#8617;</a></p>
</li>

<li id="fn13">
<p>This seems similar to Objective-C protocols.&nbsp;<a href="#fnref13" rev="footnote">&#8617;</a></p>
</li>

<li id="fn14">
<p>Or more recently, the <a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html"><code>try-with-resources</code></a> statement.&nbsp;<a href="#fnref14" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>
</div>
  <div class="meta">
    <div class="meta-component"><i class="fa fa-calendar fa-fw"></i> April  6, 2014</div>
    <div class="meta-component"><i class="fa fa-code-fork fa-fw"></i> <a href="https://github.com/blaenk/site/commits/master/input/notes/clojure.markdown">History</a><span class="hash">, <a href="https://github.com/blaenk/site/commit/dc6ff87" title="new table marker syntax; no need for metadata

This means there's no need to separate the toc marker from its
configuration, i.e. alignment. This never should've been necessary.

This has the nice side-effect of naturally invalidating the cache when
the toc marker is moved around or its alignment is changed.
">dc6ff87</a></span></div>
    <div class="meta-component"><i class="fa fa-tags fa-fw"></i> null</div>
  </div>
</article>



    
    <footer id="footer">
  <div id="social">
    <a href="https://github.com/blaenk" title="github"><i class="fa fa-github-alt"></i></a>
    &middot;
    <a href="http://stackoverflow.com/users/101090/jorge-israel-pena" title="stackoverflow"><i class="fa fa-stack-overflow"></i></a>
    &middot;
    <a href="https://twitter.com/blaenk" title="twitter"><i class="fa fa-twitter"></i></a>
    &middot;
    <a href="mailto:jorge.israel.p@gmail.com" title="email"><i class="fa fa-envelope"></i></a>
    &middot;
    <a href="/rss.xml" title="feed"><i class="fa fa-rss-square"></i></a>
  </div>
  <!-- <div id="credit">
    Designed by <a href="http://www.blaenkdenum.com">Jorge Israel Peña</a>
  </div> -->
</footer>


<!-- this should instead be something like connectWS("{{{path}}}") -->


<script type="text/javascript">
  jQuery(function (){
    var ws = new WebSocket('ws://' + window.location.hostname + ':9160/notes/clojure.markdown');

    ws.onmessage = function (e) {
      var content = jQuery('article .entry-content');
      content.html(e.data);

      window.refresh();

      MathJax.Hub.Queue(["Typeset", MathJax.Hub, content[0]]);
    };
  });
</script>




<!-- google analytics -->
<script async="true" type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37339861-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

<!--MathJax CDN-->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    messageStyle: "none"
  });

  MathJax.Hub.Register.MessageHook('End Process', function() {
    jQuery('#MathJax_Font_Test').empty();
    jQuery('.MathJax_Display').parent('.math').addClass('mobile-math');
  });
</script>
<script async="true" type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>

  </div>
</body>
</html>
