<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Rust - Blaenk Denum</title>
  <meta name="author" content="Jorge Israel Peña">
  <meta name="description" content="AKA Blaenk Denum">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="/favicon.png" rel="shortcut icon">
  <link href='http://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Merriweather:900italic,900,700italic,400italic,700,400,300italic,300' rel='stylesheet' type='text/css'>
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='/css/screen.css' rel='stylesheet' type='text/css' media='screen' />
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src='/js/blaenk.js' type='text/javascript'></script>
</head>
<body>
  <div class="page-wrapper">
    <header id="header">
  <div id="stamp">
    <h1 id="name">
      <a href="/">
        <span class="emboldened">Jorge</span>.Israel.<span class="emboldened">Peña</span>
      </a>
    </h1>
    <h4 id="pseudonym">
      AKA <span class="emboldened">Blaenk</span>.Denum
    </h4>
  </div>
  <nav id="main-nav">
    <ul class="main">
      <li><a href="/about/">About</a></li>
      <li><a href="/notes/">Notes</a></li>
      <li><a href="/work/">Work</a></li>
      <li><a href="/lately/">Lately</a></li>
      <li><a id="search_btn">Search</a></li>
    </ul>
  </nav>
  <nav id="mobile-nav">
    <div class="menu">
      <a class="button">Menu</a>
      <div class="container">
        <ul class="main">
          <li><a href="/about/">About</a></li>
          <li><a href="/notes/">Notes</a></li>
          <li><a href="/work/">Work</a></li>
          <li><a href="/lately/">Lately</a></li>
        </ul>
      </div>
    </div>
    <div class="search">
      <a class="button"></a>
      <div class="container">
        <form action="http://google.com/search" method="get">
          <input type="text" name="q" results="0">
          <input type="hidden" name="q" value="site:blaenkdenum.com">
        </form>
      </div>
    </div>
  </nav>
</header>
<form class="desk_search" action="http://google.com/search" method="get">
  <input id="search" type="text" name="q" results="0" placeholder="Search" autocomplete="off" spellcheck="false">
  <input type="hidden" name="q" value="site:blaenkdenum.com">
</form>

    
        <article class="post">
  <h2 class="title"><a href="/notes/rust"><span>Rust</span></a></h2>
  <div class="entry-content"><p>I took a shot at <a href="/notes/go/">learning Go</a> recently and I found its simplicity to be refreshing. Rust is a similar language from Mozilla which I&rsquo;ve been interested in for a while now.</p>

<p>My main resources are the <a href="http://doc.rust-lang.org/tutorial.html">tutorial</a> and <a href="http://doc.rust-lang.org/rust.html">manual</a>, but there are <a href="http://doc.rust-lang.org/">many more</a>. As usual, oftentimes some things will be directly from the source, with my commentary surrounding it. There is also a more basic <a href="http://rustbyexample.com/">Rust by Example</a> which is similar to the go tour.</p>

<nav id="toc">
<h3>Contents</h3><ol>
<li>
<a href="#types">Types</a>
</li>
<li>
<a href="#variables">Variables</a>
</li>
<li>
<a href="#modules">Modules</a>
</li>
<li>
<a href="#ownership">Ownership</a>
<ol>
<li>
<a href="#boxes">Boxes</a>
</li>
<li>
<a href="#managed-boxes">Managed Boxes</a>
</li>
<li>
<a href="#cells">Cells</a>
</li>
<li>
<a href="#moving">Moving</a>
</li>
<li>
<a href="#borrowing">Borrowing</a>
</li>
<li>
<a href="#references">References</a>
</li>
<li>
<a href="#lifetimes">Lifetimes</a>
<ol>
<li>
<a href="#elision">Elision</a>
</li>
</ol>
</li>
<li>
<a href="#dropping">Dropping</a>
</li>
</ol>
</li>
<li>
<a href="#collections">Collections</a>
<ol>
<li>
<a href="#arrays">Arrays</a>
</li>
<li>
<a href="#slices">Slices</a>
</li>
<li>
<a href="#vectors">Vectors</a>
</li>
<li>
<a href="#strings">Strings</a>
</li>
</ol>
</li>
<li>
<a href="#pattern-matching">Pattern Matching</a>
</li>
<li>
<a href="#control-structures">Control Structures</a>
</li>
<li>
<a href="#structures">Structures</a>
</li>
<li>
<a href="#enumerations">Enumerations</a>
</li>
<li>
<a href="#tuples">Tuples</a>
</li>
<li>
<a href="#functions">Functions</a>
</li>
<li>
<a href="#methods">Methods</a>
<ol>
<li>
<a href="#universal-function-call-syntax">Universal Function Call Syntax</a>
</li>
</ol>
</li>
<li>
<a href="#closures">Closures</a>
<ol>
<li>
<a href="#unboxed-closures">Unboxed Closures</a>
</li>
</ol>
</li>
<li>
<a href="#generics">Generics</a>
<ol>
<li>
<a href="#where-clauses">Where Clauses</a>
</li>
</ol>
</li>
<li>
<a href="#traits">Traits</a>
<ol>
<li>
<a href="#associated-items">Associated Items</a>
<ol>
<li>
<a href="#associated-types">Associated Types</a>
</li>
<li>
<a href="#associated-statics">Associated Statics</a>
</li>
</ol>
</li>
<li>
<a href="#drop">Drop</a>
</li>
<li>
<a href="#clone">Clone</a>
</li>
<li>
<a href="#operator-overloading">Operator Overloading</a>
</li>
</ol>
</li>
<li>
<a href="#dynamically-sized-types">Dynamically Sized Types</a>
</li>
<li>
<a href="#tasks">Tasks</a>
<ol>
<li>
<a href="#spawning">Spawning</a>
</li>
<li>
<a href="#channels">Channels</a>
</li>
<li>
<a href="#futures">Futures</a>
</li>
<li>
<a href="#arc">Arc</a>
</li>
<li>
<a href="#failure">Failure</a>
</li>
</ol>
</li>
<li>
<a href="#errors">Errors</a>
</li>
<li>
<a href="#iterators">Iterators</a>
</li>
<li>
<a href="#macros">Macros</a>
<ol>
<li>
<a href="#syntax-extensions">Syntax Extensions</a>
</li>
</ol>
</li>
<li>
<a href="#foreign-function-interface">Foreign Function Interface</a>
</li>
<li>
<a href="#unsafe">Unsafe</a>
</li>
<li>
<a href="#comments">Comments</a>
</li>
<li>
<a href="#testing">Testing</a>
</li>
<li>
<a href="#cargo">Cargo</a>
</li>
<li>
<a href="#printing">Printing</a>
</li>
<li>
<a href="#input">Input</a>
</li>
<li>
<a href="#documentation">Documentation</a>
</li>
<li>
<a href="#debugging">Debugging</a>
</li>
</ol>
</nav>
<h1 id="types">
<span class="hash">#</span>
<a href="#types" class="header-link">Types</a>
</h1>
<p>There are no implicit type conversions. Instead, the <code>as</code> keyword is used to perform explicit type conversions. The <code>type</code> keyword can be used to create type aliases.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Category</th>
<th style="text-align: left">Types</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">signed integers</td>
<td style="text-align: left"><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>int</code> (word size)</td>
</tr>
<tr>
<td style="text-align: left">unsigned integers</td>
<td style="text-align: left"><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>uint</code> (word size)</td>
</tr>
<tr>
<td style="text-align: left">floating point</td>
<td style="text-align: left"><code>f32</code>, <code>f64</code></td>
</tr>
<tr>
<td style="text-align: left">Unicode scalars</td>
<td style="text-align: left"><code>char</code></td>
</tr>
<tr>
<td style="text-align: left">booleans</td>
<td style="text-align: left"><code>bool</code></td>
</tr>
</tbody>
</table>

<p>The <code>Box&lt;T&gt;</code> type represents a boxed value allocated on the heap. The <code>Vec&lt;T&gt;</code> type represents a growable vector. The <code>String</code> type represents a growable UTF-8 encoded buffer.</p>

<p>Nearly every statement in Rust is an expression that yields a value, but this can be suppressed by adding a trailing semicolon <code>;</code>, which makes the result be unit <code>()</code>.</p>

<p>The <code>Result&lt;T, E&gt;</code> type is similar to Haskell&rsquo;s <code>Either</code>, containing either <code>Ok</code> or <code>Err</code>. The <code>try!</code> macro makes it easier to work with <code>Result</code>, expanding to a <code>match</code> expression that returns the contained error or evaluates to the. This reminds me of the <code>Either</code> monad.</p>

<p>Types are categorized into <em>kinds</em> based on various properties of the components of the type.</p>

<ul>
<li><code>Send</code> is for types that can be safely sent between tasks. Includes scalars, owning pointers, owned closures, and structural types containing only other owned types. All <code>Send</code> types are <code>&#39;static</code></li>
<li><code>Share</code> for types that are thread-safe</li>
<li><code>Copy</code> is for types that consist of Plain Old Data. Includes scalars, immutable references, and structural types containing other <code>Copy</code> types</li>
<li><code>&#39;static</code> is for types that don&rsquo;t contain any references except those with <code>static</code> lifetime</li>
<li><code>Drop</code> is for types that need to be cleaned up by a destructor. Only <code>Send</code> types can implement <code>Drop</code></li>
<li>Default is for types with destructors, closure environments, or other non-first-class types which aren&rsquo;t copyable at all and are only accessible through pointers</li>
</ul>
<h1 id="variables">
<span class="hash">#</span>
<a href="#variables" class="header-link">Variables</a>
</h1>
<p>Variables are immutable by default and are defined using the <code>let</code> keyword, though one can be made mutable by providing the <code>mut</code> keyword after <code>let</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// immutable</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="c1">// mutable</span>
</code></pre></figure>
<p>Constants represent a value, not a memory address, and can be declared using the <code>const</code> keyword. Constants can be declared in any scope, can&rsquo;t be shadowed, and are considered rvalues. Constants are essentially inlined wherever they are used, like <code>#define</code> constants in C.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kr">const</span><span class="w"> </span><span class="n">age</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p>Global variables represent a memory address and can be declared using the <code>static</code> keyword. Static variables can be created using the <code>static</code> keyword and always have a single address. If the static doesn&rsquo;t contain an <code>UnsafeCell</code> then it may be placed in read-only memory.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">static</span><span class="w"> </span><span class="n">LANGUAGE</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Rust&quot;</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="n">THRESHOLD</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p>It&rsquo;s also possible to define mutable statics, though using these is considered unsafe as it can introduce race conditions. Because of this, mutable static can only be read or written to within <code>unsafe</code> blocks, and can&rsquo;t be placed in read-only memory.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">static</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">LEVELS</span><span class="o">:</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">bump_levels_unsafe1</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LEVELS</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">LEVELS</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h1 id="modules">
<span class="hash">#</span>
<a href="#modules" class="header-link">Modules</a>
</h1>
<p>The content of all source code that the compiler directly had to compile in order to end up with a particular binary is collectively called a <em>crate</em>. A crate is a unit of independent compilation in Rust. Using an already compiled library in code doesn&rsquo;t make it part of a crate.</p>

<p>There exists a hierarchy of modules where the root is referred to as <em>crate root</em>. Global paths begin with the root path <code>::</code>, all other paths are local paths, similar to the distinction between absolute <code>/</code>-prefixed paths and relative paths in a POSIX file system.</p>

<p>Everything in Rust is private by default with a single exception. If an enumeration is declared public, then its variants are public as well by default, though this may be overridden with the <code>priv</code> keyword.</p>

<p>Visibility restrictions are only applicable at module boundaries, so that private items are available within the same module and its descendants. Descendants still have to bring the parent items into view using <code>use</code>, however&mdash;this simply means that they have permission view private items.</p>

<p>Source files and modules are not the same thing. The only file that&rsquo;s relevant when compiling is the one that contains the body of the crate root. Declaring a module without a body prompts the compiler to look for a file named after that module or for a file named <code>mod.rs</code> in a folder named after that module, and use its contents as the module&rsquo;s body.</p>

<p>The <code>path</code> attribute may be used to manually specify a module&rsquo;s path.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[path = </span><span class="s">&quot;manual.rs&quot;</span><span class="cp">]</span><span class="w"></span>
<span class="kn">mod</span><span class="w"> </span><span class="n">aliased</span><span class="p">;</span><span class="w"></span>

<span class="kn">mod</span><span class="w"> </span><span class="n">plants</span><span class="p">;</span><span class="w"></span>
<span class="kn">mod</span><span class="w"> </span><span class="n">animals</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kn">mod</span><span class="w"> </span><span class="n">fish</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kn">mod</span><span class="w"> </span><span class="n">mammals</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kn">mod</span><span class="w"> </span><span class="n">humans</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// looks for:</span>

<span class="c1">// src/manual.rs</span>

<span class="c1">// src/plants.rs</span>
<span class="c1">// src/plants/mod.rs</span>

<span class="c1">// src/animals/fish.rs</span>
<span class="c1">// src/animals/fish/mod.rs</span>

<span class="c1">// src/animals/mammals/humans.rs</span>
<span class="c1">// src/animals/mammals/humans/mod.rs</span>
</code></pre></figure>
<p>The <code>use</code> statement can be used to bring in a module&rsquo;s contents into the current block by providing a global path without the <code>::</code> prefix. It&rsquo;s possible to prefix with <code>super::</code> to start the path in the parent module, and <code>self::</code> to start the path in the current module.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kn">use</span><span class="w"> </span><span class="n">super</span><span class="o">::</span><span class="n">some_parent_item</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="bp">self</span><span class="o">::</span><span class="n">some_child_module</span><span class="o">::</span><span class="n">some_item</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p>Imported items are shadowed by local definitions. To make this fact more explicit, <code>use</code> statements must go before any declaration, including <code>mod</code> declarations. This looks awkward when importing items from a module that follows:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kn">use</span><span class="w"> </span><span class="n">farm</span><span class="o">::</span><span class="n">cow</span><span class="p">;</span><span class="w"></span>

<span class="kn">mod</span><span class="w"> </span><span class="n">farm</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">cow</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;moo&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cow</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>This is even more awkward when using a <code>mod</code> statement that looks in a separate file for the contents:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kn">use</span><span class="w"> </span><span class="n">b</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span><span class="w"></span>
<span class="kn">mod</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>These restrictions have been removed by <a href="https://github.com/rust-lang/rfcs/blob/master/text/0385-module-system-cleanup.md"><abbr title="Request for Comments">RFC</abbr> #385</a>, so that it&rsquo;s now possible to use any order:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kn">mod</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">b</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p>It&rsquo;s possible to import by wildcard or selectively, similar to Scala. It&rsquo;s also possible to rename an imported item:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kn">use</span><span class="w"> </span><span class="n">farm</span><span class="o">::</span><span class="p">{</span><span class="n">chicken</span><span class="p">,</span><span class="w"> </span><span class="n">cow</span><span class="p">};</span><span class="w"></span>

<span class="cp">#[feature(globs)]</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">farm</span><span class="o">::*</span><span class="p">;</span><span class="w"></span>

<span class="kn">use</span><span class="w"> </span><span class="n">farm</span><span class="o">::</span><span class="n">chicken</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">egg_layer</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p>It&rsquo;s possible to make a module available through another module by using <code>pub mod</code>. This allows the exposed module&rsquo;s public items to be accessible using path-notation.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="c1">// secondmod.rs</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">hi</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="c1">// firstmod.rs</span>
<span class="k">pub</span><span class="w"> </span><span class="kn">mod</span><span class="w"> </span><span class="n">secondmod</span><span class="p">;</span><span class="w"></span>

<span class="c1">// main.rs</span>
<span class="n">firstmod</span><span class="o">::</span><span class="n">secondmod</span><span class="o">::</span><span class="n">hi</span><span class="p">();</span><span class="w"></span>
</code></pre></figure>
<p>Likewise, it&rsquo;s possible to re-export specific items to make them appear to be part of the module in which they&rsquo;re exposed, using <code>pub use</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="c1">// firstmod.rs</span>
<span class="k">pub</span><span class="w"> </span><span class="kn">use</span><span class="w"> </span><span class="n">secondmod</span><span class="o">::</span><span class="n">hi</span><span class="p">;</span><span class="w"></span>
<span class="kn">mod</span><span class="w"> </span><span class="n">secondmod</span><span class="p">;</span><span class="w"></span>

<span class="c1">// main.rs</span>
<span class="n">firstmod</span><span class="o">::</span><span class="n">hi</span><span class="p">();</span><span class="w"></span>
</code></pre></figure>
<p>It&rsquo;s common to use existing libraries, which in rust are simply referred to as crates. The <code>extern crate</code> declaration is used to reference other crates, similar to <code>extern</code> in C.</p>

<p>Items imported via <code>extern crate</code> can be shadowed by local declarations and by items imported by <code>use</code>, so they must go before both. Crates declared in an <code>extern crate</code> declaration are looked for in the library search path, which can be expanded with the <code>-L</code> switch.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w"></span>

<span class="kn">use</span><span class="w"> </span><span class="n">farm</span><span class="o">::</span><span class="n">dog</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">num</span><span class="o">::</span><span class="n">rational</span><span class="o">::</span><span class="n">Ratio</span><span class="p">;</span><span class="w"></span>

<span class="kn">mod</span><span class="w"> </span><span class="n">farm</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">dog</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;woof&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">farm</span><span class="o">::</span><span class="n">dog</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">one_half</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">::</span><span class="n">num</span><span class="o">::</span><span class="n">rational</span><span class="o">::</span><span class="n">Ratio</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Crates can contain metadata used for the resultant libraries:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#![crate_name = </span><span class="s">&quot;farm&quot;</span><span class="cp">];</span><span class="w"></span>

<span class="cp">#![desc = </span><span class="s">&quot;Farm&quot;</span><span class="cp">]</span><span class="w"></span>
<span class="cp">#![license = </span><span class="s">&quot;BSD&quot;</span><span class="cp">]</span><span class="w"></span>
<span class="cp">#![comment = </span><span class="s">&quot;Farm library&quot;</span><span class="cp">]</span><span class="w"></span>

<span class="c1">// specify that it&#39;s a library</span>
<span class="cp">#![crate_type = </span><span class="s">&quot;lib&quot;</span><span class="cp">];</span><span class="w"></span>
</code></pre></figure>
<p>This information can be used to select the crate from the <code>extern crate</code> declaration:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">farm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;farm&quot;</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p>For example, here&rsquo;s an example library, its compilation, and usage:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[crate_name = </span><span class="s">&quot;world&quot;</span><span class="cp">];</span><span class="w"></span>
<span class="cp">#[crate_type = </span><span class="s">&quot;lib&quot;</span><span class="cp">];</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">explore</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></figure><figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">world</span><span class="p">;</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;hello {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">world</span><span class="o">::</span><span class="n">explore</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><figure class="codeblock">
<pre>
<code class="highlight language-bash"><span class="nv">$ </span>rustc world.rs     <span class="c"># compiles libworld-&lt;HASH&gt;-0.42.so</span>
<span class="nv">$ </span>rustc main.rs -L . <span class="c"># include local dir in library search path</span>
<span class="nv">$ </span>./main
<span class="s2">&quot;hello world&quot;</span>
</code></pre></figure>
<p>Many predefined items such as <code>range</code> and <code>Option&lt;T&gt;</code> come from the standard library&rsquo;s prelude, similar to Haskell&rsquo;s. The rust compiler automatically inserts the following into the crate root:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">std</span><span class="p">;</span><span class="w"></span>

<span class="c1">// to prevent: in crate root</span>
<span class="cp">#[no_std];</span><span class="w"></span>
</code></pre></figure>
<p>As well as the following into every module body:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">prelude</span><span class="o">::*</span><span class="p">;</span><span class="w"></span>

<span class="c1">// to prevent: in any module</span>
<span class="cp">#[no_implicit_prelude];</span><span class="w"></span>
</code></pre></figure>
<p>Attributes can be used to specify conditional compilation of code, crate names, disabling or enabling compiler features, and so on. The <code>cfg</code> attribute can test for configuration values passed by the rust compiler either implicitly or explicitly with the <code>--cfg</code> flag.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="c1">// crate-wide attribute</span>
<span class="cp">#![crate_attribute]</span><span class="w"></span>

<span class="c1">// module-wide attribute</span>
<span class="cp">#[module_attribute]</span><span class="w"></span>

<span class="cp">#[cfg(target_os = </span><span class="s">&quot;linux&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">on_linux</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;on linux&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[cfg(not(target_os = </span><span class="s">&quot;linux&quot;</span><span class="cp">))]</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">not_on_linux</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;not on linux&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h1 id="ownership">
<span class="hash">#</span>
<a href="#ownership" class="header-link">Ownership</a>
</h1>
<p>An object&rsquo;s lifetime is determined by its owner, either a variable or a task-local garbage collector. Ownership is recursive so that mutability is inherited recursively and a destructor destroys the contained tree of owned objects. Variables are owners and destroy the contained object when they go out of scope.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">struct</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// `a` is owner of struct and its fields</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// `a` goes out of scope, destructor for y&#39;s `box int` is called</span>

<span class="c1">// `b` is mutable, so the objects it owns are also mutable</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
</code></pre></figure>
<p>Notice that a structure may contain a mutable reference, so that even if the structure is immutable, the pointed-to value can be mutated. Naturally, the reference itself can&rsquo;t be changed since the structure is immutable.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">struct</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">S2</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">S1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="mi">56</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="n">s2</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">45</span><span class="p">;</span><span class="w">    </span><span class="c1">// legal</span>
<span class="n">s2</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"> </span><span class="c1">// illegal</span>
</code></pre></figure><h2 id="boxes">
<span class="hash">#</span>
<a href="#boxes" class="header-link">Boxes</a>
</h2>
<p>Values are allocated on the stack by default, but they can also be <em>boxed</em>, i.e. allocated on the heap. Values are boxed with the <code>box</code> keyword and result in a value of type <code>Box&lt;T&gt;</code>. Box values can be dereferenced using the <code>*</code> operator, or they can be destructured by using the <code>box</code> keyword on the <abbr title="Left-Hand Side">LHS</abbr>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">enum</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Cons</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">Nil</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="n">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="n">Nil</span><span class="p">)));</span><span class="w"></span>
</code></pre></figure>
<p>The <code>list</code> represents an owned tree of values.</p>

<p>It&rsquo;s not necessary to worry about manually boxing large return values or arguments, they are essentially passed by reference if they are larger than the size of the machine&rsquo;s register. To quote the tutorial:</p>

<blockquote>
<p>A large value is returned via a hidden output parameter, and the decision on where to place the return value should be left to the caller</p>
</blockquote>

<p>What this essentially means is that if for example function <code>foo()</code> returns <code>BigStruct</code>, the compiler will pass <code>foo()</code> a pointer to an uninitialized <code>BigStruct</code> in the local scope, something like:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">BigStruct</span><span class="p">;</span><span class="w"> </span><span class="c1">// uninitialized</span>
<span class="n">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// as if type: foo(_ret: &amp;mut BigStruct)</span>
</code></pre></figure>
<p>This allows the caller to decide where to place the return value, for example:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// allocates result in a box and writes u64&#39;s directly to it</span>
<span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
</code></pre></figure><h2 id="managed-boxes">
<span class="hash">#</span>
<a href="#managed-boxes" class="header-link">Managed Boxes</a>
</h2>
<p>There are other ownership strategies that can be employed, such as task-local garbage collected and reference counted. Reference counted ownership <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> is possible through <code>std::rc::Rc</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">rc</span><span class="o">::</span><span class="n">Rc</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span><span class="o">::</span><span class="n">new</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"> </span><span class="c1">// a new owner</span>
<span class="kd">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// moves x into z</span>

<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">z</span><span class="p">.</span><span class="n">borrow</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span><span class="o">::</span><span class="n">new</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]);</span><span class="w"></span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"> </span><span class="c1">// variable is mutable, not its contents</span>
</code></pre></figure><h2 id="cells">
<span class="hash">#</span>
<a href="#cells" class="header-link">Cells</a>
</h2>
<p>Mutability can&rsquo;t be inherited when shared ownership is involved, since the contained values may be multiply-aliased, so boxes are always immutable and the contained values can only be borrowed as shared references, not mutable references.</p>

<p>However, dynamic mutability is possible via types like <code>Cell</code> and <code>RefCell</code> where freezing is handled via dynamic checks which can fail at run-time. Specifically, <code>Cell</code> is for types that implement <code>Copy</code>, and <code>RefCell</code> is for all others.</p>

<p><code>Rc</code> and <code>Gc</code> types are not sendable, so they can&rsquo;t be used to share memory between tasks. This is instead possible via the <code>extra::arc</code> module.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">shared_map</span><span class="o">:</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">RefCell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">HashMap</span><span class="o">::</span><span class="n">new</span><span class="p">()));</span><span class="w"></span>
<span class="n">shared_map</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;africa&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">92388</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="n">shared_map</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;kyoto&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">11837</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="n">shared_map</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;piccadilly&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">11826</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
</code></pre></figure>
<p>A <code>Cell</code> may also be used to hide mutability for operations that appear to be immutable. A good example of this is <code>Rc</code> whose <code>clone()</code> method must increment the reference count, but <code>clone</code> is not expected to change the source value, which is <a href="http://doc.rust-lang.org/std/clone/trait.Clone.html">why it takes</a> <code>&amp;self</code> and not <code>&amp;mut self</code>. This can be reconciled by storing the reference count in a <code>Cell</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">struct</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptr</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">RcBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">RcBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">refcount</span><span class="o">:</span><span class="w"> </span><span class="n">Cell</span><span class="o">&lt;</span><span class="kt">uint</span><span class="o">&gt;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="p">).</span><span class="n">refcount</span><span class="p">.</span><span class="n">set</span><span class="p">((</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="p">).</span><span class="n">refcount</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">Rc</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptr</span><span class="o">:</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h2 id="moving">
<span class="hash">#</span>
<a href="#moving" class="header-link">Moving</a>
</h2>
<p>Moving in Rust is similar to <a href="/notes/cpp#move-semantics">C++11 move semantics</a>, where the &ldquo;move&rdquo; refers to moving ownership. Rust performs a shallow copy for parameter passing, assignment, and returning from functions. Performing such a shallow copy is treated by Rust as &ldquo;moving ownership&quot; of the value, so that the original source location can no longer be used unless it is reinitialized. A move can be avoided by cloning:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nil</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xs</span><span class="p">;</span><span class="w"></span>

<span class="c1">// error if attempt to use `xs`</span>

<span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nil</span><span class="p">;</span><span class="w"> </span><span class="c1">// xs can be used again</span>

<span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"> </span><span class="c1">// y is a newly allocated box</span>
<span class="kd">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// no new memory alloc&#39;d, x can no longer be used</span>
</code></pre></figure>
<p>Mutability can be changed by moving it to a new owner:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">13</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="c1">// box becomes mutable</span>
<span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="c1">// box becomes immutable</span>
</code></pre></figure><h2 id="borrowing">
<span class="hash">#</span>
<a href="#borrowing" class="header-link">Borrowing</a>
</h2>
<p>References don&rsquo;t imply ownership, they&rsquo;re &ldquo;borrowed.&ldquo; Reference parameters are often used to allow functions to work with all manner of different allocated types.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">distance</span><span class="p">(</span><span class="n">p1</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>This can be used on stack-allocated variables by using the address-of operator <code>&amp;</code> to borrow the local variable, to create an alias for it, i.e. another route to the same data. Managed and owned boxes, on the other hand, are automatically converted to references, in which case the &ldquo;borrowed&quot; metaphor is more like &ldquo;lent out&rdquo;.</p>

<p>If the contents of a variable are lent out then the variable can&rsquo;t be sent to another task. Also, no actions can be taken that may cause the borrowed value to be freed or to change its type. It&rsquo;s necessary to wait for the borrowed value to be returned, i.e. reference to go out of scope, before making full use of it again.</p>

<p>Furthermore, the act of lending immutable pointers to variables freezes the objects they point to and prevents their mutation until the reference is destroyed (i.e. out of scope):</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// x is frozen</span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// x is unfrozen</span>
</code></pre></figure>
<p>Pointers and boxes are uniformly dereferenced with <code>*</code>. The pointer <code>borrowed</code> can be read as taking the reference of the mutable <code>value</code>, that is, the <code>mut</code> is part of the name. Note that the precedence levels of <code>*</code> and <code>.</code> are similar to those in C/C++, making for the awkward parenthesized dereferencing syntax. Unlike C/C++, there is no <code>-&gt;</code> shortcut. Instead, there is automatic pointer dereferencing through <code>*</code> and <code>[]</code>, which applies to any number of levels of indirection:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">owned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">borrowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>

<span class="o">*</span><span class="n">owned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">borrowed</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"></span>
<span class="o">*</span><span class="n">borrowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mf">10.0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mf">20.0</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:f}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
</code></pre></figure><h2 id="references">
<span class="hash">#</span>
<a href="#references" class="header-link">References</a>
</h2>
<p>The <code>&amp;</code> symbol has multiple context-dependent meanings in Rust, as in C++ <sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>. Remembering that expressions are for constructing and patterns for destructuring, a <code>&amp;</code> in a pattern <em>dereferences</em> the expression being destructured. This can be useful to avoid having to manually dereference the variable within the body using <code>*</code>.</p>

<p>For example, the <code>fold</code> function takes a folding operation in the form of a closure that is passed the accumulator and a reference <code>&amp;T</code> to the current element, which means that within the body it would have to be manually dereferenced with <code>*</code>, and we can avoid that by specifying the <code>&amp;</code> in the pattern.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">manual</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
</code></pre></figure>
<p>It&rsquo;s also necessary when attempting to match on borrowed values. In this case, it reads as <em>dereference the variable then see if it matches the pattern</em>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">&amp;</span><span class="nb">Some</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>A <code>&amp;</code> in a function signature means that the parameter accepts a reference. Owned pointers <code>box</code> and types that implement the <code>Deref</code> trait are automatically converted to references when passed to such functions. Variables on the stack, on the other hand, can yield a reference manually using <code>&amp;</code>, which is the address-of operator in that context.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">eq</span><span class="p">(</span><span class="n">xs</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">ys</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">34</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">34</span><span class="p">;</span><span class="w"></span>
<span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ys</span><span class="p">));</span><span class="w"></span>
</code></pre></figure>
<p>A <code>&amp;</code> that&rsquo;s applied to an rvalue is a shorthand for creating a temporary and taking its address.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">explicit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mf">4.0</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">reference_taking_func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">explicit</span><span class="p">);</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">shorthand</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mf">4.0</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">reference_taking_func</span><span class="p">(</span><span class="n">shorthand</span><span class="p">);</span><span class="w"></span>
</code></pre></figure>
<p>A mutable reference <code>&amp;mut</code> is one through which the pointed-to variable can be modified, provided the pointed-to variable is also mutable. When a mutable reference exists to an object, no other reference can exist to the same object, regardless of whether it&rsquo;s mutable or not. Compare this with a regular, immutable reference of which many can exist to the same variable, since the variable cannot be modified through it.</p>

<p>There is also the <code>ref</code> keyword that can be used in a pattern. In this context, it is similar to C++&rsquo;s ref-qualifier, which means bind by reference. This is required when matching on something that can&rsquo;t or we don&rsquo;t want to be taken by value. It can be used with <code>box</code> and <code>mut</code> as well.</p>

<p>For example, we want to get a reference to the <code>Foo</code> in <code>&amp;Option&lt;Foo&gt;</code>. Taking it by value would require moving ownership, but since the <code>Option</code> is borrowed we don&rsquo;t have ownership to begin with. Instead we bind the <code>foo</code> by reference which does away with the need to take ownership.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">borrowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">some</span><span class="p">;</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">borrowed</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">&amp;</span><span class="nb">Some</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">foo</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="p">(</span><span class="k">box</span><span class="w"> </span><span class="mi">5</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="n">u</span><span class="p">);</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">box</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tuple</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Another example is the <code>Option</code> type&rsquo;s <a href="http://doc.rust-lang.org/core/option/enum.Option.html#method.as_mut"><code>as_mut</code></a> method which converts an <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;mut T&gt;</code>. It essentially provides a mutable reference to the contained value to facilitate its mutation.</p>

<p>In order to avoid moving the reference out of the <code>Option</code> and thereby invalidating it later on, it&rsquo;s necessary to bind it by reference with <code>ref</code>.</p>

<p>However, this would yield a <code>&amp; &amp;mut uint</code>, and since it&rsquo;s not a mutable reference it would prevent us from mutating the value, otherwise it would essentially break the rule of not allowing more than one mutable reference to any one thing.</p>

<p>For this reason, it&rsquo;s necessary to bind it by mutable reference with <code>ref mut</code>, yielding a <code>&amp;mut &amp;mut uint</code>, allowing us to mutate the value by doing <code>**v = 1;</code>. To avoid having to dereference twice, we would include the dereference operator <code>&amp;</code> in the pattern position, to finally arrive at <code>&amp;ref mut v</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">2</span><span class="n">u</span><span class="p">);</span><span class="w"></span>
<span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">as_mut</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">ref</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{},</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">42</span><span class="n">u</span><span class="p">));</span><span class="w"></span>
</code></pre></figure>
<p>There&rsquo;s also a language inconsistency where <code>&quot;str&quot;</code> is of type <code>&amp;str</code>, but to get a type of <code>&amp;&amp;str</code> it doesn&rsquo;t suffice to simply do <code>&amp;&quot;str&quot;</code>, because that <em>too</em> is treated as <code>&amp;str</code>, so <em>two</em> are needed: <code>&amp;&amp;str</code>.</p>

<p>In the following example, <code>contains_key</code> takes a value of type <code>&amp;K</code> where <code>K</code> is the key type. The key type is <code>&amp;str</code>, so <code>&amp;K</code> is <code>&amp;&amp;str</code>. Because of the language inconsistency noted above, two <code>&amp;</code>&rsquo;s must prefix the string literal in order to yield a <code>&amp;&amp;str</code> to pass to <code>contains_key</code>. Alternatively, a single <code>&amp;</code> can be used if the string literal is surrounded in parentheses.</p>

<p>Issue <a href="https://github.com/rust-lang/rust/issues/10105">#10105</a> is a proposal to fix this. I&rsquo;ve also read that <a href="https://github.com/rust-lang/rust/issues/6308"><abbr title="Dynamically Sized Types">DST</abbr></a> will fix this as a consequence of its implementation.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kn">use</span><span class="w"> </span><span class="n">collections</span><span class="o">::</span><span class="n">Hashmap</span><span class="p">;</span><span class="w"></span>

<span class="c1">// type inferred as HashMap&lt;&amp;str, &amp;str&gt;</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span><span class="o">::</span><span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="n">items</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;key1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;value1&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">items</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;key2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;value2&quot;</span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">items</span><span class="p">.</span><span class="n">contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="o">&amp;</span><span class="s">&quot;key1&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;not present&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// or</span>
<span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">items</span><span class="p">.</span><span class="n">contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="s">&quot;key1&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;not present&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h2 id="lifetimes">
<span class="hash">#</span>
<a href="#lifetimes" class="header-link">Lifetimes</a>
</h2>
<p>Objects have lifetimes which aid the borrow checker in enforcing valid borrowing. The compiler automatically sets the lifetimes. In the following example, the compiler may give <code>integer</code> lifetime <code>&#39;i</code> and <code>ref_to_int</code> lifetime <code>&#39;r</code> with type <code>&amp;&#39;i int</code> denoting that it&rsquo;s a reference type that points to an <code>int</code> of lifetime <code>&#39;i</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">integer</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ref_to_int</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">integer</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p>It&rsquo;s possible to give a lifetime a name in order to explicitly specify the lifetime of a returned reference. In the following case, the named lifetime <code>&#39;r</code> is associated with the parameter <code>p: &amp;Point</code>, this named lifetime is then also mentioned in the return type. What this means is that the returned reference will have the same lifetime as the passed in pointer parameter <code>p</code>. In effect, this means that the returned reference will remain valid as long as <code>p</code> itself remains valid.</p>

<p>This is necessary because, generally it&rsquo;s only possible to return references derived from a parameter to the function, and named lifetimes explicitly specify which parameter that is. The lifetime is something that&rsquo;s implicitly passed in from the caller&rsquo;s context, just like the parameter.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">struct</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">get_x</span><span class="o">&lt;</span><span class="nl">&#39;r</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;r</span><span class="w"> </span><span class="n">Point</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;r</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">&amp;</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Named lifetimes allow grouping of parameters by lifetime. The following means that all of the parameters are assigned the same named lifetime <code>r</code>, so that in the caller the lifetime <code>r</code> will be the intersection of the lifetime of the three region parameters.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">select</span><span class="o">&lt;</span><span class="nl">&#39;r</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">shape</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;r</span><span class="w"> </span><span class="n">Shape</span><span class="p">,</span><span class="w"> </span><span class="n">threshold</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;r</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;r</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;r</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">compute_area</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">threshold</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>For example, if <code>select()</code> were called by the following function it would produce an error. The reason is that the lifetime of the first parameter to <code>select()</code> is the function body of <code>select_unit()</code>. The second two parameters to <code>select()</code> share a lifetime in <code>select_unit()</code>, so there are actually two lifetimes. The intersection between these two lifetimes would be the <code>Shape</code>&rsquo;s lifetime which is the function body, so the return value of the <code>select()</code> call will be the function body of <code>select_unit()</code>.</p>

<p>This would lead to a <em>compilation error</em>, because <code>select_unit()</code> is supposed to return a value with a lifetime of <code>r</code>, which is the lifetime of <code>a</code> and <code>b</code>, <em>not</em> the lifetime of the local <code>Circle</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">select_unit</span><span class="o">&lt;</span><span class="nl">&#39;r</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">threshold</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;r</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;r</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;r</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mf">0.</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mf">1.</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">select</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shape</span><span class="p">,</span><span class="w"> </span><span class="n">threshold</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>This can be resolved by creating another lifetime, <code>&#39;tmp</code> in <code>select()</code> and assign it to the <code>shape</code> parameter, in order to distinguish it from the lifetime of the last two parameters. However, since we wouldn&rsquo;t be using the <code>&#39;tmp</code> lifetime and the compiler is guaranteed to generate a unique lifetime for ever parameter, it&rsquo;s simpler to simply omit it altogether:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">select</span><span class="o">&lt;</span><span class="nl">&#39;r</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">shape</span><span class="o">:</span><span class="w"> </span><span class="n">Shape</span><span class="p">,</span><span class="w"> </span><span class="n">threshold</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;r</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;r</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;r</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">compute_area</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">threshold</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>It&rsquo;s also necessary to specify explicit lifetimes in structures that contain references.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">struct</span><span class="w"> </span><span class="n">Pair</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="nl">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">one</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">two</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;b</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>It&rsquo;s also possible to use named lifetime notation to label control structures, allowing for breaking and continuing to specific locations.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="nl">&#39;h</span><span class="o">:</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nl">&#39;g</span><span class="o">:</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">continue</span><span class="w"> </span><span class="nl">&#39;h</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">break</span><span class="w"> </span><span class="nl">&#39;h</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="w"> </span><span class="nl">&#39;g</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h3 id="elision">
<span class="hash">#</span>
<a href="#elision" class="header-link">Elision</a>
</h3>
<p><abbr title="Request for Comments">RFC</abbr> <a href="https://github.com/rust-lang/rfcs/blob/master/text/0141-lifetime-elision.md">#141</a> proposed expanded lifetime elision rules. The practical effect of this is that a lot of omitted, or <em>elided</em>, lifetime annotations can be inferred by the compiler.</p>

<p>To facilitate this, the compiler has notions of input or output. For <em>functions</em>, inputs are the lifetimes on arguments and outputs are the lifetimes on result types; this <em>doesn&rsquo;t</em> include lifetimes that appear in the method&rsquo;s <code>impl</code> or <code>trait</code> header. For <em>implementations</em>, inputs are the lifetimes on the type receiving the implementation, and the outputs are the lifetimes on the trait.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="c1">// elided one input and two outputs</span>
<span class="k">fn</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"></span>

<span class="c1">// input:  &#39;a, &#39;c</span>
<span class="c1">// output: &#39;b, &#39;c</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="nl">&#39;b</span><span class="p">,</span><span class="w"> </span><span class="nl">&#39;c</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="nl">&#39;b</span><span class="p">,</span><span class="w"> </span><span class="nl">&#39;c</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Type</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="nl">&#39;c</span><span class="o">&gt;</span><span class="w"></span>
</code></pre></figure>
<p>Given this distinction between lifetime parameters, the rules are simple:</p>

<ol>
<li><p>each elided lifetime in input position becomes a distinct lifetime parameter, as was already the case</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">);</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="nb">print</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">);</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Reader</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="nl">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Reader</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;b</span><span class="w"> </span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></figure></li>
<li><p>if there&rsquo;s only one input lifetime position, its lifetime is assigned to all elided output lifetimes</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">substr</span><span class="p">(</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">until</span><span class="o">:</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">;</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">substr</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">until</span><span class="o">:</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">StrSlice</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">StrSlice</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></figure></li>
<li><p>if there are multiple input lifetime positions and one of them is <code>&amp;self</code> or <code>&amp;mut self</code>, the lifetime of <code>self</code> is assigned to all elided output lifetimes</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">args</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="nb">ToCStr</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Command</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">args</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="nl">&#39;b</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="nb">ToCStr</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;b</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">Command</span><span class="w"></span>
</code></pre></figure></li>
<li><p>otherwise, it&rsquo;s an error to elide an output lifetime</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">get_str</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">;</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">frob</span><span class="p">(</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">;</span><span class="w"></span>
</code></pre></figure></li>
</ol>

<p>Lifetime elision with implementations is a bit trickier. Elision inference occurs at two levels: the implementation header line and its methods. Expansion can occur in trait methods since they&rsquo;re treated as any other function.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">bound</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">fresh</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// fresh expands like any other function</span>
<span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">bound</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">fresh</span><span class="o">&lt;</span><span class="nl">&#39;b</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;b</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;b</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>In general, the elided signatures of the <code>impl</code> should match those of the <code>trait</code> so that the <code>impl</code> expansion matches the <code>trait</code> and thus will compile. Failing to do this might break the relationship between an <code>impl</code> header-level lifetime and a method&rsquo;s lifetime.</p>

<p>Consider the following example where the <code>impl</code> header-level was expanded, and then the <code>bound</code> method expanded separately with a distinct lifetime (as per rule #1) even though they&rsquo;re supposed to be the same as specified in the <code>trait</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">bound</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// bound&#39;s lifetime should&#39;ve been &#39;a</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">bound</span><span class="o">&lt;</span><span class="nl">&#39;b</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;b</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;b</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>If the signatures are used exactly as in the <code>trait</code>, with the same lifetime elisions, the <code>impl</code> expansion will most likely expand to match the <code>trait</code>&rsquo;s expansion.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">bound</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">fresh</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// fresh method expands correctly</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">bound</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;a</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">fresh</span><span class="o">&lt;</span><span class="nl">&#39;b</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">&#39;b</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;b</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h2 id="dropping">
<span class="hash">#</span>
<a href="#dropping" class="header-link">Dropping</a>
</h2>
<p>Destructors are functions responsible for cleaning up resources used by an object that is no longer accessible. Objects are never accessible after their destructor has been called, so it&rsquo;s not possible to fail from accessing freed resources. Further, when a task fails, destructors of all objects in the task are called.</p>

<p>The <code>box</code> keyword represents a unique handle for a memory allocation on the heap:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// allocated on the heap</span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// destructor frees heap memory as soon as `y` goes out of scope</span>
</code></pre></figure><h1 id="collections">
<span class="hash">#</span>
<a href="#collections" class="header-link">Collections</a>
</h1><h2 id="arrays">
<span class="hash">#</span>
<a href="#arrays" class="header-link">Arrays</a>
</h2>
<p>Fixed-size vectors are unboxed blocks of memory that owns the elements it contains.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">fixed_size</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">five_zeroes</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="p">..</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">..</span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
</code></pre></figure><h2 id="slices">
<span class="hash">#</span>
<a href="#slices" class="header-link">Slices</a>
</h2>
<p>Slices point into blocks of memory and don&rsquo;t have ownership over the elements. Other vector types coerce to slices. An unadorned string literal is an immutable string slice:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ys</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xs</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">three</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">zs</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">three</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;foobar&quot;</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">view</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">string</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
</code></pre></figure>
<p>Mutable slices exist, but none for strings, since strings are a multi-byte encoding of Unicode code points, meaning they can&rsquo;t be freely mutated without the ability to alter the length, something that can&rsquo;t be done via slices, which simply provide a window.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">mut_slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="n">view</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">ys</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
</code></pre></figure>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0198-slice-notation.md"><abbr title="Request for Comments">RFC</abbr> #198</a> adds overloaded slice notation via the <code>Slice</code> and <code>SliceMut</code> traits.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w"></span>

<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">xs</span><span class="p">[],</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">as_slice</span><span class="p">());</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">n</span><span class="p">..</span><span class="n">m</span><span class="p">],</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">));</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">n</span><span class="p">..],</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">slice_from</span><span class="p">(</span><span class="n">n</span><span class="p">));</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">xs</span><span class="p">[..</span><span class="n">m</span><span class="p">],</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">slice_to</span><span class="p">(</span><span class="n">m</span><span class="p">));</span><span class="w"></span>

<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="k">mut</span><span class="p">],</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">as_mut_slice</span><span class="p">());</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="k">mut</span><span class="w"> </span><span class="n">n</span><span class="p">..</span><span class="n">m</span><span class="p">],</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">slice_mut</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">));</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="k">mut</span><span class="w"> </span><span class="n">n</span><span class="p">..],</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">slice_from_mut</span><span class="p">(</span><span class="n">n</span><span class="p">));</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="k">mut</span><span class="w"> </span><span class="p">..</span><span class="n">m</span><span class="p">],</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">slice_to_mut</span><span class="p">(</span><span class="n">m</span><span class="p">));</span><span class="w"></span>
</code></pre></figure><h2 id="vectors">
<span class="hash">#</span>
<a href="#vectors" class="header-link">Vectors</a>
</h2>
<p>Vectors are dynamically-sized and have a destructor that cleans up the allocated memory on the heap. Vectors own the elements they contain. They are represented with 3 words: a pointer to the data, its length, and its capacity representing how much memory is reserved for the vector.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="n">numbers</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">more_numbers</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numbers</span><span class="p">;</span><span class="w"></span>
</code></pre></figure><h2 id="strings">
<span class="hash">#</span>
<a href="#strings" class="header-link">Strings</a>
</h2>
<p>Strings are represented as vectors of <code>u8</code> with a guarantee of containing a valid UTF-8 sequence. The <code>String</code> type represents a non-null terminated, growable string, while the <code>&amp;str</code> type represents fixed-sized one.</p>

<p><code>String</code> is represented as a vector of bytes <code>Vec&lt;u8&gt;</code> that is guaranteed to always be a valid UTF-8 sequence. The <code>&amp;str</code> type is a slice <code>&amp;[u8]</code> that always points to a valid UTF-8 sequence and can be used as a view into String, as <code>&amp;[T]</code> is a view into <code>Vec&lt;T&gt;</code>.</p>

<p>String literals are stored in the static region of the program&rsquo;s memory, and so Rust treats static strings as slices which serve as views into the region of memory pertaining to the string: <code>&amp;&#39;static str</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="o">::</span><span class="nb">from_str</span><span class="p">(</span><span class="s">&quot;fo&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">string</span><span class="p">.</span><span class="n">push_char</span><span class="p">(</span><span class="nl">&#39;o</span><span class="err">&#39;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// trimmed strings are slices into original string</span>
<span class="c1">// no new allocation required</span>
<span class="kd">let</span><span class="w"> </span><span class="n">trimmed</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">string</span><span class="p">.</span><span class="n">as_slice</span><span class="p">().</span><span class="n">trim_chars</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="sc">&#39;,&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">]);</span><span class="w"></span>
<span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Unused characters: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">trimmed</span><span class="p">);</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">literal</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;testing&quot;</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p>Raw string literals are possible by surrounding the string with zero or more hashes <code>#</code> as needed to disambiguate from the string contents, and prefixed by an <code>r</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s-Raw">r#&quot;\d+&quot;#</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p>Byte string literals are possible by prefixing the string with a <code>b</code> and are stored as <code>&amp;&#39;static [u8]</code>. A byte literal is a single ASCII character surrounded by single quotes and prefixed by <code>b</code>.</p>

<p>Byte literals can have raw bodies by appending the <code>b</code> prefix with the <code>r</code> for raw string literals.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">letter</span><span class="o">:</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="nl">&#39;A</span><span class="err">&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 65u8</span>
<span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;static</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="s">&quot;john&quot;</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">raw_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">br</span><span class="err">#</span><span class="s">&quot;test&quot;</span><span class="err">#</span><span class="p">;</span><span class="w"></span>
</code></pre></figure><h1 id="pattern-matching">
<span class="hash">#</span>
<a href="#pattern-matching" class="header-link">Pattern Matching</a>
</h1>
<p>Pattern matching takes the place of regular switch statements. Pattern matches don&rsquo;t fall through. The pipe operator <code>|</code> can be used to combine multiple patterns into one arm. As in Haskell, matches must be exhaustive. Every case is separated by commas, unless block expressions are used. As in Haskell, pattern matching can be used to bind values. Pattern guards are added using <code>if</code> expressions:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">match</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="mi">0</span><span class="w">     </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">println</span><span class="p">(</span><span class="s">&quot;zero&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">println</span><span class="p">(</span><span class="s">&quot;one or two&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="mf">3.</span><span class="p">.</span><span class="mi">10</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">println</span><span class="p">(</span><span class="s">&quot;three to ten&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">_</span><span class="w">     </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">println</span><span class="p">(</span><span class="s">&quot;something else&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>The underscore <code>_</code> is a placeholder and two dots <code>..</code> acts as a wildcard pattern for matching the rest of the fields.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Cons</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="n">Nil</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;singleton list&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">Cons</span><span class="p">(..)</span><span class="w">         </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Nil</span><span class="w">              </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;empty list&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Patterns can also be bound to variables as in Haskell and Scala:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">match</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="mf">0.</span><span class="p">.</span><span class="mi">20</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{} years old&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">_</span><span class="w">         </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;older than 21&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Pattern matching on structures can use the field name which creates a local varaible with that name <sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">struct</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">age</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">apples</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="n">apples</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0160-if-let.md"><abbr title="Request for Comments">RFC</abbr> #160</a> added support for <code>if-let</code> pattern matching as in <a href="/notes/swift/#optionals">Swift</a>, where the condition succeeds if the pattern matches.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optional</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">doSomething</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Similarly, <a href="https://github.com/rust-lang/rfcs/blob/master/text/0214-while-let.md"><abbr title="Request for Comments">RFC</abbr> #214</a> added support for <code>while-let</code>. It works in a similar manner to the above <code>if-let</code>, essentially continuing the loop so long as the pattern matches. This is useful for iterators.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>With the <code>advanced_slice_patterns</code> feature gate, it&rsquo;s possible to use more advanced pattern matching on slices. With these patterns, <code>..</code> can be used to match any number of elements, which can also be bound to a name.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">match</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="n">rest</span><span class="p">..]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">blah</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h1 id="control-structures">
<span class="hash">#</span>
<a href="#control-structures" class="header-link">Control Structures</a>
</h1>
<p>The for loop is in the form of <code>for-in</code>; there is no explicit increment looping via for loops. The <code>loop</code> keyword denotes an infinite loop.</p>
<h1 id="structures">
<span class="hash">#</span>
<a href="#structures" class="header-link">Structures</a>
</h1>
<p>Structures are laid out in memory the same as as they are in C. Structures are constructed similar to Go structures. Structures have inherited mutability. Structures can be pattern matched on to destructure their fields.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">struct</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">match</span><span class="w"> </span><span class="n">mypoint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="p">..</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">println</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">to_str</span><span class="p">())</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Structures can define methods by providing implementations.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="k">static</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// static method</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">something</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// method</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Functional updates can be performed by terminating the structure expression syntax with <code>..</code> followed by another value of the same type as the structure being defined. This is similar to what is commonly done in Haskell.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point3d</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">Point3d</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="o">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="p">..</span><span class="n">base</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></figure><h1 id="enumerations">
<span class="hash">#</span>
<a href="#enumerations" class="header-link">Enumerations</a>
</h1>
<p>Enumerations in Rust feel similar to algebraic datatypes in Haskell. Enumerations can be C-like, in which case they can optionally be given specific values. The specific values can be converted to an <code>int</code> using the cast operator <code>as</code>. Enumerations can define methods with the <code>impl</code> keyword as with structures. Enumerations variants can be structs as well:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">enum</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">Rectangle</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">enum</span><span class="w"> </span><span class="n">Direction</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Left</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Right</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">enum</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Red</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xff0000</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Green</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00ff00</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Blue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0000ff</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[feature(struct_variant)]</span><span class="w"></span>
<span class="k">enum</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">center</span><span class="o">:</span><span class="w"> </span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">radius</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">top_left</span><span class="o">:</span><span class="w"> </span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">bottom_right</span><span class="o">:</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h1 id="tuples">
<span class="hash">#</span>
<a href="#tuples" class="header-link">Tuples</a>
</h1>
<p>Tuples are available and are most similar to Haskell&rsquo;s. <em>Tuple structs</em> behave like both structs and tuples. They&rsquo;re like tuples with names. Tuple structs with a single field are similar to Haskell newtypes and are often called the same thing in Rust. These provide a distinct type from the type they wrap. Newtypes' wrapped values can be extracted using the dereference operator <code>*</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">mytup</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mf">30.0</span><span class="p">)</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">MyTup</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">mytup</span><span class="o">:</span><span class="w"> </span><span class="n">MyTup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyTup</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mf">30.0</span><span class="p">)</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">GizmoId</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">my_gizmo_id</span><span class="o">:</span><span class="w"> </span><span class="n">GizmoId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GizmoId</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">id_int</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">my_gizmo_id</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0184-tuple-accessors.md"><abbr title="Request for Comments">RFC</abbr> #184</a> adds tuple accessor syntax which applies to tuples and tuple structs. Only one level is possible since more than one would be considered a float.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">tpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">tpl</span><span class="p">.</span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">15</span><span class="p">);</span><span class="w"></span>
<span class="n">foo</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
</code></pre></figure><h1 id="functions">
<span class="hash">#</span>
<a href="#functions" class="header-link">Functions</a>
</h1>
<p>Function definitions are similar to Scala&rsquo;s, with the type following the name of the parameter. The return type follows the parameter list as in Scala, but more like C++11&rsquo;s <a href="http://en.wikipedia.org/wiki/C++11#Alternative_function_syntax">alternative function syntax</a>. If the top-level block of the function produces an expression, the <code>return</code> statement may be omitted. Functions that return nothing return nil <code>()</code>, which can be omitted from the function declaration. However, ending the function with a semicolon is also equivalent to returning <code>()</code>. Function arguments can be destructured, but the patterns must be irrefutable:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">line</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">do_nothing_the_hard_way</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">do_nothing_the_easy_way</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">do_nothing_another_way</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">first</span><span class="p">((</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="p">))</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>In short, blocks such as <code>{ expr1; expr2 }</code> are considered a single expression and evaluate to the result of the last expression if it&rsquo;s not followed by a semicolon, otherwise the block evaluates to <code>()</code>.</p>

<p>A diverging function is one that never returns a value to the caller. Every control path must end in <code>panic!()</code> or another diverging function. This is informs the compiler that execution will never return to the original context, allowing things to type-check where they wouldn&rsquo;t otherwise.</p>

<p>In the following example, <code>my_err</code> can be used even though it&rsquo;s not of type <code>int</code> because it&rsquo;s a diverging function.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">my_err</span><span class="p">(</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">panic</span><span class="o">!</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">my_err</span><span class="p">(</span><span class="s">&quot;Bad number!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Parameters can be marked as to be moved into the function. They can also be borrowed immutably, or mutably which allows the variable to be mutated. Finally, a parameter can also be moved into the function and marked as mutable, so that once moved into the function it can be mutated within the scope of the function.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">);</span><span class="w">      </span><span class="c1">// move</span>
<span class="k">fn</span><span class="w"> </span><span class="n">m</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">);</span><span class="w">  </span><span class="c1">// move and mark mutable</span>
<span class="k">fn</span><span class="w"> </span><span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">T</span><span class="p">);</span><span class="w">     </span><span class="c1">// immutably borrow</span>
<span class="k">fn</span><span class="w"> </span><span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">);</span><span class="w"> </span><span class="c1">// mutably borrow</span>
</code></pre></figure><h1 id="methods">
<span class="hash">#</span>
<a href="#methods" class="header-link">Methods</a>
</h1>
<p>Methods are functions that take <code>self</code> as the first argument, which is of the same type as the method&rsquo;s receiver. Implementations are used to define methods on specific types, such as structs and enums.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">struct</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">enum</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">Rectangle</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">Circle</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w">      </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">draw_circle</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="n">Rectangle</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">draw_rectangle</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Circle</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mf">3.0</span><span class="p">);</span><span class="w"></span>
<span class="n">s</span><span class="p">.</span><span class="n">draw</span><span class="p">();</span><span class="w"></span>
</code></pre></figure>
<p>It&rsquo;s also possible to define static methods by omitting the <code>self</code> parameter. This is usually how constructors are defined:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">f64</span><span class="o">::</span><span class="n">consts</span><span class="o">::</span><span class="n">PI</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">radius</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">new</span><span class="p">(</span><span class="n">area</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">radius</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">area</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">PI</span><span class="p">).</span><span class="n">sqrt</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Circle</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mf">42.5</span><span class="p">);</span><span class="w"></span>
</code></pre></figure><h2 id="universal-function-call-syntax">
<span class="hash">#</span>
<a href="#universal-function-call-syntax" class="header-link">Universal Function Call Syntax</a>
</h2>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md"><abbr title="Request for Comments">RFC</abbr> #132</a> specifies a <em>universal function call syntax</em> (<abbr title="Universal Function Call Syntax">UFCS</abbr>) which provides a way to completely disambiguate a particular method call, which is particularly useful when a type implements more than one trait that contains the same method.</p>

<p>Given a particular call syntax, different behavior occurs:</p>

<ul>
<li><p><code>Trait::method()</code>: the same behavior occurs as it does now.</p></li>
<li><p><code>T::method()</code> where <code>T</code> is a path that resolves to a type: it is rewritten internally to <code>&lt;T&gt;::method()</code>.</p></li>
<li><p><code>&lt;T&gt;::method()</code>: if type <code>T</code> implements only one trait in the scope that provides <code>method()</code>, then that method is called. Otherwise, the call must be disambiguated using the syntax <code>&lt;T as DesiredTrait&gt;::method()</code>.</p></li>
</ul>

<p>A nice consequence of <abbr title="Universal Function Call Syntax">UFCS</abbr> is that static methods on traits can be called through the implementing type now, instead of having to be called on the trait itself.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[deriving(Default)]</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">S</span><span class="p">;</span><span class="w"></span>

<span class="n">S</span><span class="o">::</span><span class="n">default</span><span class="p">();</span><span class="w"></span>
<span class="nb">Default</span><span class="o">::</span><span class="n">default</span><span class="p">();</span><span class="w"></span>
</code></pre></figure>
<p>In fact, <abbr title="Universal Function Call Syntax">UFCS</abbr> completely erases the distinction between static methods and regular methods, so that <code>t.a(b)</code> is also equivalent to <code>T::a(t, b)</code>. This means that methods can be called <a href="https://github.com/rust-lang/rust/pull/18053">like functions</a>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">struct</span><span class="w"> </span><span class="n">Foo</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">;</span><span class="w"></span>

<span class="n">x</span><span class="p">.</span><span class="n">bar</span><span class="p">();</span><span class="w"></span>
<span class="n">Foo</span><span class="o">::</span><span class="n">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
</code></pre></figure><h1 id="closures">
<span class="hash">#</span>
<a href="#closures" class="header-link">Closures</a>
</h1>
<p>Regular, named functions don&rsquo;t close over their environment, but closures do.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">call_closure_with_ten</span><span class="p">(</span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="o">|</span><span class="kt">int</span><span class="o">|</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">captured_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">closure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">arg</span><span class="o">|</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;captured_var={}, arg={}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">captured_var</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span><span class="w"></span>

<span class="n">call_closure_with_ten</span><span class="p">(</span><span class="n">closure</span><span class="p">);</span><span class="w"></span>
</code></pre></figure>
<p>Stack closures are a specific kind of closure that directly accesses local variables in the enclosing scope, making them very efficient. To ensure that they don&rsquo;t outlive the current scope, they aren&rsquo;t first class, so they can&rsquo;t be assigned to values or returned from functions.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">].</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
</code></pre></figure>
<p>Owned closures are written with <code>proc</code>, e.g. <code>proc(arg: int)</code>, and they own values that can be sent safely between processes. As a result, they can only be called once. The values they close over are copied, and they become owned by the closure. These are particularly used in concurrent scenarios, particularly for spawning tasks.</p>

<p>Despite there being different types of closures, functions that expect a <code>||</code> closure can accept any kind of closure provided they have the same arguments and return types. For this reason, higher-order functions should usually define their closure types as <code>||</code> so that callers can pass any kind of closure.</p>
<h2 id="unboxed-closures">
<span class="hash">#</span>
<a href="#unboxed-closures" class="header-link">Unboxed Closures</a>
</h2>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0114-closures.md"><abbr title="Request for Comments">RFC</abbr> #114</a> proposed unboxed closure traits <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>, along with new closure syntax which was refined by <a href="https://github.com/rust-lang/rfcs/blob/master/text/0231-upvar-capture-inference.md"><abbr title="Request for Comments">RFC</abbr> #231</a>. These traits are defined in <a href="http://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a>, which is a module that defines traits for overloading operators. In effect, implementing these traits is equivalent to overloading the function call operator <code>()</code> in C++.</p>

<p>As in C++, unboxed closures essentially expand to an anonymous structure which contains the captured variables&mdash;known as <em>upvars</em>&mdash;as well as an implementation of one of these traits, which has the effect of overloading the function call operator <code>()</code>.</p>

<p>In this context, the receiving parameter <code>self</code> refers to the instance of the generated structure, so that the type of <code>self</code> determines whether the upvars can be moved or mutated. This is exactly the difference between the three unboxed closure traits.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Trait</th>
<th style="text-align: left">Self</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>Fn</code></td>
<td style="text-align: left"><code>&amp;self</code></td>
</tr>
<tr>
<td style="text-align: left"><code>FnMut</code></td>
<td style="text-align: left"><code>&amp;mut self</code></td>
</tr>
<tr>
<td style="text-align: left"><code>FnOnce</code></td>
<td style="text-align: left"><code>self</code></td>
</tr>
</tbody>
</table>

<p>The <abbr title="Request for Comments">RFC</abbr> defines two types of closures: escaping and non-escaping closures. <em>Escaping closures</em> are closures that will escape the stack frame that created them&mdash;such as task bodies&mdash;and are created using the <code>move ||</code> syntax. <em>Non-escaping closures</em> are the most common and therefore use the default <code>||</code> syntax.</p>

<p>Both escaping and non-escaping closures can implement any of the closure traits, depending on how the upvars are used within the closure.</p>

<ol>
<li><code>FnOnce</code> if any upvars are moved out of the closure</li>
<li><code>FnMut</code> if any upvars are mutably borrowed within the closure</li>
<li>otherwise: <code>Fn</code></li>
</ol>

<p>Notice that moving an upvar out of the closure essentially means to move it out of the closure&rsquo;s environment, that is, its implementing anonymous structure.</p>

<p>The trait above is inferred, but inference of these traits is not completely implemented yet. As a result, there exists syntax sugar to explicitly declare which trait to choose.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Trait</th>
<th style="text-align: left">Sugar</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>Fn</code></td>
<td style="text-align: left"><code>|&amp;:|</code></td>
</tr>
<tr>
<td style="text-align: left"><code>FnMut</code></td>
<td style="text-align: left"><code>|&amp;mut:|</code></td>
</tr>
<tr>
<td style="text-align: left"><code>FnOnce</code></td>
<td style="text-align: left"><code>|:|</code></td>
</tr>
</tbody>
</table>

<p>A simple way to remember this sugar is to imagine that the <code>self</code> keyword precedes the colon <code>:</code>, which makes it obvious that this sugar is designating the type of the <code>self</code> parameter, which corresponds to the appropriate trait.</p>

<p><em>Capture modes</em> determine the manner in which upvars are captured. With escaping closures, all upvars are moved into the closure. For non-escaping closures, there are three different capture modes that are applied depending on three different situations which are checked in-order:</p>

<ol>
<li>if an upvar is mutably borrowed within the closure, it is mutably borrowed into the closure</li>
<li>if an upvar is moved within the closure and doesn&rsquo;t implement <code>Copy</code>, it is moved into the closure</li>
<li>otherwise: the upvar is immutably borrowed</li>
</ol>

<p>Notice that regular non-escaping closures can end up moving all of the upvars <em>only</em> if they&rsquo;re moved within the closure. This is why the separate escaping closure syntax <code>move ||</code> is necessary, for cases where the closure escapes the stack frame, in order to ensure that all upvars are moved into the closure regardless of how they&rsquo;re used within.</p>

<p>There exists sugar for denoting unboxed closure traits at the type level.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">foo</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">F</span><span class="o">:</span><span class="w"> </span><span class="n">FnMut</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h1 id="generics">
<span class="hash">#</span>
<a href="#generics" class="header-link">Generics</a>
</h1>
<p>Types can be parameterized similar to C++ class templates:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">enum</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Const</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">Nil</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">prepend</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xs</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Cons</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>The compiler can infer the type of a list like this:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nil</span><span class="p">;</span><span class="w"></span>
<span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prepend</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prepend</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span><span class="w"></span>
<span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prepend</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">);</span><span class="w"></span>
</code></pre></figure>
<p>However, it&rsquo;s also possible to explicitly annotate the types:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">xs</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nil</span><span class="o">::&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prepend</span><span class="o">::&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prepend</span><span class="o">::&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span><span class="w"></span>
<span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prepend</span><span class="o">::&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">);</span><span class="w"></span>
</code></pre></figure>
<p>The list equality function can be updated for this generic list by adding a trait bound of <code>Eq</code> on the element type and adding <code>ref</code> annotations to avoid moving out the element types. In fact, we might as well implement the <code>Eq</code> trait for this generic list already:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="nb">Eq</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Eq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">ys</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">ys</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="o">&amp;</span><span class="n">Nil</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Nil</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">true</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="o">&amp;</span><span class="n">Cons</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">next_xs</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Cons</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">next_ys</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">next_xs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">next_ys</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Generic functions in Rust have similar performance characteristics as templates in C++ because it performs <em>monomorphization</em> which generates a separate copy of each generic function at each call site, which is specialized to the argument types, optimized specifically for them. This is similar to C++ template instantiation.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vector</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="n">function</span><span class="o">:</span><span class="w"> </span><span class="o">|</span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">T</span><span class="o">|</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">U</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">accumulator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vec</span><span class="o">::</span><span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">vector</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">accumulator</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">element</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">accumulator</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Type parameters can also be used to define generic types, structs, and enums.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">hashmap</span><span class="o">::</span><span class="n">HashMap</span><span class="p">;</span><span class="w"></span>
<span class="k">type</span><span class="w"> </span><span class="nb">Set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Set&lt;int&gt;</span>

<span class="k">struct</span><span class="w"> </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">elements</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Stack&lt;int&gt;</span>

<span class="k">enum</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="nb">None</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Option&lt;int&gt;</span>
</code></pre></figure><h2 id="where-clauses">
<span class="hash">#</span>
<a href="#where-clauses" class="header-link">Where Clauses</a>
</h2>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md"><abbr title="Request for Comments">RFC</abbr> #135</a> adds support for <code>where</code> clauses similar to <a href="/notes/swift/#where-clauses">those in Swift</a> which allow type bounds to be specified for the type parameters in a generic declaration. Where clauses can be added to anything that can be parameterized with type or lifetime parameters, except for trait method definitions. This includes <code>impl</code>, <code>fn</code>, <code>trait</code>, <code>struct</code>, as well as <a href="#associated-types">associated types</a>.</p>

<p>Multiple bounds declarations are separated by commas, and multiple bounds for a given type parameter can be written separately or in a compound form using <code>+</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="o">:</span><span class="w"> </span><span class="nb">Hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Eq</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">where</span><span class="w"> </span><span class="n">K</span><span class="o">:</span><span class="w"> </span><span class="nb">Hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Eq</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>With <a href="#associated-types">associated types</a>, a trait like <code>Iterator</code> might no longer have type parameters, since it&rsquo;ll be an associated type. As a result, a bound can&rsquo;t be provided for the type parameter using regular syntax. Instead, <code>where</code> clauses can be used to express the bound.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="c1">// Iterator has no type parameter, so this doesn&#39;t work</span>
<span class="k">fn</span><span class="w"> </span><span class="n">sum</span><span class="o">&lt;</span><span class="n">I</span><span class="o">:</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// the where clause can express a bound</span>
<span class="c1">// on the Iterator&#39;s associated type `E`</span>
<span class="k">fn</span><span class="w"> </span><span class="n">sum</span><span class="o">&lt;</span><span class="n">I</span><span class="o">:</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="w">  </span><span class="n">where</span><span class="w"> </span><span class="n">I</span><span class="o">::</span><span class="n">E</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h1 id="traits">
<span class="hash">#</span>
<a href="#traits" class="header-link">Traits</a>
</h1>
<p>Traits are similar to type classes in Haskell. They allow the expression of <em>bounded polymorphism</em> which limits the possible types a type parameter could refer to. For example, the <code>clone</code> method which allows the copying of a type, isn&rsquo;t defined on all types because it can&rsquo;t be safely performed on all types, due to user-defined destructors for example. Traits allow to bound the polymorphism of a generic function by specifying that a type parameter must implement the <code>Clone</code> trait in this case to limit the types on which the function can work:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">head</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">clone</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Traits contain zero or more method signatures. In the following trait, it is said that <code>Printable</code> provides a <code>print</code> method with the given signature:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">trait</span><span class="w"> </span><span class="n">Printable</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nb">print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Printable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nb">print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Printable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nb">print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">println</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>It&rsquo;s also possible to define default method implementations which can later be overridden on a case-by-case basis:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">trait</span><span class="w"> </span><span class="n">Printable</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nb">print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// these use default implementation</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Printable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">Printable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">Printable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">f32</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="c1">// overrides default implementation</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Printable</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nb">print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">println</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Traits may be parameterized by type variables. Traits can be implemented generically or specifically for a particular type.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">trait</span><span class="w"> </span><span class="n">Seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Seq</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// implement Seq&lt;bool&gt; for u32</span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>The <code>Self</code> type parameter is available within the trait definition and is replaced with the eventual type <code>T</code> in the implementation:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Eq</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">equals</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Eq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">equals</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">other</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Traits can also define static methods which are ultimately called with a <code>::</code> prefix as well:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">f64</span><span class="o">::</span><span class="n">consts</span><span class="o">::</span><span class="n">PI</span><span class="p">;</span><span class="w"></span>

<span class="k">trait</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">new</span><span class="p">(</span><span class="n">area</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">radius</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">new</span><span class="p">(</span><span class="n">area</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">radius</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">area</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">PI</span><span class="p">).</span><span class="n">sqrt</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="o">:</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Shape</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">area</span><span class="p">);</span><span class="w"></span>
</code></pre></figure>
<p>Type parameters can have multiple bounds by combining them with <code>+</code>. Method calls to bounded type parameters are statically dispatched:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">print_all</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Printable</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">printable_things</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// can clone() then print()</span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>It&rsquo;s possible to have method calls to trait types that are dynamically dispatched. With this, it&rsquo;s possible to define a function that performs the <code>draw</code> method on type that implements <code>Drawable</code>, which itself provides the <code>draw</code> method. This particular method takes a borrowed pointer to an array of owned values that implement the <code>Drawable</code> trait. Such an array must be constructed by casting each element to <code>Box&lt;Drawable&gt;</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">draw_all</span><span class="p">(</span><span class="n">shapes</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Drawable</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">shapes</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">shape</span><span class="p">.</span><span class="n">draw</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">draw_all</span><span class="p">([</span><span class="n">circle</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Drawable</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">rectangle</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Drawable</span><span class="o">&gt;</span><span class="p">])</span><span class="w"></span>
</code></pre></figure>
<p>Traits can inherit from other traits, so that the traits they inherit from are referred to as <em>supertraits</em>. This means that for any type to implement the derived trait, it must also implement the supertrait:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">trait</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">f64</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">trait</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">radius</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">f64</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">CircleStruct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">center</span><span class="o">:</span><span class="w"> </span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">radius</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CircleStruct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">radius</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">area</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">PI</span><span class="p">).</span><span class="n">sqrt</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CircleStruct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">PI</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">radius</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>It&rsquo;s also possible to call supertrait methods on subtrait-bound type parameter values. This is also possible from trait objects:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">radius_times_area</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">c</span><span class="p">.</span><span class="n">radius</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">area</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">concrete</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="n">CircleStruct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">center</span><span class="o">:</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="n">f</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">radius</span><span class="o">:</span><span class="w"> </span><span class="mi">5</span><span class="n">f</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">mycircle</span><span class="o">:</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">concrete</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Circle</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">nonsense</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mycircle</span><span class="p">.</span><span class="n">radius</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mycircle</span><span class="p">.</span><span class="n">area</span><span class="p">();</span><span class="w"></span>
</code></pre></figure>
<p>Some traits can be automatically derived, similar to Haskell. The full list is <code>Eq</code>, <code>TotalEq</code>, <code>Ord</code>, <code>TotalOrd</code>, <code>Encodable</code>, <code>Decodable</code>, <code>Clone</code>, <code>DeepClone</code>, <code>IterBytes</code>, <code>Rand</code>, <code>Default</code>, <code>Zero</code>, <code>FromPrimitive</code>, and <code>Show</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[deriving(Eq)]</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">radius</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="cp">#[deriving(Rand, ToStr)]</span><span class="w"></span>
<span class="k">enum</span><span class="w"> </span><span class="n">ABC</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></figure><h2 id="associated-items">
<span class="hash">#</span>
<a href="#associated-items" class="header-link">Associated Items</a>
</h2>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md"><abbr title="Request for Comments">RFC</abbr> #195</a> adds support for associated functions, statics, types, and lifetimes. Both associated types and statics allow defaults, just as associated methods and functions do. However, if an implementation overrides any default associted types, then they must override <em>all</em> default functions and methods.</p>
<h3 id="associated-types">
<span class="hash">#</span>
<a href="#associated-types" class="header-link">Associated Types</a>
</h3>
<p>Consider a <code>Graph</code> type with node and edge type parameters. Without associated types, any function that operates on generic <code>Graph</code>s has to parameterize on all type parameters even when they&rsquo;re not relevant.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">trait</span><span class="w"> </span><span class="n">Graph</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">has_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">distance</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="p">,</span><span class="w"> </span><span class="n">G</span><span class="o">:</span><span class="w"> </span><span class="n">Graph</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">graph</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>With associated types, it&rsquo;s made clear that the node and edge types are defined by specific implementations. This way, code can abstract over the entire <code>Graph</code> and refer to associated types through the <code>Graph</code> as needed.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">trait</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// trait bounds can be specified with the usual + delimited syntax</span>
<span class="w">  </span><span class="k">type</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">type</span><span class="w"> </span><span class="n">E</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">has_edge</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">distance</span><span class="o">&lt;</span><span class="n">G</span><span class="o">:</span><span class="w"> </span><span class="n">Graph</span><span class="o">&gt;</span><span class="p">(</span><span class="n">graph</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">G</span><span class="o">::</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">G</span><span class="o">::</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>As shown, associated types make code more readable and also scalable, since traits can incorporate additional associated types without breaking code that doesn&rsquo;t care about them.</p>

<p>Currently, before associated types, traits' type parameters are considered either inputs or outputs, where the input type parameter determines which implementation to use and the output type parameter is determined by the implementation itself but otherwise plays no role in implementation selection.</p>

<p>Typically the only input type is <code>Self</code>, i.e. the type implementing the trait, while all other trait type parameters are outputs. It would be useful to be able to specify other input type parameters so that the implementation could be chosen depending on <code>Self</code> <em>and</em> the additional input type parameters.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="p">,</span><span class="w"> </span><span class="n">Sum</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Rhs</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Sum</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Add</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="nb">Add</span><span class="o">&lt;</span><span class="n">Complex</span><span class="p">,</span><span class="w"> </span><span class="n">Complex</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>This is impossible without this <abbr title="Request for Comments">RFC</abbr>, which implements the equivalent of Haskell&rsquo;s <a href="http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes#Multi-parameter_type_classes">multi-parameter type classes</a>, effectively treating all trait type parameters as input types and allowing output types to be specified via associated types. Specifying traits like this essentially defines a family of traits, one for each combination of input types (e.g. of <code>Rhs</code> in this example), each for which an implementation can be provided.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="c1">// Self and Rhs are input types</span>
<span class="c1">// Self is defined at the impl site,</span>
<span class="c1">// it&#39;s the type in `for T`</span>
<span class="k">trait</span><span class="w"> </span><span class="nb">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">type</span><span class="w"> </span><span class="n">Sum</span><span class="p">;</span><span class="w"> </span><span class="c1">// output type</span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Rhs</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Sum</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Sum = Self + Rhs</span>
<span class="c1">// int = int  + Complex</span>
<span class="k">impl</span><span class="w"> </span><span class="nb">Add</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">type</span><span class="w"> </span><span class="n">Sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Complex = int + Complex</span>
<span class="k">impl</span><span class="w"> </span><span class="nb">Add</span><span class="o">&lt;</span><span class="n">Complex</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">type</span><span class="w"> </span><span class="n">Sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Complex</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// or fn add(&amp;self, rhs: &amp;Complex) -&gt; Sum { ... }</span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Complex</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Equality constraints and trait bounds can be provided for associated types using where clauses.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">type</span><span class="w"> </span><span class="n">A</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// associated type A must implement Show</span>
<span class="k">fn</span><span class="w"> </span><span class="n">print_iter</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="o">:</span><span class="w"> </span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">I</span><span class="o">:</span><span class="w"> </span><span class="nb">Iterator</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="o">::</span><span class="n">A</span><span class="o">:</span><span class="w"> </span><span class="n">Show</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="c1">// associated type must be uint (i.e. specialization)</span>
<span class="k">fn</span><span class="w"> </span><span class="n">sum_uints</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="o">:</span><span class="w"> </span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">I</span><span class="o">:</span><span class="w"> </span><span class="nb">Iterator</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="o">::</span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="c1">// or sugar</span>
<span class="k">fn</span><span class="w"> </span><span class="n">sum_uints</span><span class="o">&lt;</span><span class="n">I</span><span class="o">:</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">iter</span><span class="o">:</span><span class="w"> </span><span class="n">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>When using a trait as a type (e.g. trait object) then all input and output types must be provided as part of the type.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">consume_obj</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">IT1</span><span class="p">,</span><span class="w"> </span><span class="n">IT2</span><span class="p">,</span><span class="w"> </span><span class="n">OT1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">OT2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="nl">&#39;a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nl">&#39;static</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"></span>
</code></pre></figure>
<p>All associated items are also allowed in inherent implementations, i.e. implementations for a particular struct. However, output constraints don&rsquo;t make sense for inherent outputs. In inherent implementations, associated types act more like type aliases with the added benefit that the associated types can be referred to using path syntax without having to import the modules that define those types.</p>
<h3 id="associated-statics">
<span class="hash">#</span>
<a href="#associated-statics" class="header-link">Associated Statics</a>
</h3>
<p>Currently, without associated statics, numeric traits like <code>Float</code> need to expose constants as static functions&mdash;which would be useful when writing a function generic over the type of <code>Float</code>&mdash;but these functions can&rsquo;t be used in static initializers, so modules for the numeric type implementation (e.g. <code>f64</code>) also export a separate set of statics outside of traits. Associated statics allow statics to be declared within traits.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Float</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">NAN</span><span class="o">:</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">INFINITY</span><span class="o">:</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">PI</span><span class="o">:</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">TWO_PI</span><span class="o">:</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p><a href="#where-clauses">Where clauses</a> can be used within object types using a type-parameterization syntax.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="c1">// create and get reference to an Iterator for int</span>
<span class="o">&amp;</span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">where</span><span class="w"> </span><span class="n">E</span><span class="o">=</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"></span>
</code></pre></figure><h2 id="drop">
<span class="hash">#</span>
<a href="#drop" class="header-link">Drop</a>
</h2>
<p>The <code>Drop</code> trait can be used to define destructors via its method <code>drop</code>. The global <code>drop</code> function also exists which essentially takes ownership of the passed value so that the moved variable&rsquo;s destructor&mdash;its <code>drop</code> method&mdash;is called by the end of the function scope. Destructors are run in top-down order, so that the value is completely destroyed before any values it owns run their destructors.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">struct</span><span class="w"> </span><span class="n">TimeBomb</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">explosivity</span><span class="o">:</span><span class="w"> </span><span class="kt">uint</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">TimeBomb</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nb">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">explosivity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nb">println</span><span class="p">(</span><span class="s">&quot;boom&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h2 id="clone">
<span class="hash">#</span>
<a href="#clone" class="header-link">Clone</a>
</h2>
<p>The <code>Clone</code> trait can be implemented to support copying of types via the <code>clone</code> method.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[deriving(Clone,Show)]</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">Pair</span><span class="p">(</span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pair</span><span class="p">(</span><span class="k">box</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">box</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">cloned_pair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="nb">drop</span><span class="p">(</span><span class="n">pair</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;clone: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cloned_pair</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h2 id="operator-overloading">
<span class="hash">#</span>
<a href="#operator-overloading" class="header-link">Operator Overloading</a>
</h2>
<p>Most operators are implemented as functions and can be overloaded by implementing the <a href="http://doc.rust-lang.org/core/ops/">appropriate traits</a>. For example, the <code>Add</code> trait can be used to overload the <code>+</code> operator.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">struct</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Add</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h1 id="dynamically-sized-types">
<span class="hash">#</span>
<a href="#dynamically-sized-types" class="header-link">Dynamically Sized Types</a>
</h1>
<p><a href="DST">Dynamically Sized Types</a> [<a href="https://github.com/rust-lang/rust/issues/12938">metabug</a>] introduces two new types: <code>[T]</code> representing some number of instances of <code>T</code> laid out sequentially in memory with the exact number unknown to the compiler, and <code>Trait</code> representing some type <code>T</code> that implements the trait <code>Trait</code>.</p>

<p>Smart pointers, for example, can implement <code>Deref</code> and automatically dereference down to the base type that is indexable. Concretely, <code>r</code> of type <code>Rc&lt;[T]&gt;</code> would autoderef to <code>*r</code> which is of type <code>&amp;[T]</code> which is not indexable either and so would autoderef to <code>**r</code> which is of type <code>[T]</code> which <em>is</em> indexable, and so Rust indexes into that. The same thing is done for trait objects, where <code>Rc&lt;Trait&gt;</code> is derefed to <code>&amp;Trait</code>.</p>
<h1 id="tasks">
<span class="hash">#</span>
<a href="#tasks" class="header-link">Tasks</a>
</h1>
<p>Tasks have dynamically sized stacks, starting out with small ones and dynamically growing as required. This means that unlike C/C++, it&rsquo;s not possible to write beyond the end of the stack. Tasks provide failure isolation and recovery. When a problem occurs, the runtime destroys the entire task, and other tasks can monitor each other for failure.</p>

<p>Tasks can&rsquo;t share mutable state with each other. Instead they communicate with each other by transferring owned data through the global <em>exchange heap</em>.</p>
<h2 id="spawning">
<span class="hash">#</span>
<a href="#spawning" class="header-link">Spawning</a>
</h2>
<p>Tasks are spawned with the <code>spawn</code> function which accepts a closure which is executed in a separate task. Creating tasks isn&rsquo;t defined at the language-level, but rather, inside the standard library.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">print_msg</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;running in diff task&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="nb">spawn</span><span class="p">(</span><span class="n">print_msg</span><span class="p">);</span><span class="w"></span>

<span class="c1">// or with lambda expression</span>
<span class="nb">spawn</span><span class="p">(</span><span class="k">proc</span><span class="p">()</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;also in diff task&quot;</span><span class="p">));</span><span class="w"></span>
</code></pre></figure>
<p>Since the signature of the <code>spawn</code> function is <code>spawn(f: proc())</code>, it accepts only owned closures, which by extension can only contain owned data. For this reason, <code>spawn</code> can safely move the entire closure and its associated state to an entirely different task for execution. As with any closure, it can capture an environment that it carries across tasks:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">child_task_nr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generate_task_nr</span><span class="p">();</span><span class="w"></span>

<span class="nb">spawn</span><span class="p">(</span><span class="k">proc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;I am child number {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">child_task_nr</span><span class="p">);</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</code></pre></figure><h2 id="channels">
<span class="hash">#</span>
<a href="#channels" class="header-link">Channels</a>
</h2>
<p>Pipes are used for communication between tasks <sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup>. Each pipe is defined by a pair of endpoints: one for sending and another for receiving. In Rust, a channel is the <em>sending</em> endpoint of a pipe and the <em>port</em> is the receiving endpoint.</p>

<p>The following code creates a channel for sending and receiving <code>int</code> types. Note that <code>Sender</code> and <code>Receiver</code> are both sendable types that may be captured into task closures or transferred between them.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">Sender</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Receiver</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">comm</span><span class="o">::</span><span class="n">channel</span><span class="p">();</span><span class="w"></span>

<span class="nb">spawn</span><span class="p">(</span><span class="k">proc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expensive_computation</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>

<span class="n">other_expensive_computation</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">recv</span><span class="p">();</span><span class="w"></span>
</code></pre></figure>
<p>A regular <code>Sender</code> and <code>Receiver</code> created by <code>comm::channel</code> can&rsquo;t be used by more than one task. Attempting to do so leads to an error, since the first task to use it becomes its owner. Instead it&rsquo;s necessary to clone the given endpoint.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">comm</span><span class="o">::</span><span class="n">channel</span><span class="p">();</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="n">init_val</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// create a SharedChan</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">child_rx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tx</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="nb">spawn</span><span class="p">(</span><span class="k">proc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">child_rx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">expensive_computation</span><span class="p">(</span><span class="n">init_val</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">});</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">recv</span><span class="p">();</span><span class="w"></span>
</code></pre></figure>
<p>The above example is contrived and could&rsquo;ve been done with three separate channels:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">rxs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">::</span><span class="n">from_fn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">init_val</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">comm</span><span class="o">::</span><span class="n">channel</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="nb">spawn</span><span class="p">(</span><span class="k">proc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">some_expensive_computation</span><span class="p">(</span><span class="n">init_val</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="n">rx</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rxs</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">accum</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="o">|</span><span class="w"> </span><span class="n">accum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</code></pre></figure><h2 id="futures">
<span class="hash">#</span>
<a href="#futures" class="header-link">Futures</a>
</h2>
<p>Futures can be used for requesting a computation and getting the result later. In the code below, <code>sync::Future::spawn</code> immediately returns a <code>future</code> object whether or not the computation is complete. The result can be explicitly retrieve with the <code>get()</code> function, which blocks until the value becomes available. <strong>Note</strong> that the future is mutable so that it can save the result inside the object once the computation is complete.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">12586269025</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">delayed_fib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sync</span><span class="o">::</span><span class="n">Future</span><span class="o">::</span><span class="nb">spawn</span><span class="p">(</span><span class="k">proc</span><span class="p">()</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span><span class="w"></span>
<span class="n">something_else</span><span class="p">();</span><span class="w"></span>
<span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;fib(50) = {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">delayed_fib</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
</code></pre></figure><h2 id="arc">
<span class="hash">#</span>
<a href="#arc" class="header-link">Arc</a>
</h2>
<p>When wanting to share immutable data between tasks, it may be expensive to use a typical pipe as that would create a copy of the data on each transfer. For this it would be more efficient to use an Atomically Reference Counted wrapper, <code>Arc</code>, which is implemented in the <code>sync</code> library. <code>Arc</code> acts as a reference to shared data so that only the reference itself is shared and cloned.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sync</span><span class="o">::</span><span class="n">Arc</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vec</span><span class="o">::</span><span class="n">from_fn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f32</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">shared_numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">child_numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared_numbers</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="nb">spawn</span><span class="p">(</span><span class="k">proc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="n">local_numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">child_numbers</span><span class="p">.</span><span class="n">as_slice</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Work with the local numbers</span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h2 id="failure">
<span class="hash">#</span>
<a href="#failure" class="header-link">Failure</a>
</h2>
<p>Exceptions can be raised in Rust using the <code>panic!()</code> macro. Exceptions are unrecoverable within a single task. When an exception is raised, the task unwinds its stack, running destructors and freeing memory along the way, then exits.</p>

<p>However, tasks may notify each other of failure. The <code>try</code> function is similar to <code>spawn</code> but blocks until the child is finish, yielding a return value of <code>Result&lt;T, ()&gt;</code> <sup id="fnref5"><a href="#fn5" rel="footnote">5</a></sup> which has two variants: <code>Ok(T)</code> and <code>Err</code>. This <code>Result</code> can then be pattern-matched to determine the outcome of the task, with <code>Err</code> representing termination with an error. <strong>Note</strong> currently, it&rsquo;s not possible to retrieve a useful error value from the <code>Err</code> variant, since <code>try</code> always returns <code>()</code>:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">task</span><span class="o">::</span><span class="n">try</span><span class="p">(</span><span class="k">proc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">some_condition</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">calculate_result</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;oops!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>

<span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">is_err</span><span class="p">());</span><span class="w"></span>
</code></pre></figure><h1 id="errors">
<span class="hash">#</span>
<a href="#errors" class="header-link">Errors</a>
</h1>
<p>It can quickly become unwieldly to handle multiple kinds of error types. For example, your application might define its own error type for a particular task, such as a service API, but the lower-level components that facilitate the API have their own error types as well, such as IO or more specifically network errors.</p>

<p>One solution to this is to define an enum with a variant for each kind of error type possible for a particular action (e.g. API requests). The <code>FromError</code> trait can be used to define how to convert from one error type to another, therefore allowing the <code>try!</code> macro to work with any that can be converted to a common type.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">enum</span><span class="w"> </span><span class="n">MyError</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Io</span><span class="p">(</span><span class="n">IoError</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="nb">Map</span><span class="p">(</span><span class="n">MapError</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// how to convert IoError to MyError</span>
<span class="k">impl</span><span class="w"> </span><span class="n">FromError</span><span class="o">&lt;</span><span class="n">IoError</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyError</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">from_error</span><span class="p">(</span><span class="n">err</span><span class="o">:</span><span class="w"> </span><span class="n">IoError</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">MyError</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// how to convert MapError to MyError</span>
<span class="k">impl</span><span class="w"> </span><span class="n">FromError</span><span class="o">&lt;</span><span class="n">MapError</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyError</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">from_error</span><span class="p">(</span><span class="n">err</span><span class="o">:</span><span class="w"> </span><span class="n">MapError</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">MyError</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Map</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">open_and_map</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">MyError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try</span><span class="o">!</span><span class="p">(</span><span class="n">File</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">Path</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;foo.txt&quot;</span><span class="p">)));</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try</span><span class="o">!</span><span class="p">(</span><span class="n">MemoryMap</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]));</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>The <code>Error</code> trait can be used to provide uniform base functionality for errors. The <code>description</code> method is the only necessary one and it yields a very short string that identifies the error type, and so is usually a static string. The <code>detail</code> method, if implemented, yields a string that is much more descriptive of the actual error, usually including dynamic information, hence the <code>String</code> return type.</p>

<p>The <code>cause</code> method, if implemented, can yield the lower-level cause for the current error, allowing for the possibility of maintaining a chain of errors which led to the current one. For example, an API service error type might include a network error as its cause if a request failed for that reason.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Error</span><span class="o">:</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">description</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">detail</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">cause</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure><h1 id="iterators">
<span class="hash">#</span>
<a href="#iterators" class="header-link">Iterators</a>
</h1>
<p>Iterators can be created by implementing the <code>Iterator</code> trait, particularly its <code>next</code> method. Notice that an <code>Option</code> is returned to indicate whether or not the iterator has finished, which is signified by yielding <code>None</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">struct</span><span class="w"> </span><span class="n">ZeroStream</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">remaining</span><span class="o">:</span><span class="w"> </span><span class="kt">uint</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">ZeroStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">new</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="kt">uint</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">ZeroStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ZeroStream</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">remaining</span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ZeroStream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">remaining</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nb">None</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="bp">self</span><span class="p">.</span><span class="n">remaining</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="nb">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ZeroStream</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">print</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// prints &quot;000&quot;</span>
</code></pre></figure>
<p>Iterators can be transformed by adaptors that themselves return another iterator:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;one&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;three&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;four&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;five&quot;</span><span class="p">];</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">zip</span><span class="p">(</span><span class="n">ys</span><span class="p">.</span><span class="n">iter</span><span class="p">());</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{} {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">h</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Iterators offer a generic conversion to containers with the <code>collect</code> adaptor. This method is provided by the <code>FromIterator</code> trait:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">ys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xs</span><span class="p">.</span><span class="n">rev_iter</span><span class="p">().</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">collect</span><span class="o">::&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"></span>
</code></pre></figure><h1 id="macros">
<span class="hash">#</span>
<a href="#macros" class="header-link">Macros</a>
</h1>
<p>Rust has support for advanced <a href="http://en.wikipedia.org/wiki/Hygienic_macro">hygienic macros</a>. Macros are defined using the <code>macro_rules!</code> syntax extension which is followed by the macro name. Its body consists of pattern matching cases, where the <abbr title="Left-Hand Side">LHS</abbr> is the macro invocation syntax (how macro is called) and the <abbr title="Right-Hand Side">RHS</abbr> is the macro transcription syntax (what macro expands to).</p>

<p>The macro definition can be surrounded by parentheses, brackets, or braces. Regardless of what was used in the definition, the macro can be invoked using either one as well, such as <code>vec![]</code> or <code>vec!()</code>. By convention, braces are used for blocks and parentheses for one-liners.</p>

<p>The macro invocation syntax must be surrounded by parentheses and the parentheses, brackets, or braces contained within must be balanced. Everything contained in the parentheses that isn&rsquo;t prefixed by <code>$</code> is taken literally, so that the same thing must be repeated at the call-site in order to match.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="c1">// the following</span>
<span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">my_macro</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="cp">$x</span><span class="o">:</span><span class="n">ident</span><span class="w"> </span><span class="n">verbatim</span><span class="w"> </span><span class="cp">$e</span><span class="o">:</span><span class="n">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// means it could be invoked as</span>
<span class="n">my_macro</span><span class="o">!</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="n">verbatim</span><span class="w"> </span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
</code></pre></figure>
<p>Items prefixed by <code>$</code> are ways to refer to different types of syntax such as identifiers, expressions, types, and so on. The <code>$</code> is followed by a name to give it within the transcription syntax body followed by the fragment specifier.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Designator</th>
<th style="text-align: left">Type</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>block</code></td>
<td style="text-align: left">code block</td>
</tr>
<tr>
<td style="text-align: left"><code>expr</code></td>
<td style="text-align: left">expressions</td>
</tr>
<tr>
<td style="text-align: left"><code>ident</code></td>
<td style="text-align: left">identifiers</td>
</tr>
<tr>
<td style="text-align: left"><code>item</code></td>
<td style="text-align: left"><a href="http://doc.rust-lang.org/rust.html#items">crate component</a></td>
</tr>
<tr>
<td style="text-align: left"><code>matchers</code></td>
<td style="text-align: left"><abbr title="Left-Hand Side">LHS</abbr> of <code>=&gt;</code> in macro</td>
</tr>
<tr>
<td style="text-align: left"><code>pat</code></td>
<td style="text-align: left">patterns</td>
</tr>
<tr>
<td style="text-align: left"><code>path</code></td>
<td style="text-align: left">module path</td>
</tr>
<tr>
<td style="text-align: left"><code>stmt</code></td>
<td style="text-align: left">statement</td>
</tr>
<tr>
<td style="text-align: left"><code>tt</code></td>
<td style="text-align: left"><abbr title="Right-Hand Side">RHS</abbr> of <code>=&gt;</code> in macro</td>
</tr>
<tr>
<td style="text-align: left"><code>ty</code></td>
<td style="text-align: left">types</td>
</tr>
</tbody>
</table>

<p>The <code>tt</code> specifier seems to refer to token tree, and it seems to refer to code within a block&rsquo;s delimiters <code>{}</code>. It&rsquo;s used for implementing macros that are <a href="https://github.com/rust-lang/rust/pull/12497">called with code blocks</a>, reminiscent of the removed do-notation syntax.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">expr</span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="cp">$e</span><span class="o">:</span><span class="w"> </span><span class="n">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cp">$e</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">)</span><span class="w"></span>

<span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="nb">spawn</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="cp">$($code</span><span class="o">:</span><span class="w"> </span><span class="n">tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">expr</span><span class="o">!</span><span class="p">(</span><span class="nb">spawn</span><span class="p">(</span><span class="k">proc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cp">$($code</span><span class="p">)</span><span class="o">*</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="nb">spawn</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">info</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;stmt&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></figure>
<p>The patterns may also contain the syntax <code>$(...)*</code> or <code>$(...)+</code> which expresses that the pattern contained must appear zero or more times, or one or more times, respectively&mdash;as in regular expressions. This special syntax may be also specify a separator token after the closing parenthesis but before the match-type discriminator, i.e. <code>$(...),*</code> would be repeatable and comma-separated.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="c1">// from RFC 163: https://github.com/rust-lang/rfcs/pull/163</span>
<span class="c1">// returns true if the expression matches the pattern</span>
<span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">matches</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="cp">$expression</span><span class="o">:</span><span class="w"> </span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="cp">$($pattern</span><span class="o">:</span><span class="n">pat</span><span class="p">)</span><span class="o">|*</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="cp">$expression</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="cp">$($pattern</span><span class="o">:</span><span class="w"> </span><span class="n">pat</span><span class="p">)</span><span class="o">|+</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">true</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">input</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">   </span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">char_at</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">   </span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">char_at</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">..</span><span class="sc">&#39;9&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// parse signed number</span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Macros may expand to expressions, items, or statements depending on the arguments it was invoked with and the location at which it was invoked.</p>

<p>The transcription syntax body must be enclosed by delimiters&mdash;parentheses, brackets, or braces&mdash;which are ignored. The contents of the delimiters must contain regular Rust syntax or interpolated fragments.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="cp">$x</span><span class="o">:</span><span class="n">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">$x</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="cp">$x</span><span class="o">:</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="cp">$($y</span><span class="o">:</span><span class="n">expr</span><span class="p">),</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cmp</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="cp">$x</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="o">!</span><span class="p">(</span><span class="cp">$($y</span><span class="p">),</span><span class="o">+</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="o">!</span><span class="p">(</span><span class="mi">5</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="n">u</span><span class="p">));</span><span class="w"></span>
</code></pre></figure><h2 id="syntax-extensions">
<span class="hash">#</span>
<a href="#syntax-extensions" class="header-link">Syntax Extensions</a>
</h2>
<p>There are a variety of built-in syntax extensions which expand to expressions with values.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Extension</th>
<th style="text-align: left">Purpose</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>format!</code></td>
<td style="text-align: left">format data into a string</td>
</tr>
<tr>
<td style="text-align: left"><code>env!</code></td>
<td style="text-align: left">lookup env-var at compile-time</td>
</tr>
<tr>
<td style="text-align: left"><code>file!</code></td>
<td style="text-align: left">path to file being compiled</td>
</tr>
<tr>
<td style="text-align: left"><code>stringify!</code></td>
<td style="text-align: left">pretty-print Rust expression</td>
</tr>
<tr>
<td style="text-align: left"><code>include!</code></td>
<td style="text-align: left">include expression in given file</td>
</tr>
<tr>
<td style="text-align: left"><code>include_str!</code></td>
<td style="text-align: left">include contents of file as string</td>
</tr>
<tr>
<td style="text-align: left"><code>include_bin!</code></td>
<td style="text-align: left">include contents of file as binary</td>
</tr>
<tr>
<td style="text-align: left"><code>info!</code></td>
<td style="text-align: left">print diagnostics. also <code>error!</code>, <code>warn!</code>, and <code>debug!</code></td>
</tr>
</tbody>
</table>
<h1 id="foreign-function-interface">
<span class="hash">#</span>
<a href="#foreign-function-interface" class="header-link">Foreign Function Interface</a>
</h1>
<p>The <code>extern</code> block can be used to list function signatures in a foreign library, and is usually paired with a <code>link</code> attribute to link against the library in question. Foreign functions are considered unsafe, so they must be wrapped in <code>unsafe</code>, which essentially tells the compiler that everything within is truly safe.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[link(name = </span><span class="s">&quot;snappy&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">snappy_max_compressed_length</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">source_length</span><span class="o">:</span><span class="w"> </span><span class="n">size_t</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">size_t</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">snappy_compress</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">input</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">input_length</span><span class="o">:</span><span class="w"> </span><span class="n">size_t</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">compressed</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">compressed_length</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">size_t</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">c_int</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>The <code>link_name</code> attribute could be used to specify an alternative function name, which is useful when a function collides with the Rust namespace.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">extern</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// reference exit(i32) as die(i32)</span>
<span class="w">  </span><span class="cp">#[link_name = </span><span class="s">&quot;exit&quot;</span><span class="cp">]</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">die</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">die</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>To avoid requiring <code>unsafe</code> blocks at the call-site, safe wrappers are usually created with native Rust types.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">compress</span><span class="p">(</span><span class="n">src</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">srclen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">size_t</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">psrc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">dstlen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">snappy_max_compressed_length</span><span class="p">(</span><span class="n">srclen</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vec</span><span class="o">::</span><span class="n">with_capacity</span><span class="p">(</span><span class="n">dstlen</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">uint</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pdst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dst</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">snappy_compress</span><span class="p">(</span><span class="n">psrc</span><span class="p">,</span><span class="w"> </span><span class="n">srclen</span><span class="p">,</span><span class="w"> </span><span class="n">pdst</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">dstlen</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dst</span><span class="p">.</span><span class="n">set_len</span><span class="p">(</span><span class="n">dstlen</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">uint</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dst</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Rust functions can be made available to C code, such as for callbacks, by marking them as <code>extern</code> with the correct calling convention.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">extern</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">callback</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;I&#39;m called from C with the value {0}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[link(name = </span><span class="s">&quot;extlib&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">register_callback</span><span class="p">(</span><span class="n">cb</span><span class="o">:</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">trigger_callback</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">register_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">trigger_callback</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>The <code>link</code> attribute can take a <code>kind</code> argument that specifies the type of library being linked. If the <code>kind</code> argument is not provided, it is assumed to be dynamic. Otherwise, the <code>kind</code> may be <code>static</code> or, if on OS X, <code>framework</code>.</p>

<p>Linked static libraries are included within the output crate. Dynamic dependencies (and OS X frameworks), however, aren&rsquo;t linked until the rlib is included in the final target (e.g. binary).</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[link(name = </span><span class="s">&quot;dependency&quot;</span><span class="cp">, kind = </span><span class="s">&quot;static&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="cp">#[link(name = </span><span class="s">&quot;CoreFoundation&quot;</span><span class="cp">, kind = </span><span class="s">&quot;framework&quot;</span><span class="cp">)]</span><span class="w"></span>
</code></pre></figure>
<p>Global variables must also be declared within <code>extern</code> blocks before they&rsquo;re accessible. They may also be marked as <code>mut</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[link(name = </span><span class="s">&quot;readline&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">rl_readline_version</span><span class="o">:</span><span class="w"> </span><span class="n">libc</span><span class="o">::</span><span class="n">c_int</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">rl_prompt</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="n">libc</span><span class="o">::</span><span class="n">c_char</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;readline version {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rl_readline_version</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="s">&quot;&gt;&gt; &quot;</span><span class="p">.</span><span class="n">with_c_str</span><span class="p">(</span><span class="o">|</span><span class="n">buf</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">rl_prompt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// get a line</span>
<span class="w">  </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">rl_prompt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="o">::</span><span class="n">null</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">})</span><span class="w"></span>
</code></pre></figure>
<p>The <code>extern</code> keyword can also take as argument a calling convention to use with the contained function declarations. The <code>system</code> calling convention selects the appropriate calling convention for interoperating with the target&rsquo;s libraries, e.g. <code>stdcall</code> on x86 or <code>C</code> on x86_64.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[link(name = </span><span class="s">&quot;kernel32&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;stdcall&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">SetEnvironmentVariableA</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">libc</span><span class="o">::</span><span class="n">c_int</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Structures are guaranteed to be compatible with the platform&rsquo;s representation in C. Since strings aren&rsquo;t null terminated, the <code>c_str::to_c_str</code> function is used to null-terminate them.</p>
<h1 id="unsafe">
<span class="hash">#</span>
<a href="#unsafe" class="header-link">Unsafe</a>
</h1>
<p>The <code>unsafe</code> blocks are mainly used for dereferencing raw pointers, calling <abbr title="Foreign Function Interface">FFI</abbr> functions, casting types in a bitwise manner using <code>transmute</code>, and inline assembly.</p>

<p>There are two additional raw pointer types that are an approximation of pointer types in C, namely <code>*const T</code> which is an approximation of <code>const T*</code> and <code>*mut T</code> is an approximation of <code>T*</code>.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Rust</th>
<th style="text-align: left">C</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>*const T</code></td>
<td style="text-align: left"><code>const T*</code></td>
</tr>
<tr>
<td style="text-align: left"><code>*mut T</code></td>
<td style="text-align: left"><code>T*</code></td>
</tr>
</tbody>
</table>

<p>Rust pointer types aren&rsquo;t guaranteed to not be null or even to point to valid memory, nor do they also don&rsquo;t implement <abbr title="Resource Allocation Is Initialization">RAII</abbr> for automatic resource management, like <code>Box</code>. Raw pointers are considered plain-old-data, and don&rsquo;t have a notion of move ownership so that Rust can&rsquo;t protect against bugs like use-after-free. Raw pointers are also considered sendable, allowing them to be access from multiple concurrent threads without synchronization.</p>

<p>Dereferencing raw pointers is only possible within <code>unsafe</code> blocks, since it may result in crashes. Pointer arithmetic also needs to be within <code>unsafe</code> blocks. Creating a raw pointer or converting one to an integer is not unsafe.</p>

<p>At run-time, raw pointers <code>*</code> and references <code>&amp;</code> pointing to the same data have identical representations. A <code>&amp;T</code> reference implicitly coerces to raw pointer <code>*const T</code> in safe code, and can even be made explicit as <code>value as *const T</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="c1">// explicit</span>
<span class="kd">let</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">p_imm</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>

<span class="c1">// implicit</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">m</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">p_mut</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p>However, the reverse isn&rsquo;t true, since a reference <code>&amp;</code> is always valid, but a <code>*const T</code> may not be, since the pointed object has to be a valid instance of the correct type and it must satisfy the aliasing and mutability laws of references. Raw pointers can be converted back to references by using the <code>&amp;*p</code> syntax where <code>p</code> must be a pointer.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">ref_imm</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;*</span><span class="n">p_imm</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">ref_mut</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="n">p_mut</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Inline assembly is possible via the <code>asm!</code> macro which requires the <code>asm</code> feature and must be within an <code>unsafe</code> block. The template parameter is the only one that is required.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="n">template</span><span class="w"></span>
<span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="n">output</span><span class="w"></span>
<span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="n">input</span><span class="w"></span>
<span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="n">clobbers</span><span class="w"></span>
<span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="n">options</span><span class="p">);</span><span class="w"></span>
</code></pre></figure>
<p>Input and output operands consist of <code>constraint(expr)</code> <a href="https://gcc.gnu.org/onlinedocs/gcc/Constraints.html">as in GCC</a>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;add $2, $0&quot;</span><span class="w"></span>
<span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;0&quot;</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="p">);</span><span class="w"></span>
</code></pre></figure>
<p>Clobbers are used to list registers that may have been modified by the assembly code. If the code changes the condition code register or modifies memory, <code>cc</code> and <code>memory</code> should be specified in the clobbers list respectively.</p>

<p>Inputs and outputs are omitted from the following code as they&rsquo;re not required by the assembly code, and no whitespace is necessary between the colon delimiters.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="c1">// put 0x200 in eax</span>
<span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;mov $$0x200, %eax&quot;</span><span class="w"> </span><span class="o">:::</span><span class="w"> </span><span class="s">&quot;eax&quot;</span><span class="p">);</span><span class="w"></span>
</code></pre></figure>
<p>The final parameter is a list of options to apply to the assembly code, such as <code>volatile</code>, <code>alignstack</code> to align the stack, or <code>intel</code> to use Intel syntax.</p>

<p>The standard library <code>std</code> can be avoided by using the <code>no_std</code> attribute. Further, the entry point can be modified by applying the <code>start</code> attribute to what will be the entry point.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#![no_std]</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">libc</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[start]</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">start</span><span class="p">(</span><span class="n">_argc</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">_argv</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="o">*</span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>Alternatively, the compiler-inserted <code>main</code> shim can be disabled and overridden using the <code>no_main</code> attribute. Another one must then be provided with the correct name and bypassing compiler name mangling.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#![no_std]</span><span class="w"></span>
<span class="cp">#![no_main]</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">libc</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[no_mangle]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="n">_argc</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">_argv</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="o">*</span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>There are also two functions that are normally provided by the standard library must de defined. The <code>stack_exhausted</code> function is called whenever a stack overflow is detected, and the <code>eh_personality</code> function is used by the failure mechanisms of the compiler.</p>

<p>The <a href="http://doc.rust-lang.org/core/"><code>libcore</code></a> library provides the minimum necessary functionality for writing idiomatic Rust.</p>

<p>Lang items are pluggable operations that aren&rsquo;t hard-coded into the language but instead implemented in libraries. The <code>lang</code> attribute is used to inform the compiler of a given implementation.</p>

<p>The <a href="http://doc.rust-lang.org/core/intrinsics/ffi.transmute.html"><code>transmute</code></a> function is essentially like C&rsquo;s <a href="http://en.cppreference.com/w/cpp/language/reinterpret_cast"><code>reinterpret_cast</code></a>. Both types must have the same size and alignment.</p>
<h1 id="comments">
<span class="hash">#</span>
<a href="#comments" class="header-link">Comments</a>
</h1>
<p>Comments are available in single and multi-line variants as in C. Single line comments with three slashes <code>///</code> and multi-line comments with one extra asterisk <code>/**</code> are interpreted as documentation</p>
<h1 id="testing">
<span class="hash">#</span>
<a href="#testing" class="header-link">Testing</a>
</h1>
<p>Test functions are marked with the <code>test</code> attribute and use the <code>assert!</code> macro for asserting conditions. Test functions must not have any arguments or return values. A test is considered successful if the function returns, and fails if the test fails through <code>panic!</code>, <code>assert</code>, or any other means.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="k">fn</span><span class="w"> </span><span class="n">return_two</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="cp">#[test]</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">return_two_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">return_two</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>For tests to be run, the crate has to be compiled with the <code>--test</code> flag. The resulting executable will then run all tests.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-bash"><span class="nv">$ </span>rustc --test foo.rs
<span class="nv">$ </span>./foo
running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test </span>return_two_test ... ok

<span class="nb">test </span>result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured
</code></pre></figure>
<p>The <code>--nocapture</code> flag can be provided to the test harness to prevent it from stealing standard output, so that tests can print messages to the terminal.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-bash"><span class="nv">$ </span>./foo --nocapture
<span class="nv">$ </span>cargo <span class="nb">test</span> -- --nocapture
</code></pre></figure>
<p>The <code>ignore</code> attribute can be used to specify that a test should not be run. The existence of the test will be noted in the runner&rsquo;s output. The <code>ignore</code> attribute can take a configuration value as predicate, to ignore a given test depending on a configuration value.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[ignore(cfg(target_os = </span><span class="s">&quot;win32&quot;</span><span class="cp">))]</span><span class="w"></span>
<span class="cp">#[test]</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">linux_test</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></figure>
<p>Tests that are intended to fail can be annotated with the <code>should_fail</code> attribute.</p>

<p>The test runner can take as argument a regular expression used to run the matching tests, and the <code>--ignored</code> flag can tell the runner to only run the ignored tests.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-bash"><span class="nv">$ </span>./foo sometest
<span class="nv">$ </span>cargo <span class="nb">test</span> -- sometest
</code></pre></figure>
<p>It&rsquo;s also possible to benchmark functions using the <code>bench</code> attribute. Benchmarks are compiled along with tests when compiled with the <code>--test</code> flag. Benchmark functions take as parameter a mutable reference to type <code>test::Bencher</code>. Setup should happen at the beginning of the function, and the actual code to be benchmarked should occur within a closure passed to <code>test::Bencher</code>&rsquo;s <code>iter</code> method.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[bench]</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">bench_sum_1024_ints</span><span class="p">(</span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Bencher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vec</span><span class="o">::</span><span class="n">from_fn</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="c1">// setup</span>
<span class="w">  </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">old</span><span class="p">,</span><span class="w"> </span><span class="n">new</span><span class="o">|</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">new</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>If measuring throughput, the <code>bytes</code> field of the <code>Bencher</code> can be set to the bytes consumed/produced in each iteration.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[bench]</span><span class="w"></span>
<span class="k">fn</span><span class="w"> </span><span class="n">initialize_vector</span><span class="p">(</span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Bencher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">Vec</span><span class="o">::</span><span class="n">from_elem</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="k">u64</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">b</span><span class="p">.</span><span class="n">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>The <code>--bench</code> flag must be passed to the compiled test-runner to run the benchmarks.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-bash"><span class="nv">$ </span>rustc mytests.rs -O --test
<span class="nv">$ </span>mytests --bench

running <span class="m">2</span> tests
<span class="nb">test </span>bench_sum_1024_ints ... bench: <span class="m">709</span> ns/iter <span class="o">(</span>+/- 82<span class="o">)</span>
<span class="nb">test </span>initialise_a_vector ... bench: <span class="m">424</span> ns/iter <span class="o">(</span>+/- 99<span class="o">)</span> <span class="o">=</span> <span class="m">19320</span> MB/s

<span class="nb">test </span>result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">2</span> measured
</code></pre></figure>
<p>It&rsquo;s possible that the optimizer might optimize away what is being measured. One way to avoid this is to have the closure return a value or to wrap the contents in <code>test::black_box</code>, which forces the optimizer to consider any argument used. Larger values can be passed by reference to <code>black_box</code> for efficiency.</p>

<p>The testsuite supports ratcheting against a metrics file, which basically compares benchmark results with previously saved results and considers it a regression if the results are worse by a certain noise value. This is possible through the <code>--save-metrics=file.json</code> parameter to save the results, and the <code>--ratchet-metrics=file.json</code> parameter to ratchet the results against those saved in the specified file.</p>
<h1 id="cargo">
<span class="hash">#</span>
<a href="#cargo" class="header-link">Cargo</a>
</h1>
<p><a href="http://crates.io/">Cargo</a> is the package manager for Rust, which actually reminds me a lot of Haskell&rsquo;s <a href="http://www.haskell.org/cabal/">Cabal</a>. The package configuration is defined in a <span class="path">Cargo.toml</span> file which is written in <a href="https://github.com/toml-lang/toml">TOML</a> format. The TOML file <a href="http://crates.io/manifest.html">contains</a> a <code>package</code> section which establishes the project&rsquo;s metadata. A <code>[[bin]]</code> section can also be created to specify that the target is to be a binary, as well as information pertaining to it, such as its name.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-toml"><span class="p">[</span><span class="n">package</span><span class="p">]</span>

<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;hello_world&quot;</span>
<span class="n">version</span> <span class="o">=</span> <span class="s">&quot;0.1.0&quot;</span>
<span class="n">authors</span> <span class="o">=</span> <span class="p">[</span> <span class="s">&quot;someone@example.com&quot;</span> <span class="p">]</span>

<span class="p">[[</span><span class="n">bin</span><span class="p">]]</span>

<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;hello_world&quot;</span>
</code></pre></figure>
<p>The project can then be built using the <code>build</code> command.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-bash"><span class="nv">$ </span>cargo build
   Compiling hello_world v0.1.0 <span class="o">(</span>file:/home/yourname/projects/hello_world<span class="o">)</span>
<span class="nv">$ </span>./target/hello_world
Hello, world!
</code></pre></figure>
<p>Dependencies may be expressed by adding sections of the form <code>[dependency.name]</code> with a property of type <code>git</code> or <code>path</code> with the appropriate path.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-toml"><span class="p">[</span><span class="n">dependencies</span><span class="p">.</span><span class="n">color</span><span class="p">]</span>

<span class="n">git</span> <span class="o">=</span> <span class="s">&quot;https://github.com/bjz/color-rs&quot;</span>
</code></pre></figure><h1 id="printing">
<span class="hash">#</span>
<a href="#printing" class="header-link">Printing</a>
</h1>
<p>Use the <code>print!</code>, <code>println!</code>, and <code>write!</code> macros to print strings in a <code>printf</code>-like manner. If just printing an actual string, then just use the direct functions <code>print</code> and <code>println</code>. The <code>format!</code> macro also exists for creating a <code>String</code> with a specific format. See the docs for <a href="http://static.rust-lang.org/doc/master/std/fmt/index.html"><code>std::fmt</code></a> for more information.</p>
<h1 id="input">
<span class="hash">#</span>
<a href="#input" class="header-link">Input</a>
</h1>
<p>Simple input can be achieved using the <code>io::stdin()</code> function to retrieve a <a href="http://doc.rust-lang.org/std/io/struct.BufferedReader.html"><code>BufferedReader</code></a> which has functions such as <code>read_line()</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="kd">let</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="o">::</span><span class="n">stdin</span><span class="p">().</span><span class="n">read_line</span><span class="p">().</span><span class="n">ok</span><span class="p">().</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;failed to read line&quot;</span><span class="p">);</span><span class="w"></span>
<span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">);</span><span class="w"></span>
</code></pre></figure><h1 id="documentation">
<span class="hash">#</span>
<a href="#documentation" class="header-link">Documentation</a>
</h1>
<p>A built-in tool called <code>rustdoc</code> can be used to generate documentation, similar to <a href="/notes/haskell#documentation">haddock</a> with Haskell. Documentation is primarily provided using &ldquo;doc comments&rdquo; which are simply line comments of three forward slashes: <code>///</code>. If a <code>//!</code> comment is used, it applies to the parent of the comment rather than what follows. Doc comments are implicitly converted to <code>doc</code> attributes by the compiler, which themselves may be used explicitly as well.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="c-Doc">/// this documentation applies to S</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c-Doc">//! this documentation applies to `test`</span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[doc = </span><span class="s">&quot;</span>
<span class="s">Calculates the factorial of a number.</span>
<span class="s">&quot;</span><span class="cp">]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>The <code>doc</code> attribute can also be used to control how documentation is emitted, such as to prevent inlining documentation of a <code>pub use</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[doc(no_inline)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">option</span><span class="o">::</span><span class="nb">Option</span><span class="p">;</span><span class="w"></span>
</code></pre></figure>
<p>Code examples can be provided within documentation as regular code blocks, and those marked as being Rust code can be tested using the <code>--test</code> option with <code>rustdoc</code>. The <code>ignore</code> directive can be provided instead of a language to not run that code block but still highlight it as rust. The <code>should_fail</code> directive specifies that the code block is expected to fail, and thus shouldn&rsquo;t be considered an error when testing. The <code>no_run</code> directive specifies that the code block should be compiled but not run. The <code>test_harness</code> directive compiles the code as if <code>--test</code> were passed to the compiler.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="w">  </span><span class="err">```</span><span class="w"> </span><span class="n">rust</span><span class="p">{.</span><span class="n">example</span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// some code</span>
<span class="w">  </span><span class="err">```</span><span class="w"></span>

<span class="w">  </span><span class="err">```</span><span class="w"> </span><span class="n">test_harness</span><span class="w"></span>
<span class="w">  </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;runs and registers as failure&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="err">```</span><span class="w"></span>
</code></pre></figure>
<p>Tests are facilitated by implicitly adding <code>extern crate doc-target</code> at the top of each code example.</p>

<p>If a line is prefixed with <code>#</code>, then the line won&rsquo;t show up in the resulting HTML but it <em>will</em> be used when testing the code block.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="w">  </span><span class="err">```</span><span class="w"></span>
<span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nb">spawn</span><span class="p">(</span><span class="k">proc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">  </span><span class="err">```</span><span class="w"></span>
</code></pre></figure>
<p>API stability can be documented by using stability attributes. There are six stability levels, where levels <em>stable</em>, <em>frozen</em>, and <em>locked</em> convey a guarantee of backwards-compatibility. The levels are listed below in order of increasing stability.</p>

<table>
<thead>
<tr>
<th style="text-align: left">Level</th>
<th style="text-align: left">Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">deprecated</td>
<td style="text-align: left">should no longer be used</td>
</tr>
<tr>
<td style="text-align: left">experimental</td>
<td style="text-align: left">may change or be removed</td>
</tr>
<tr>
<td style="text-align: left">unstable</td>
<td style="text-align: left">still under development</td>
</tr>
<tr>
<td style="text-align: left">stable</td>
<td style="text-align: left">will not change significantly</td>
</tr>
<tr>
<td style="text-align: left">frozen</td>
<td style="text-align: left">very stable; unlikely to change</td>
</tr>
<tr>
<td style="text-align: left">locked</td>
<td style="text-align: left">never change unless there are bugs</td>
</tr>
</tbody>
</table>

<p>Individual items such as functions and structs can be annotated with an API stability level of the form <code>#[level]</code>.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#[deprecated = </span><span class="s">&quot;was stupid to begin with&quot;</span><span class="cp">]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">learn_visual_basic</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[stable]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">use_rust</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></figure>
<p>When importing another crate, lints can be enabled to, for example, warn when a given item is used from it with a stability less than the one specified.</p>
<figure class="codeblock">
<pre>
<code class="highlight language-rust"><span class="cp">#![warn(unstable)]</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">other_crate</span><span class="p">;</span><span class="w"></span>
</code></pre></figure><h1 id="debugging">
<span class="hash">#</span>
<a href="#debugging" class="header-link">Debugging</a>
</h1>
<p>Existing debugging infrastructure such as <a href="/notes/gdb">GDB</a> can be used to debug Rust programs. It may be useful to set the optimization level to 0 and enable debugging symbols in Cargo using a development profile:</p>
<figure class="codeblock">
<pre>
<code class="highlight language-toml"><span class="p">[</span><span class="n">profile</span><span class="p">.</span><span class="n">dev</span><span class="p">]</span>
<span class="n">opt-level</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">debug</span> <span class="o">=</span> <span class="kc">true</span>
</code></pre></figure>
<p>There&rsquo;s also the <code>RUST_BACKTRACE</code> environment variable which, when set (e.g. to 1), will output a backtrace when a Rust program crashes.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>This of course reminds me of C++11&rsquo;s <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>In C++, an <code>&amp;</code> on the <abbr title="Left-Hand Side">LHS</abbr> can be the ref-qualifier, i.e. <em>bind by reference</em>, and on the <abbr title="Right-Hand Side">RHS</abbr> it can be the address-of operator.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>This is like Haskell&rsquo;s <a href="/notes/haskell#named-field-puns">named-field puns</a>.&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

<li id="fn4">
<p>Pipes remind me of Go&rsquo;s channels, or Haskell&rsquo;s.&nbsp;<a href="#fnref4" rev="footnote">&#8617;</a></p>
</li>

<li id="fn5">
<p>This <code>Result</code> type is a lot like Haskell&rsquo;s <code>Either</code>.&nbsp;<a href="#fnref5" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>
</div>
  <div class="meta">
    <div class="meta-component"><i class="fa fa-calendar fa-fw"></i> December 29, 2013</div>
    <div class="meta-component"><i class="fa fa-code-fork fa-fw"></i> <a href="https://github.com/blaenk/site/commits/master/input/notes/rust.markdown">History</a><span class="hash">, <a href="https://github.com/blaenk/site/commit/dc6ff87" title="new table marker syntax; no need for metadata

This means there's no need to separate the toc marker from its
configuration, i.e. alignment. This never should've been necessary.

This has the nice side-effect of naturally invalidating the cache when
the toc marker is moved around or its alignment is changed.
">dc6ff87</a></span></div>
    <div class="meta-component"><i class="fa fa-tags fa-fw"></i> null</div>
  </div>
</article>



    
    <footer id="footer">
  <div id="social">
    <a href="https://github.com/blaenk" title="github"><i class="fa fa-github-alt"></i></a>
    &middot;
    <a href="http://stackoverflow.com/users/101090/jorge-israel-pena" title="stackoverflow"><i class="fa fa-stack-overflow"></i></a>
    &middot;
    <a href="https://twitter.com/blaenk" title="twitter"><i class="fa fa-twitter"></i></a>
    &middot;
    <a href="mailto:jorge.israel.p@gmail.com" title="email"><i class="fa fa-envelope"></i></a>
    &middot;
    <a href="/rss.xml" title="feed"><i class="fa fa-rss-square"></i></a>
  </div>
  <!-- <div id="credit">
    Designed by <a href="http://www.blaenkdenum.com">Jorge Israel Peña</a>
  </div> -->
</footer>


<!-- this should instead be something like connectWS("{{{path}}}") -->


<script type="text/javascript">
  jQuery(function (){
    var ws = new WebSocket('ws://' + window.location.hostname + ':9160/notes/rust.markdown');

    ws.onmessage = function (e) {
      var content = jQuery('article .entry-content');
      content.html(e.data);

      window.refresh();

      MathJax.Hub.Queue(["Typeset", MathJax.Hub, content[0]]);
    };
  });
</script>




<!-- google analytics -->
<script async="true" type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37339861-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

<!--MathJax CDN-->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    messageStyle: "none"
  });

  MathJax.Hub.Register.MessageHook('End Process', function() {
    jQuery('#MathJax_Font_Test').empty();
    jQuery('.MathJax_Display').parent().addClass('mobile-math');
  });
</script>
<script async="true" type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>

  </div>
</body>
</html>
