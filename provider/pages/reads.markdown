---
title: Reads
published: July 5, 2013
comments: off
---

This is a list of books I've finished reading recently, in reverse chronological order. You can also see a list of books 
I'm [currently reading](/lately/#reading).

<hr class="book">

<img src="/images/books/kingkiller.jpg" class="right" width="128">

<a href="http://amzn.com/0756405890" name="kingkiller1">The Name of the Wind</a> --- After finishing two major series from Brandon Sanderson, I felt like changing it up and had heard very good things of Patrick Rothfuss' _Kingkiller Chronicles_. Like Sanderson, Rothfuss seems to be pretty new to epic fantasy but is already very well established and widely acclaimed.

I'm still going through the phase one goes through when approaching a new epic fantasy series, of getting acclimated to the world and understanding the different elements of it. The world reminds me more of GRRM's world in _A Song of Ice and Fire_ than Sanderson's worlds; it is dark and gritty.

<hr class="book">

<img src="/images/books/clojure-web-development.jpg" class="right" width="128">

<a href="http://amzn.com/1937785645" name="clojure-web">Web Development in Clojure</a> [[notes](/notes/clojure-web-development/)] --- Clojure has gained prominence in web development ranging from the back-end and even in the front-end via ClojureScript. After [learning about Clojure](#clojure), it made sense to learn about Clojure's web ecosystem. Clojure has a preference for mixing and matching individual libraries instead of going for heavy, monolithic frameworks.

This book covered Ring and Compojure, and also went over how the novel ways in which Clojure approaches templating, ClojureScript, and database interaction.

<hr class="book">

<img src="/images/books/swift.jpg" class="right" width="128">

<a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/TheBasics.html" name="swift">Swift</a> [[notes](/notes/swift/)] --- A new language for Mac OS X and iOS development has been anticipated for years, and not it's hear. Swift takes many of the ideas that are found in more advanced functional languages and incorporates them in the most pragmatic way I could have imagined with the intention that mainstream developers will easily be able to adapt to the new ideas.

This official book from Apple did a great job of covering the language, and left me admiring Swift for what it has managed to accomplish.

<hr class="book">

<img src="/images/books/clojure.jpg" class="right" width="128">

<a href="http://amzn.com/1449394701" name="clojure">Clojure Programming</a> [[notes](/notes/clojure/)] --- I've had a recent interest in JVM languages. I already looked into [Scala] and am unsure what I think of it so far. I like a lot of it but I feel like it's overly complex and context-dependent; it reminds me of C++. I decided to look into the other emerging JVM language, the lisp-like Clojure, and its level of simplicity and consistency feels refreshing in comparison.

One of my computer science professors once told me that the reason he likes [Scheme] is because he likes a language where he could easily wrap his head around its computational model so that he may work as effectively as possible. At the time I found his choice of words interesting, "computational model." Now that I'm learning Clojure and the so-called _special forms_ which are [sufficient to describe any possible computation], I understand what he means. I have to agree that the simplicity in this model is empowering.

*[JVM]: Java Virtual Machine
[Scala]: /notes/scala/
[Scheme]: http://en.wikipedia.org/wiki/Scheme_(programming_language)
[sufficient to describe any possible computation]: http://www.paulgraham.com/rootsoflisp.html

<hr class="book">

<img src="/images/books/mistborn3.jpg" class="right" width="128">

<a href="http://amzn.com/0765356147" name="mistborn3">Mistborn: The Hero of Ages</a> --- This is the sequel to [The Well of Ascension] and the third and final book in the original _Mistborn_ trilogy. The end of the second book completely changed the stakes of the world and now the characters must deal with the repercussions.

The world and characters are very different from how they were in the first book. By now the characters have been really developed from the events of the past two books and are efficiently and expertly attempting to deal with a problem that otherwise seems insurmountable to them. Meanwhile, those characters that seemed to have reached the extent of their development have experienced events that have catalyzed further development in ways that would seem uncharacteristic of how we knew them to be.

This is a very beautiful series. It has been tragic, nerve-racking, deep, funny, and heartwarming. There is a recurrent theme of attempting the impossible, of perseverance and determination in the face of apparently unequivocal doom. Of survival.

[The Well of Ascension]: /reads/#mistborn2

<hr class="book">

<img src="/images/books/play.jpg" class="right" width="128">

<a href="http://amzn.com/1617290793" name="play">Play for Scala</a> [[notes](/notes/play/)] --- So now that I [learned][Scala] about the _language_ I figured I'd read up on some of the main Scala libraries and frameworks. The nice thing about it is that it completely rethinks JVM web frameworks, outside of the constraints of the J2EE (over) architecture, whose problem was abstracting away HTTP instead of embracing it.

Play seems like a more performant alternative to Ruby on Rails. It runs on Java's NIO via Netty and is built with the Akka concurrency framework. The architecture of Play, from what I learned from the book, is very clean and straightforward; at no point did I get the feeling that there was clearly some magic going on under the hood like one does with Rails.

Scala tends to adopt advanced functional programming concepts from Haskell, and Play continues this tradition. For example, Play uses iteratees for streamed responses and WebSockets. I also really like the templating language that Play uses, which makes it about as powerful as Scala itself, without having to learn some other templating DSL and having to reconcile the two languages. All in all I have to say that Play seems like a pretty nice framework.

*[MVC]: Model-View-Controller
*[DSL]: Domain Specific Language

[Scala]: /notes/scala/

<hr class="book">

<img src="/images/books/wor.jpg" class="right" width="128">

<a href="http://amzn.com/0765326361" name="wor">Words of Radiance</a> --- This is the much anticipated sequel to [The Way of Kings] and the second book in the 10-book epic fantasy _Stormlight Archive_. It starts out with an alternate perspective on the event that catalyzed the events of tWoK. All of the characters---which were previously scattered throughout the world---are finally converging upon the same location, ramping up anticipation of their first interactions.

The magic that was misunderstood and scarce during the first book is slowly becoming more common, and some of the more scholarly characters are attempting to study it.

Sanderson is known to be a very prolific writer, writing thousands of words every day, teaching a university class on creative writing, and has had enough practice with world-building and meticulous story planning with _Mistborn_, the last few books of _Wheel of Time_, and various other independent books he has written. This is what he wants to be his legacy, what he has prepared for, and it really shows.

[The Way of Kings]: #wok

<hr class="book">

<img src="/images/books/mistborn2.jpg" class="right" width="128">

<a href="http://amzn.com/0765316889" name="mistborn2">Mistborn: The Well of Ascension</a> --- This is the sequel to _Mistborn: The Final Empire_. It's difficult to talk about this one without spoiling the first book. Suffice it to say that crazy things happen at the end of the first book and this book deals with the repercussions of those events. It seems like it's the least liked of the original trilogy, only because it seems to have gone a little slow---for a Brandon Sanderson book---at the beginning. I didn't really mind since I'm used to an even slower, seemingly undirected pace from GRRM's books, and it allowed me to really learn about some of the characters in-depth. Of course, the Sanderson Avalanche starts up towards the end so that even those who did find it to be their least favorite seem to agree that it redeems itself with it.

*[GRRM]: George RR Martin

One thing I really like about Sanderson is that everything he writes seems to have been very meticulously premeditated. An event comes to fruition at the end of this second book that was slowly, subtly, patiently unraveling before our very eyes throughout the first two books, and completely changes the stakes for the third and final book in the original trilogy.

<hr class="book">

<img src="/images/books/mistborn.jpg" class="right" width="128">

<a href="http://amzn.com/0765350386" name="mistborn">Mistborn: The Final Empire</a> --- After finishing [_The Way of Kings_][wok] and absolutely _loving_ it, I decided to try another series from the same author, Brandon Sanderson, taking place within the same _Cosmere_ universe, called _Mistborn_. I decided to do this while I wait for the second book of the _Stormlight Archive_ series, _Words of Radiance_.

The first book in _Mistborn_ is called _The Final Empire_ and it starts out a lot darker than tWoK, although there are actually a lot of parallels once you learn about a plot twist reveal towards the end of tWoK. The world in general is more somber though. The world seems split between the aristocracy and a subjugated class known as the _skaa_. The skaa has for the most part lost all hope after centuries of subjugation.

Membership into these classes is hereditary, determined by a great war that occurred centuries ago. The leader of the winning side, the Lord Ruler---who has reigned for centuries---rewarded all of those that fought for him, and their descendants, by making them members of the aristocracy.

The aristocracy was also rewarded with genes that give them the ability to wield special powers, but very few nobles are actually born with these powers. "Half-bloods" between the aristocracy and the skaa are forbidden and hunted down. There are different kinds of powers, and they're all triggered by consuming certain metals, depending on the power, and "burning" them. Those born with the powers actually only manifest the ability to wield one of these powers, those people are referred to as _Mistings_. Even rarer are those who can wield all of the powers, known as _Mistborns_. That is, it's no powers, one power, or all powers.

The story is written from multiple POVs, but the story originates from a character whom intends to overthrow the ruling government which has been in power for centuries. He is faced with the difficult task of rousing up a group of people that have been subjugated for centuries, whom regard their oppressive ruler as their god, and their subjugation as deserved.

This is the second book I read by Sanderson and it proves to me that he's a very skilled writer. Everything he writes is very intricately planned, making for very detailed and skillfully-weaved plot threads that are always neatly resolved by the end of his books.

[wok]: #wok

*[tWoK]: The Way of Kings

<hr class="book">

<img src="/images/books/debugging.jpg" class="right" width="128">

<a href="http://amzn.com/1593271743" name="gdb">The Art of Debugging with GDB, DDD, and Eclipse</a> [[notes](/notes/gdb/)] --- Another great book by No Starch Press, publishers of TLPI. I unfortunately never really spent the time to really understand how to use debuggers past basic functionality, in this case [GDB]. I knew enough to get by, but it always seemed a little archaic or very complicated, instead opting for so-called "printf debugging," in which one simply adds a bunch of print statements to find the source of various problems. This, I've come to realize, is an exercise in masochism. Really learning the various tools available to one through a debugger is enlightening.

[GDB]: http://www.gnu.org/software/gdb/

<hr class="book">

<img src="/images/books/wayofkings.jpg" class="right" width="128">

<a href="http://amzn.com/B003P2WO5E" name="wok">The Way of Kings</a> --- My brother had a physical copy of this book lying around for months because he read on reddit that it was a very good book, but I paid no attention to it.

However, after recently finishing the _A Song of Ice and Fire_ [prequels], I was left with a craving for that kind of world, so I checked online and saw that the general consensus was that it was indeed a very good book. It's written by Brandon Sanderson, whom I wasn't familiar with, but he already had other popular series, and also masterfully finished the late Robert Jordan's _The Wheel of Time_ by writing books 12 through 14, judging by their critical reception.

This has become my favorite book. I think it's the best book I've ever read.

The series is called _The Stormlight Archive_. The setting is the typical medieval fantasy world, somewhat like the one from _A Song of Ice and Fire_. It's a little heavier on the magic, but only slightly, and it's treated similar to how it's treated in ASOIAF: there are magical items in the world, but they are scarce, and people don't really understand how they work because they were created thousands of years ago. It has many _very_ interesting concepts that I've come to love.

It's around the same length as the typical ASOIAF book, and has POV chapters as well, though not in as strict a fashion as ASOIAF. _The Stormlight Archive_ will eventually consist of 10 books, and this series itself belongs to a larger universe referred to as _The Cosmere_ which will eventually consist of 36 books.

[prequels]: http://en.wikipedia.org/wiki/Tales_of_Dunk_and_Egg

*[ASOIAF]: A Song of Ice and Fire
*[POV]: Point of View

<hr class="book">

<img src="/images/books/scala.jpg" class="right" width="128">

<a href="http://amzn.com/0981531644" name="scala">Programming in Scala</a> [[notes](/notes/scala/)] --- This is a book about Scala by the person that designed the language. The book is pretty inconsistent in the topics it approaches and how it approaches them. Some topics, like software testing, received very shallow coverage, to the point where I wondered why it was included at all. Other topics were covered perhaps a bit too in-depth, such as the collections API which has multiple chapters devoted to it, one of them being very long and plastered with API references that could have easily been left to the Internet, or a chapter on the rationale behind the collections API's design and implementation.

However, the coverage of the language was pretty good, perhaps as good as it can get considering that it came from the language's designer himself. I've yet to form an opinion on the language since I haven't really created anything with it, but at face value, I think I prefer Haskell.

<hr class="book">

<img src="/images/books/algorithms.jpg" class="right" width="128">

<a href="http://amzn.com/032157351X" name="algorithms">Algorithms</a> [[notes](/notes/algorithms/)] --- I've been refreshing my knowledge of algorithms using this book by Sedgewick. I chose this one for this purpose because it seems to strike a balance between the catalog-formatted coverage of Skiena's book and the in-depth analysis of the classic CLRS. So far it has worked perfectly fine, at times looking to CLRS for more information.

Only one thing really bothered me about the book and that is that it teaches left-leaning red-black trees---a creation of the author himself---instead of classical red-black trees, _without_ warning the reader. The main claim to LLRBs that I'm aware of is that they're simpler to teach because they're more consistent, only allowing left-leaning red links, thereby reducing every imbalance to a matter of rotating into left-leaning red links.

I discovered that the book was teaching LLRBs and not classical RB trees when it got around to "explaining" deletion from LLRBs, in quotes because it left it as an "exercise to the reader." Granted, it provided solution code to the exercise but I figured that I would find some more information online to reinforce my understanding; RB tree deletion is notoriously complex. Of course, every explanation and implementation I found online was entirely different from the red-black trees the book explained.

I ended up reading through the wikipedia page on red-black trees, which is one of the most dense articles I've read, even just the deletion section was pretty dense. However, the actual implementation was pretty straightforward, so much so apparently that even the Linux kernel uses it.

<hr class="book">

<img src="/images/books/tlpi.jpg" class="right" width="128">

<a href="http://amzn.com/1593272200" name="tlpi">The Linux Programming Interface</a> --- This book concerns the POSIX API as defined by various standards, e.g. POSIX.1-2001/SUSv3, POSIX.1-2008/SUSv4, and platform-specific deviations. It has an emphasis on Linux, at times covering Linux-specific APIs such as epoll and inotify. The book comes in at a hefty 64 chapters and 1500+ pages, covering every possible topic including signals, processes, threads, interprocess-communication (IPC), sockets, terminals and pseudoterminals, evented I/O, and more.

At the time of writing, the book's reviews consist of 52 five-star reviews and one four-star review (simply because the reviewer didn't like the binding, which I think is excellent). It took me many months to finish, in part from becoming distracted by other books, but it was worth it because every chapter connected many dots, triggering epiphanies left and right. It is liberating to have this much of a deeper understanding of Linux and POSIX systems in general.

<hr class="book">

<img src="/images/books/cppprimer.jpg" class="right" width="128">

<a href="http://amzn.com/0321714113" name="cpp-primer">C++ Primer</a> [[notes](/notes/cpp/)] ---  The 5th edition of the book was specifically updated for the new C++11 standard release. At one point I came to the realization that I didn't have enough experience with C++, and that my understanding of it was hazy at best. Recognizing this, I dedicated myself to bettering my understanding of C++ by rereading a book I already had on C++. However, I felt I was missing out on the new C++11 features that were recently introduced.

C++ Primer is what I look for in every programming book. It is direct and to the point, thanks in part to the assumption that the reader is already familiar with programming, or even C++ itself. It diligently scours every nook and cranny of the C++11 standard, almost reading as a commentary of it, and in so doing, masterfully conveys the various intricacies of shared and unique pointers, move semantics, lambdas, variadic templates, and more.

<hr class="book">

<img src="/images/books/lyah.jpg" class="right" width="128">

<a href="http://amzn.com/1593272839" name="lyah">Learn You a Haskell</a> --- This book is [freely available](http://learnyouahaskell.com/) online, but I decided to buy it in print form to support the author. This was the first book I read on the subject of Haskell. However, after a few chapters I felt it was more concerned with the theory than practical usage of Haskell, so I decided to switch over to _Real World Haskell_.

After reading RWH, however, I had an insatiable interest in Haskell, and so I wanted to see if I had missed anything of note in this book, so I continued where I had left off. Indeed, after having seen practical uses of Haskell in RWH, I developed an appreciation for the theory that LYAH preoccupied itself with and came to appreciate it's more in-depth analysis of functors, applicative functors, monoids, and monads.

<hr class="book">

<img src="/images/books/rwh.jpg" class="right" width="128">

<a href="http://amzn.com/0596514980" name="rwh">Real World Haskell</a> --- This book is [freely available](http://book.realworldhaskell.org/read/) online, which is how I read it. I initially bought _Learn You A Haskell_, but I felt like it beat around the bush too much. Conversely, I found _Real World Haskell_ refreshingly direct and practical, living up to its name.

For the longest time I had wanted to learn Haskell, but I wanted to learn it in a practical context so that I may develop a realistic idea of what I can do with it. Specifically, I learned Haskell for the purpose of doing some digital signal processing in order to create a music visualizer. This book was very direct with regard to its teaching practical usage of Haskell. As a result, I was able to see how functors, applicative functors, monoids, monads, monad transformers---and other seemingly-abstract concepts---actually helped in developing real-world applications.

<hr class="book">

<img src="/images/books/dspguide.jpg" class="right" width="128">

<a href="http://amzn.com/0966017633" name="dspguide">The Scientist and Engineer's Guide to Digital Signal Processing</a> --- This book is [freely available](http://www.dspguide.com/pdfbook.htm) online. I initially began reading it in PDF format, but found it to be so good that I decided to buy the book to support the author.

For the longest time I had wanted to learn digital signal processing, but I had absolutely no idea where to begin. I had heard of some books that were deemed "classic" and thus oft-recommended, but these books were heavy-handed with the math and a bit too abstract for a beginner.

This book, on the other hand, was exactly what I needed, and best of all it was available for _free_ online. Right from the start it got right down to business and began teaching fundamental DSP concepts in ways that were very simple to visualize. For example, it explained the concept of convolution through an imaginary "[convolution machine](http://www.dspguide.com/ch6/4.htm)," which forms the basis of my [naive implementation](/posts/naive-convolution-in-haskell/) of convolution in Haskell.

Best of all, however, was that it provided example algorithm implementations of every concept it discussed. I feel this is a testament to the author's foresight, as the book was written during a transitional period in which DSP was beginning to shift from dedicated hardware to general purpose CPUs.

<hr class="book">

<img src="/images/books/direct3d11.jpg" class="right" width="128">


<a href="http://amzn.com/1936420228" name="d3d11">Introduction to 3D Game Programming with DirectX 11</a> --- After reading the 3D Math book mentioned below, I wanted to learn a graphics API to apply my newfound knowledge. I was previously familiar with basic, "immediate mode" OpenGL. However, modern graphics development favors the programmable pipeline, in which one uploads the vertex buffer to the GPU and writes vertex and pixel/fragment shaders to operate on that data.

I decided to choose Direct3D 11 as the API to learn because I felt it would be a bit more organized and consistent than OpenGL (cf. extensions), OpenGL's advantages notwithstanding. Indeed, I found the Direct3D 11 API to be pretty clean and straightforward. With it I covered traditional lighting, texturing, blending, stenciling, as well as the newer functionality like geometry, compute, and tessellation shaders. The book also covered some more advanced topics such as cube, normal, and displacement mapping, particle systems with stream-out, shadow mapping, and ambient occlusion.

<hr class="book">

<img src="/images/books/3dmath.jpg" class="right" width="128">

<a href="http://amzn.com/1568817231" name="3dmath">3D Math Primer for Graphics and Game Development</a> --- For the longest time I struggled with comprehending linear algebra and other 3D graphics-related math. I could understand the concepts on their own, but not how they related to 3D graphics. I had trouble visualizing the mathematical operations.

This book helped me to not only understand it, but fall in love with it. This is one of the highest quality books that I'm proud to have on my shelf. It is a nice hard-cover book with beautiful cover art and luminous, thick pages. It's also littered with very informative color illustrations. I say all this because the writing of the book is perfect, making for an overall masterpiece of a book. It masterfully explains the mathematical operations relevant to 3D graphics and helps visualize their operation.

This book helped me understand how matrices encode coordinate space transformations which can easily be concatenated, the utility of homogeneous coordinates in perspective projection, the pros & cons of various orientation representations (Polar Coordinates, Euler Angles, Axis-Angle, and Quaternions), Quaternion spherical linear interpolation ([slerp](http://en.wikipedia.org/wiki/Slerp#Quaternion_Slerp)), and many more concepts of the modern GPU pipeline within a mathematical context.

<hr class="book">

<img src="/images/books/iosnerdranch.jpg" class="right" width="128">

<a href="http://amzn.com/0321773772" name="ios">iOS Programming: The Big Nerd Ranch Guide</a> --- I had previously read a book on the iOS SDK but, while it wasn't bad, I found it lacking in depth. On the other hand, this book was packed with content covering topics including view controllers, various controls, notifications, multitasking, localization, Core Animation, Objective-C Blocks (i.e. lambdas), background execution, and push notifications.

Most of this information is easily available in the Apple documentation. Instead, I used this book more like a tour of various SDK features to get an idea of what kinds of things could be achieved.

<hr class="book">

<img src="/images/books/hfdesignpatterns.jpg" class="right" width="128">

<a href="http://amzn.com/0596007124" name="headfirst-designpatterns">Head First Design Patterns</a> --- The experience of many developers over decades has yielded a variety of common patterns which have become essential in solving a certain kinds of problems. This book is covers a few of these patterns in a straightforward manner.

Admittedly, in my opinion, while it was fun to read and achieved its purpose, ultimately the over-use of pictures and figures, and the very contrived example use cases made it feel very indirect. I feel I could've saved more time by simply getting the classic Gang of Four [Design Patterns](http://amzn.com/0201633612) book, which serves as more of a catalog of different design patterns with direct explanations and examples.

<hr class="book">

<img src="/images/books/metaruby.jpg" class="right" width="128">

<a href="http://amzn.com/1934356476" name="metaprogramming-ruby">Metaprogramming Ruby</a> --- Ruby has a tradition of employing metaprogramming techniques in various libraries to create DSLs that make programming a lot simpler or straightforward, as is evident in libraries like Rails, Sinatra, Cucumber, or any other significant Ruby library.

This book covers the details on how the language really lends itself to metaprogramming through mechanisms such as `method_missing()`, `instance_eval()`, and `define_method()` that allow one to dynamically add methods and functionality to classes at run-time. Perhaps most important is its coverage of the Ruby object model (hierarchy) complete with Eigenclasses, and how method calls are resolved in this grand context.

*[TLPI]: The Linux Programming Interface
*[LYAH]: Learn You a Haskell
*[RWH]: Real World Haskell
*[DSP]: Digital Signal Processing
